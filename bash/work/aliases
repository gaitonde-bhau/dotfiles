#!/usr/bin/env bash

# Identify the current shell
[[ ! $0 =~ "bash" ]] && return

# If xterm, put cwd in title
#setenv HOST `hostname`
#alias xsettitle 'echo -n "]2;${HOST}:\!*"'
#if ("$TERM" == "xterm") then
#  alias precmd 'xsettitle $cwd; set prompt = "<%c> "'
#else
#  alias precmd 'set prompt = "<%c> "'
#endif


#=======================================================================================================================
# EDITOR                                                                                                           {{{1
#=======================================================================================================================
gvim_server() {
  # There is no way to automatically launch a server if one doesn't exist when using --remote-send
  # Thus, check if --remote-send has been passed in and if a server doesn't exist create one
  # NOTE: ${STEM^^} converts $STEM to uppercase. vim servernames are always in uppercase
  if [[ "$*" =~ --remote-send ]] && [[ -n "$STEM" ]] &&
     [[ ! $(command vim --serverlist | command grep "${STEM^^}" 2> /dev/null) ]]; then
    gvim --servername "$STEM"
  fi
  gvim ${STEM:+--servername $STEM} "$@"
}
alias v=gvim_server
alias vc='gvim_server --remote-silent'

# Open results of a previous command in a quickfix window in a remote vim eg.
# $ rg PATTERN
# $ vq --vimgrep
vq() {
  eval "$(fc -nl -1) $@ >| /tmp/vimqf"
  gvim_server --remote-send ":silent -tabnew|lcd $PWD|silent cfile /tmp/vimqf"
}

vlog() {
  local _comp=$(command grep -o 'error.*component=\S\+' sim.out | sed 's/.*=//')
  if [[ $_comp == "sim.out" ]] || [[ ${_comp}.log == *AggL3.log ]] || [[ ${_comp}.log == *L3Seq.log ]]; then
    _comp=""
  else
    _comp=${_comp:+${_comp}.log}
  fi
  local _files=()
  for i in sim.out ${_comp} *AggL3.log *AggL3Seq.log; do
    if [[ -f "$i" ]]; then
      _files=("${_files[@]}" "$i")
    fi
  done
  vim -p "${_files[@]}" "$@" -c 'set nobackup' -c 'set autoread' -c 'silent! /error:\|Backtrace:' -c 'silent! "norm zt"'
}

alias e="emacs_func ${STEM+--socket-name=${STEM//\//_}}"


# Project Aliases
# alias as_bsub="lsf_bsub -Is -R 'rusage[mem=2000]' -q high -P aspen-ver"

# Building and Compiling
mkv() { mkverdi -novericom $(command grep -Po '\-model\s*\S+' sim.out) -rc ~/novas.rc -guiConf ~/novas.conf -tkName "verdi_$(tmux display-message -p '#S:#I.#P')" "$@" & }
alias findFirstError='findFirstError --tkName "verdi_$(tmux display-message -p "#S:#I.#P")"'
alias cid='cat ${REPO_PATH+$REPO_PATH/}configuration_id'

bj() {
  local _fmt_str="id:8"
  [[ "$*" =~ -u ]] && _fmt_str="$_fmt_str user:9"
  _fmt_str="$_fmt_str stat:6 queue: submit_time:13"
  [[ "$*" =~ -d ]] && _fmt_str="$_fmt_str finish_time:13 exit_code:"

  command lsf_bjobs -o "$_fmt_str name" "$@"
  # lsf_bjobs -w "$@" | perl -aF"\s+" -lne 'printf("%-7s  %-8s  %-4s  %-9s  %-14s  %-10s  %-12s  %s\n", ($. == 1 ? @F[0..5,7,6] : @F[0..5],"@F[$#F-2..$#F]","@F[6..$#F-3]"))'
}
bjg() {
  bj >| /tmp/$$
  head -n 1 /tmp/$$

  if (( $# == 0 )); then
    grep "$$" /tmp/$$
  else
    grep "$@" /tmp/$$
  fi
}
alias bk='lsf_bkill'
alias bq='lsf_bqueues'

vv() { vv -tkName "verdi_$(tmux display-message -p '#S:#I.#P')" & }

alias wtf='WhyTheFail'
alias lmn='ljd -nomail -l'
alias rcf=$'recreate_fail -switches \'-avf "-TestCompressedLog 0 --agg_dump_on"\''
alias trapbug='P4DIFF= s_trapbug -bug'


# Misc
alias rr='~/bin/rerun'
alias rrb='rr --norun --build --recompile'
alias rrbr='rr --build --recompile'
alias rrc='rr --norun --clean'
alias rrca='build -clean_all'
alias rrcb='rr --norun --clean --build --recompile'
alias rrcr='rr --clean'
alias rrdbg=$'rr --add \'-avf "--/L3.Debug.*Graph/ --/L3.Debug.*Resources/"\' --dsp'
alias rrr='rr --norun --recompile'

alias rg='release_gate -gui'
alias rgd='release_gate -donate'
alias rgg='release_gate_gui'
rgfq() {
  command grep FAILED $STEM/release_gate_tmp/release_gate.log |
  command awk '{print $1}' |
  command sed -r -e 's/(build|sim)_/-/' -e 's/_(m)?rg(\w*)\.[0-9]+$/_\1rg\2/' |
  command paste -s -d' '
  # echo -e "rg -noauto $_fq\n"
  # rg -noauto $_fq
}

rgre() {
  # Because release_gate -redeploy doesn't work
  local _cmd="$(command grep -Po "(?<=command line is ')[^']*" $STEM/release_gate_tmp/release_gate.log)"
  echo "$_cmd"
  eval "$_cmd"
}

alias perr="perl -ne 'print if /error:/../:error/;exit if /:error/'"
bu()   { bucket "$@"; }
bus()  { bucket -s "$@"; }
bu1()  { bucket -n 1 "$@"; }
bu1w() { watch --no-title -n 60 "bucket -n 1 $@"; }
busw() { watch --no-title -n 60 "bucket -s $@"; }
alias toclippy="sed -e 's/$/
/' | tee ~/clippy.txt"

# LANG=C is the default setting at the system level. That causes xterm to not display unicode characters correctly.
# Setting LANG=en_US.UTF-8 seems to get rid of the font rendering issues but causes a bunch of other side-effects which
# are hard to figure out and harder to work-around. So I'm keeping LANG=C to avoid them (the devil you know...)
# To get xterm to render the font correctly I force the encoding while starting it
alias xt='xterm -en en_US.UTF-8'
# alias xtr='echo "resize -s 62 273"; resize -s 62 273'
# alias xtr='wmctrl -i -r $(xdotool getactivewindow) -e 0,1920,25,1918,1144; wmctrl -i -r $(xdotool getactivewindow) -b add,maximized_vert'
alias tmxvnc='tmux new-window -d -n "XVNC" "x11vnc"'



#=======================================================================================================================
# PERFORCE                                                                                                         {{{1
#=======================================================================================================================
alias pf='p4w'
alias pfa='p4 add'
alias pfchk='pf sanity_check 2> >(perl -pe "exit if m{^Sanity checking $STEM[^:]}")'
alias pfd='p4 diff'
alias pfd2='p4diff2'
alias pfdg='P4DIFF= p4 diff -du | grepdiff --output-matching=hunk'
alias pfe='p4 edit'
alias pfh='pf help'
alias pfo='p4 opened'
alias pfco='p4_mkwa -change_branch'
alias pfres='p4 resolve'
alias pfrev='p4 revert'
alias pflog='p4 filelog -stl -m 5'
pftop() {
  local num=10
  if (( $# > 0 )) && [[ "$1" =~ ^[0-9]+$ ]]; then
    num=$1
    shift
  fi
  p4 changes -m $num "$@" $STEM/...
}
alias pfs='p4w submit'

# pfop() {                                                                                                         #{{{2
#   while read; do
#     local d=$(sed -e 's/#.*$//' <<< $REPLY);
#     local f=$(p4 where $d | cut -d " " -f3);
#     sed "s:$d:$f:" <<< $REPLY;
#   done < <(p4 opened)
# }

pfor() {                                                                                                           #{{{2
  if (( $# > 0 )); then
    p4 opened "$@"
  else
    p4 opened
  fi | sed -r -e "s:^//depot/[^/]*/(trunk|branches/[^/]*):$STEM:" -e "s:$PWD/::" -e 's/#.*//'
  # fi | sed -r -e "s:^//depot/[^/]*/(trunk|branches/[^/]*):$STEM:" -e "s:$PWD/::" | column -s# -o '    #' -t | column -s- -o- -t
}

pfu() {                                                                                                            #{{{2
  # Save ENV variables
  local _env_tmux=$TMUX
  local _env_tmux_pane=$TMUX_PANE

  if [[ $(p4w opened 2> /dev/null) != "" ]] && \
     [[ -f $STEM/pre-update/configuration_id ]] && \
     [[ "$(head -n1 $STEM/configuration_id)" != "$(head -n1 $STEM/pre-update/configuration_id)" ]]; then
    echo "Creating a patch of the changes before updating..."
    patch_capture -r -p pre-update > /dev/null
    command cp $STEM/configuration_id $STEM/pre-update
  fi

  echo p4w update_env "$@"
  p4w update_env "$@"
  local ret=$?

  # Restore ENV variables
  export TMUX=$_env_tmux
  export TMUX_PANE=$_env_tmux_pane

  [[ $ret == 0 ]] && __wa_setup
}

pful() {                                                                                                           #{{{2
  local _changelist="latest"

  # If a valid username is provided then grab latest changelist by that user
  if (( $# == 1 )) && id $1 > /dev/null; then
    # FIXME: Filter out pending changelists
    _changelist=$(p4 changes -m1 -u $1 | awk '{print $2}')
  fi

  pfu "@$_changelist"
}

# Generate a list of relevant files
pfls() {                                                                                                           #{{{2
  [[ -z $STEM ]] && return 1

  cat \
    <(cd $STEM; p4 have ... 2> /dev/null) \
    <(cd $STEM; p4 opened ... 2> /dev/null | command grep add \
      | command sed "s/#.*//" | command xargs -I{} -n1 p4 where {}) \
    | command awk '{print $3}' >| $STEM/.filelist
}

# ripgrep + perforce                                                                                               #{{{2
pff() {
  command rg --no-line-number --no-heading --color=never "$@" ${STEM:+$STEM/}.filelist
}
p4f() {
  command p4 have $STEM/... | command rg --no-line-number --no-heading --color=never "$@"
}

alias pfg='rgf --files-from=$STEM/.filelist'
# }}}2



#=======================================================================================================================
# WORKAREA                                                                                                         {{{1
#=======================================================================================================================
# Declaring these as environment variables instead of regular ones allows access from within vim
make_wa_vars() {                                                                                                   #{{{2
  local _proj _ch _wa _scr
  for _proj in as ah br nv; do
    case $_proj in
      as) local _proj_full=ASPEN;;
      ah) local _proj_full=ASPEN_HIGHLANDS;;
      br) local _proj_full=BRECKENRIDGE;;
      nv) local _proj_full=NV21_EL3;;
    esac

    for _ch in {0..1}; do
      eval "export ${_proj}${_ch}='/proj/ch_func_dev${_ch}/${_proj_full}'"
      eval "export ${_proj}${_ch}ks='/proj/ch_func_dev${_ch}/${_proj_full}/kshenoy'"
      for _wa in {1..6}; do
        eval "export ${_proj}${_ch}${_wa}='/proj/ch_func_dev${_ch}/${_proj_full}/kshenoy/${_proj}${_ch}${_wa}'"
      done
    done

    for _scr in {0..2}; do
      eval "export ${_proj}s${_scr}='/proj/ch_func_gen_scratch${_scr}/${_proj_full}/kshenoy'"
    done
  done
}
make_wa_vars

# Dynamic variables (Recomputed everytime path changes via preprompt or equivalent)
# If $REPO_PATH is set, expand ${...} to $REPO_PATH/ (append trailing slash)
# This allows us to use $rtl etc as an absolute path when $REPO_PATH is set and when bootenv isn't done, as a relative path
#
# Note that something similar could be achieved by setting CDPATH=$REPO_PATH
# And as long as we're in a CH workarea, all the below variables should work the same
# However, if we're in a non-CH repository like VH then it'll not work.
# Hence, I've created explicit variables by basing them off ch which in turn is set based on the value of ANCHOR_ch
dyn_vars() {                                                                                                       #{{{2
  export ch="${ANCHOR_ch-ch}"
  export r="${ch}/rtl"
  export tb="${ch}/tb"
  export tc="${ch}/tc"
  export v="${ch}/verif"
  export cl3="${v}/chk_l3"
  export vcov="${v}/coverage"
  export l3="${v}/l3"
  export txn="${v}/txn"
  export avf="${ANCHOR_avf-import/avf}"
  export reg="${ANCHOR_aspen_regs-meta/registers}"
  export sim="${STEM+$STEM/}sim"
}
dyn_vars


mkwa() {                                                                                                           #{{{2
  _mkwa_help() {
    echo 'SYNTAX:'
    echo '  mkwa PROJ[/BRANCH=PROJ_trunk][@CHANGELIST=latest]'
    echo '  mkwa tb_env'
  }

  if [[ -f "$1" ]]; then
    local _temp=$(sed 's/p4_mkwa\s\+-configuration_id\s\+//' "$1")
  else
    local _temp=${1}
  fi

  local _proj=""
  local _branch=""
  local _cl=""
  local _fg_red=$(tput setaf 1)
  local _fg_green=$(tput setaf 2)
  local _reset=$(tput sgr0)

  if [[ "${_temp}" =~ @ ]]; then
    local _cl=" -changelist ${_temp#*@}"
    _temp=${_temp%@*}
  fi
  # echo $_temp

  if [[ "$_temp" =~ / ]]; then
    local _branch=" -branch_name ${_temp#*/}"
    _proj=${_temp%/*}
  else
    _proj=$_temp
  fi
  # echo $_temp

  case ${_proj} in
    as) _proj="aspen" ;;&
    ah) _proj="aspen_highlands" ;;&
    br) _proj="breckenridge" ;;&
    cb) ;;&
    nv) _proj="nv21_el3";;
    vh) _proj="valhalla" ;;&
    zn) _proj="zen" ;;&
    *)
      if [[ -z "${_proj}" ]]; then
        echo -e "${_fg_red}ERROR${_reset}: Project not specified\n"; _help
        return 1
      fi
      ;;
  esac

  # Save ENV variables
  local _env_tmux=$TMUX
  local _env_tmux_pane=$TMUX_PANE

  local _cmd="p4_mkwa -codeline ${_proj}${_branch}${_cl}"
  echo -e "${_cmd}\n"
  . /proj/verif_release_ro/cbwa_initscript/nodisk_current/cbwa_init.bash && export LANG=en_US.UTF-8
  $_cmd

  # Restore ENV variables
  export TMUX=$_env_tmux
  export TMUX_PANE=$_env_tmux_pane

  __wa_setup
}


wa_list() {                                                                                                        #{{{2
  local _proj _ch _wa _path
  for _ch in {0..1}; do
    for _proj in as ah br; do
      local _proj_long=$(sed -e 's/as/ASPEN/' -e 's/ah/ASPEN_HIGHLANDS/' -e 's/br/BRECKENRIDGE/' <<< $_proj)
      for _wa in {1..6}; do
        _path="/proj/ch_func_dev${_ch}/${_proj_long}/kshenoy/${_proj}${_ch}${_wa}"
        if [[ -d ${_path} ]] && [[ "$(ls -A ${_path})" ]]; then
          if [[ -t 1 ]]; then
            echo ${_path}:
            ls ${_path} | command grep '/$' | sed 's/^/  /'
          else
            find ${_path} -mindepth 1 -maxdepth 1 -type d -not -name '\.*'
          fi
        fi
      done
    done
  done
}


alias benv='. /proj/verif_release_ro/cbwa_initscript/nodisk_current/cbwa_init.bash && bootenv && __wa_setup'
lenv() {                                                                                                           #{{{2
  # Save ENV variables
  local _env_tmux=$TMUX
  local _env_tmux_pane=$TMUX_PANE
  local _old_pwd=$PWD

  local _workarea=${1:-$PWD}
  if [[ -L ${_workarea} ]]; then
    _workarea=$(readlink ${_workarea})
  fi
  if [[ -f ${_workarea} ]]; then
    _workarea=$(dirname ${_workarea})
  fi
  echo "loadenv into ${_workarea}"

  command pushd "${_workarea}" > /dev/null
  . /proj/verif_release_ro/cbwa_initscript/nodisk_current/cbwa_init.bash && loadenv
  local ret=$?

  # Restore ENV variables
  export TMUX=$_env_tmux
  export TMUX_PANE=$_env_tmux_pane

  __wa_setup

  [[ -z "$STEM" ]] && return

  local _new_wd=${_old_pwd/*${STEM//\//_}/$STEM}
  [[ -d "$_new_wd" ]] && command pushd "${_new_wd}" > /dev/null
}

__wa_setup() {                                                                                                     #{{{2
  # Source aliases etc.
  source ~/.dotfiles/bash/aliases && source ~/.dotfiles/bash/bashrc-func && echo Sourced aliases and functions

  [[ -z "$STEM" ]] && return
  for proj in 'AS|ASPEN' 'AH|ASPEN_HIGHLANDS' 'BR|BRECKENRIDGE' 'NV21_EL3'; do
    if [[ $STEM =~ /proj/ch_func_dev[[:digit:]]/($proj) ]]; then
      export PROJ_HOME=$(sed -r -e "s:(/proj/ch_func_dev[[:digit:]]?/($proj)/).*:\1:" <<< "$STEM")$(whoami)
      break
    fi
  done
  [[ ! -d "$PROJ_HOME" ]] && return

  for i in $PROJ_HOME/.bashrc; do
    [[ -f ${i} ]] && . ${i} && echo "Sourced ${i}"
  done

  pfls &

  # Create tags
  local _fg_green=$(tput setaf 2)
  local _reset=$(tput sgr0)
  echo "${_fg_green}[Generating tags...]${_reset}"
  ~kshenoy/bin/gentags &

  # Start emacs daemon if one isn't present
  # [[ -n "${_workarea}" ]] && ~kshenoy/bin/emacs_daemon -s ${workarea//\//_} &> /dev/null &
}

pfrem() {                                                                                                          #{{{2
  local _workarea=$(readlink -f ${1:-${REPO_PATH:-$PWD}})
  if [[ $_workarea != $REPO_PATH ]]; then
    command cd $_workarea
    . /proj/verif_release_ro/cbwa_initscript/nodisk_current/cbwa_init.bash
    loadenv
  fi

  local _scratch_dir=$(readlink -f ${_workarea}/build | command sed 's/build$//')
  echo -e "\nDeleting workarea: '$_workarea'"
  cd $_workarea/..

  p4w remove $_workarea
  local _exit_code=$?
  if (( $_exit_code != 0 )); then
    return $_exit_code;
  fi

  echo -e "\nDeleting workarea from scratch disk..."
  echo "  command rm -rf $_scratch_dir"
  rm_rf_silent $_scratch_dir

  # Kill emacs daemon. Use explicit path to avoid kill any other daemons
  ~kshenoy/bin/emacs_daemon -k ${_workarea//\//_}
}

trapbug_rm() {                                                                                                     #{{{2
ssh atlvsub01 xargs /home/ainfra/bin/rm_defunct_bug_data --bug_data_path /proj/aspen_bug_data/ASPEN --bug_dirs << BUGS
"$@"
BUGS
}
# }}}2
# }}}1


# Calling these as gpp/clangpp as I don't want it to interfere with my regular build flow
gpp() {
  g++ -Wall -Wextra -std=c++14 \
    -L${GCC_HOME}/lib -L${BOOST_HOME}/lib -L${HOME}/.local/lib \
    -I${BOOST_HOME}/include -I${HOME}/.local/include \
    -Wl,-rpath ${BOOST_HOME}/lib "$@"
}
clangpp() {
  clang++ -Wall -Wextra -std=c++14 \
    -L${LLVM_HOME}/lib -L${BOOST_HOME}/lib -L${HOME}/.local/lib \
    -I${BOOST_HOME}/include -I${HOME}/.local/include \
    -Wl,-rpath ${BOOST_HOME}/lib "$@"
}

psig() {
  perl -lne 'if(/^\s+-+$/../^\s*$/){if(/^\s+-+$/){$c=0;}elsif(/^\s*$/){print "  ($c) $s";}else{$c++;}}else{s/^\s+|\s+$//g;$s=$_}' $1
}

rgsig() {
  for i in $(command grep FAIL ${REPO_PATH+$REPO_PATH/}release_gate_tmp/release_gate.log | colm -1); do
    local _sim=${i##*release_gate_tmp/}
    _sim=${_sim%%/*}
    echo -e "\n${_sim}";
    psig $i;
  done
}

rgww() {
  for i in $(command grep FAIL ${REPO_PATH+$REPO_PATH/}release_gate_tmp/release_gate.log | colm -1); do
    local _sim=${i##*release_gate_tmp/}
    _sim=${_sim%%/*}
    echo -e "\n${_sim}";
    pww $i | sed 's:/.*/\(release_gate_tmp/\):$STEM/\1:'
  done
}

plastlock() {
  for i in $*; do
    echo -e "\n$i:"
    perl -ne 'if(/BUS_LOCK|SYS_MGMT/){$p="";}$p.=$_;END{print $p;}' $i
  done
}

vsig() {
  file_lnum=$(command grep -Po -m1 '(?<=source\=)[^:]+:\d+' summary.rj)
  file=${file_lnum%:*}
  lnum=${file_lnum#*:}

  file=$(pff ${file})

  # echo "File=${file} Line=${lnum}"
  vc +$lnum $file
}

tel() {
  while (( $# > 0 )); do
    getent passwd $1 | \
    perl -aF/[:,]/ -lne 'map(s/^\s+//,@F);print "ID:;$F[0]\nName:;$F[4]\nCube:;$F[5]\nExt:;$F[6]"' | \
    /usr/bin/column -t -s \;

    shift
    if (( $# > 0 )); then echo "----"; fi
  done
}

dotty() {
  for i in $*; do
    dot -Tgif -o `basename $i .gv`.gif $i
  done
}

but() {
  model=unittest_${1#unittest_}
  shift;

  echo build -model $model
  rerun --norun --build --model $model $@
  local _ret=$?
  if (( $_ret != 0 )); then
    return $_ret;
  fi

  if [[ ${model} =~ _dbg$ ]]; then
    echo gdb $REPO_PATH/build/${model}/${model}
    gdb $REPO_PATH/build/${model}/${model}
  else
    echo $REPO_PATH/build/${model}/${model}
    $REPO_PATH/build/${model}/${model}
  fi
}

wtff() {
  model=`basename ${1%_rg.build.log}`
  wtf -m $model
}


for i in $PROJ_HOME/.bashrc; do
  # Using an explicit if to prevent it from having a non-zero exit status if file doesn't exist
  if [[ -f ${i} ]]; then . ${i} && echo "Sourced ${i}"; fi
done

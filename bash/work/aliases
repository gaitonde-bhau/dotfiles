#!/usr/bin/env bash

# Identify the current shell
MYSHELL=$(basename $(ps h p $$ | /bin/awk '{ print $NF }' | sed 's/-//g'))
if [[ $MYSHELL != "bash" ]]; then
  return;
fi

# If xterm, put cwd in title
#setenv HOST `hostname`
#alias xsettitle 'echo -n "]2;${HOST}:\!*"'
#if ("$TERM" == "xterm") then
#  alias precmd 'xsettitle $cwd; set prompt = "<%c> "'
#else
#  alias precmd 'set prompt = "<%c> "'
#endif


#=======================================================================================================================
# EDITOR                                                                                                            {{{1
#=======================================================================================================================
alias v="gvim_func -c 'set columns=319' ${STEM:+--servername $STEM}"
alias vc='v --remote-silent'

unset -f vlog
vlog() {
  local _comp=$(command grep -o 'error.*component=\S\+' sim.out | sed 's/.*=//')
  if [[ $_comp == "sim.out" ]] || [[ ${_comp}.log == *AggL3.log ]] || [[ ${_comp}.log == *L3Seq.log ]]; then
    _comp=""
  else
    _comp=${_comp:+${_comp}.log}
  fi
  local _files=()
  for i in sim.out ${_comp} *AggL3.log *AggL3Seq.log; do
    if [[ -f "$i" ]]; then
      _files=("${_files[@]}" "$i")
    fi
  done
  vim -p "${_files[@]}" "$@" -c 'set nobackup' -c 'set autoread' -c 'silent! /error:\|Backtrace:' -c 'silent! "norm zt"'
}

alias e="emacs_func ${STEM+--socket-name=${STEM//\//_}}"


# Project Aliases
# alias as_bsub="lsf_bsub -Is -R 'rusage[mem=2000]' -q high -P aspen-ver"

# Building and Compiling
alias sbi='. /proj/verif_release_ro/cbwa_initscript/nodisk_current/cbwa_init.bash'
unset -f mkv
mkv() { mkverdi -novericom $(command grep -Po '\-model\s*\S+' sim.out) -rc ~/novas.rc -guiConf ~/novas.conf -tkName "verdi_$(tmux display-message -p '#S:#I.#P')" "$@" & }
alias findFirstError='findFirstError --tkName "verdi_$(tmux display-message -p "#S:#I.#P")"'
alias cid='cat ${REPO_PATH+$REPO_PATH/}configuration_id'
bj() {
  lsf_bjobs -w "$@" | perl -aF"\s+" -lne 'printf("%-7s  %-8s  %-4s  %-9s  %-14s  %-10s  %-12s  %s\n", ($. == 1 ? @F[0..5,7,6] : @F[0..5],"@F[$#F-2..$#F]","@F[6..$#F-3]"))'
}
bjg() {
  # bj | { command head -1; echo command grep "${1:-$$:}"; }
  bj | command head -1
  bj | command grep "${1:-$$:}"
}
alias bk='lsf_bkill'
alias bq='lsf_bqueues'

vv() { vv -tkName "verdi_$(tmux display-message -p '#S:#I.#P')" & }

alias wtf='WhyTheFail'
alias lmn='ljd -nomail -l'
alias rcf=$'recreate_fail -switches \'-avf "-TestCompressedLog 0 --agg_dump_on"\''
alias trapbug='P4DIFF= s_trapbug -bug'


# Misc
alias rr='~/bin/rerun'
alias rrb='rr --norun --build --recompile'
alias rrbr='rr --build --recompile'
alias rrc='rr --norun --clean'
alias rrca='build -clean_all'
alias rrcb='rr --norun --clean --build --recompile'
alias rrcr='rr --clean'
alias rrdbg=$'rr --add \'-avf "--/L3.Debug.*Graph/ --/L3.Debug.*Resources/"\' --dsp'
alias rrr='rr --norun --recompile'

alias rg='release_gate -gui'
alias rgd='release_gate -donate'
alias rgg='release_gate_gui'
rgfq() {
  command grep FAILED $STEM/release_gate_tmp/release_gate.log |
  command awk '{print $1}' |
  command sed -e 's/\(build\|sim\)_/-/' -e 's/_rg.[0-9]\+$/_rg/' |
  command paste -s -d' '
}

rgre() {
  # Because release_gate -redeploy doesn't work
  eval $(command grep -Po "(?<=command line is ')[^']*" $STEM/release_gate_tmp/release_gate.log)
}

alias perr="perl -ne 'print if /error:/../:error/;exit if /:error/'"
bu()   { bucket "$@"; }
bus()  { bucket -s "$@"; }
bu1()  { bucket -n 1 "$@"; }
bu1w() { watch --no-title -n 60 "bucket -n 1 $@"; }
busw() { watch --no-title -n 60 "bucket -s $@"; }
alias toclippy="sed -e 's/$/
/' | tee ~/clippy.txt"

alias xt='xterm -geometry 318x66+1920+25 & wmctrl -i -r $! -b add,maximized_vert'
# alias xtr='echo "resize -s 62 273"; resize -s 62 273'
alias xtr='wmctrl -i -r $(xdotool getactivewindow) -e 0,1920,25,1918,1144; wmctrl -i -r $(xdotool getactivewindow) -b add,maximized_vert'
alias tmxvnc='tmux new-window -d -n "XVNC" "x11vnc"'



#=======================================================================================================================
# PERFORCE                                                                                                          {{{1
#=======================================================================================================================
alias pf='p4w'
alias pfa='p4 add'
alias pfchk='pf sanity_check 2> >(perl -pe "exit if m{^Sanity checking $STEM[^:]}")'
alias pfd='p4 diff'
alias pfd2='p4diff2'
alias pfdg='P4DIFF= p4 diff -du | grepdiff --output-matching=hunk'
alias pfe='p4 edit'
alias pfh='pf help'
alias pfo='p4 opened'
alias pfco='p4_mkwa -change_branch'
alias pfres='p4 resolve'
alias pfrev='p4 revert'
alias pflog='p4 filelog -stl -m 5'
pftop() {
  local num=10
  if (( $# > 0 )) && [[ "$1" =~ ^[0-9]+$ ]]; then
    num=$1
    shift
  fi
  p4 changes -m $num "$@" $STEM/...
}
alias pfs='p4w submit'

# unset -f pfop
# pfop() {                                                                                                        # {{{2
#   while read; do
#     local d=$(sed -e 's/#.*$//' <<< $REPLY);
#     local f=$(p4 where $d | cut -d " " -f3);
#     sed "s:$d:$f:" <<< $REPLY;
#   done < <(p4 opened)
# }

unset -f pfor
pfor() {
  local _pp='sed -r -e "s:^//depot/[^/]*/(trunk|branches/[^/]*):$STEM:" -e "s:$PWD/::" | column -s# -o "    #" -t | column -s- -o- -t'
  if (( $# > 0 )); then
    eval "p4 opened \"${1}\" | $_pp"
  else
    eval "p4 opened | $_pp"
  fi
}

pfu() {                                                                                                           # {{{2
  # Save ENV variables
  local _env_tmux=$TMUX
  local _env_tmux_pane=$TMUX_PANE

  if [[ $(p4w opened 2> /dev/null) != "" ]] && \
     [[ -f $STEM/pre-update/configuration_id ]] && \
     [[ "$(head -n1 $STEM/configuration_id)" != "$(head -n1 $STEM/pre-update/configuration_id)" ]]; then
    echo "Creating a patch of the changes before updating..."
    patch_capture -r -p pre-update > /dev/null
    command cp $STEM/configuration_id $STEM/pre-update
  fi

  echo p4w update_env "$@"
  p4w update_env "$@"
  local ret=$?

  # Restore ENV variables
  export TMUX=$_env_tmux
  export TMUX_PANE=$_env_tmux_pane

  if [[ $ret != 0 ]]; then return; fi

  local _fg_green=$(tput setaf 2)
  echo "${_fg_green}[Generating tags...]${_reset}"
  ~kshenoy/bin/gentags --create

  __wa_setup
}

pful() {
  local _changelist="latest"

  # If a valid username is provided then grab latest changelist by that user
  if (( $# == 1 )) && id $1 > /dev/null; then
    # FIXME: Filter out pending changelists
    _changelist=$(p4 changes -m1 -u $1 | awk '{print $2}')
  fi

  pfu "@$_changelist"
}

# Generate a list of files
unset -f pf_list
pf_list() {                                                                                                       # {{{2
  if [[ "$1" == "--check" ]] && [[ -f ${STEM:+$STEM/}.filelist ]]; then
    return 0
  fi

  [[ -z $STEM ]] && return 1
  cat <(p4 have) <(cd $STEM/import/avf; p4 have ...) | awk {'print $3'} >| $STEM/.filelist
}

# Find a file
unset -f pff
pff() {                                                                                                           # {{{2
  pf_list --check
  ag --nocolor --no-numbers "$@" ${STEM:+$STEM/}.filelist
}

# Grep from the list of files in the repo
unset -f pfg
pfg() {                                                                                                           # {{{2
  pf_list --check

  local _filter='""'
  if [[ "$1" == "-g" ]]; then
    _filter="$2"
    shift 2
  fi
  # echo $_filter

  # If $_filter is empty, it acts as cat
  echo "ag $@ \$(command grep -P $_filter ${STEM:+$STEM/}.filelist)"
  ag $@ $(command grep -P $_filter ${STEM:+$STEM/}.filelist) 2> /dev/null
}
# }}}2

# -g switch was borrowed from ag
alias pfgtc='pfg --cpp'
alias pfgtch="pfg -g '\.(h|hh|hpp|tpp)$'"
alias pfgtcc="pfg -g '\.(c|cc|cpp|C|CC)$'"
alias pfgtsbs="pfg -g '\.sbs$'"



#=======================================================================================================================
# WORKAREA                                                                                                          {{{1
#=======================================================================================================================
# Declaring these as environment variables instead of regular ones allows access from within vim
unset -f make_wa_vars
make_wa_vars() {                                                                                                  # {{{2
  local _proj _ch _wa _scr
  for _proj in as ah br nv; do
    case $_proj in
      as) local _proj_full=ASPEN;;
      ah) local _proj_full=ASPEN_HIGHLANDS;;
      br) local _proj_full=BRECKENRIDGE;;
      nv) local _proj_full=NV21_EL3;;
    esac

    for _ch in {0..1}; do
      eval "export ${_proj}${_ch}='/proj/ch_func_dev${_ch}/${_proj_full}'"
      eval "export ${_proj}${_ch}ks='/proj/ch_func_dev${_ch}/${_proj_full}/kshenoy'"
      for _wa in {1..6}; do
        eval "export ${_proj}${_ch}${_wa}='/proj/ch_func_dev${_ch}/${_proj_full}/kshenoy/${_proj}${_ch}${_wa}'"
      done
    done

    for _scr in {0..2}; do
      eval "export ${_proj}s${_scr}='/proj/ch_func_gen_scratch${_scr}/${_proj_full}/kshenoy'"
    done
  done
}
make_wa_vars

# Dynamic variables (Recomputed everytime path changes via preprompt or equivalent)
# If $REPO_PATH is set, expand ${...} to $REPO_PATH/ (append trailing slash)
# This allows us to use $rtl etc as an absolute path when $REPO_PATH is set and when bootenv isn't done, as a relative path
#
# Note that something similar could be achieved by setting CDPATH=$REPO_PATH
# And as long as we're in a CH workarea, all the below variables should work the same
# However, if we're in a non-CH repository like VH then it'll not work.
# Hence, I've created explicit variables by basing them off ch which in turn is set based on the value of ANCHOR_ch
dyn_vars() {                                                                                                      # {{{2
  export ch="${ANCHOR_ch-ch}"
  export r="${ch}/rtl"
  export tb="${ch}/tb"
  export tc="${ch}/tc"
  export v="${ch}/verif"
  export cl3="${v}/chk_l3"
  export vcov="${v}/coverage"
  export l3="${v}/l3"
  export txn="${v}/txn"
  export avf="${ANCHOR_avf-import/avf}"
  export reg="${ANCHOR_aspen_regs-meta/registers}"
  export sim="${STEM+$STEM/}sim"
}
dyn_vars


unset -f mkwa
mkwa() {                                                                                                          # {{{2
  _mkwa_help() {
    echo 'SYNTAX:'
    echo '  mkwa PROJ[/BRANCH=PROJ_trunk][@CHANGELIST=latest]'
    echo '  mkwa tb_env'
  }

  if [[ -f "$1" ]]; then
    local _temp=$(sed 's/p4_mkwa\s\+-configuration_id\s\+//' "$1")
  else
    local _temp=${1}
  fi

  local _proj=""
  local _branch=""
  local _cl=""
  local _fg_red=$(tput setaf 1)
  local _fg_green=$(tput setaf 2)
  local _reset=$(tput sgr0)

  if [[ "${_temp}" =~ @ ]]; then
    local _cl=" -changelist ${_temp#*@}"
    _temp=${_temp%@*}
  fi
  # echo $_temp

  if [[ "$_temp" =~ / ]]; then
    local _branch=" -branch_name ${_temp#*/}"
    _proj=${_temp%/*}
  else
    _proj=$_temp
  fi
  # echo $_temp

  case ${_proj} in
    as) _proj="aspen" ;;&
    ah) _proj="aspen_highlands" ;;&
    br) _proj="breckenridge" ;;&
    cb) ;;&
    nv) _proj="nv21_el3";;
    vh) _proj="valhalla" ;;&
    zn) _proj="zen" ;;&
    *)
      if [[ -z "${_proj}" ]]; then
        echo -e "${_fg_red}ERROR${_reset}: Project not specified\n"; _help
        return 1
      fi
      ;;
  esac

  # Save ENV variables
  local _env_tmux=$TMUX
  local _env_tmux_pane=$TMUX_PANE

  local _cmd="p4_mkwa -codeline ${_proj}${_branch}${_cl}"
  echo -e "${_cmd}\n"
  . /proj/verif_release_ro/cbwa_initscript/nodisk_current/cbwa_init.bash && export LANG=en_US.UTF-8
  $_cmd

  # Restore ENV variables
  export TMUX=$_env_tmux
  export TMUX_PANE=$_env_tmux_pane

  if [[ -z "$STEM" ]]; then return; fi

  p4 have | awk {'print $3'} >| .filelist

  # To do misc stuff like sourcing aliases etc.
  __wa_setup

  # Create tags
  echo "${_fg_green}[Generating tags...]${_reset}"
  ~kshenoy/bin/gentags --create
}


unset -f wa_list
wa_list() {                                                                                                       # {{{2
  local _proj _ch _wa _path
  for _ch in {0..1}; do
    for _proj in as ah br; do
      local _proj_long=$(sed -e 's/as/ASPEN/' -e 's/ah/ASPEN_HIGHLANDS/' -e 's/br/BRECKENRIDGE/' <<< $_proj)
      for _wa in {1..6}; do
        _path="/proj/ch_func_dev${_ch}/${_proj_long}/kshenoy/${_proj}${_ch}${_wa}"
        if [[ -d ${_path} ]] && [[ "$(ls -A ${_path})" ]]; then
          if [[ -t 1 ]]; then
            echo ${_path}:
            ls ${_path} | command grep '/$' | sed 's/^/  /'
          else
            find ${_path} -mindepth 1 -maxdepth 1 -type d -not -name '\.*'
          fi
        fi
      done
    done
  done
}


unset -f lenv
lenv() {                                                                                                          # {{{2
  # Save ENV variables
  local _env_tmux=$TMUX
  local _env_tmux_pane=$TMUX_PANE
  local _old_pwd=$PWD

  local _workarea=${1:-$PWD}
  if [[ -L ${_workarea} ]]; then
    _workarea=$(readlink ${_workarea})
  fi
  if [[ -f ${_workarea} ]]; then
    _workarea=$(dirname ${_workarea})
  fi
  echo "loadenv into ${_workarea}"

  command pushd "${_workarea}" > /dev/null
  . /proj/verif_release_ro/cbwa_initscript/nodisk_current/cbwa_init.bash && loadenv
  local ret=$?

  # Restore ENV variables
  export TMUX=$_env_tmux
  export TMUX_PANE=$_env_tmux_pane

  if [[ $ret != 0 ]] || [[ -z "$STEM" ]]; then return; fi

  local _new_wd=${_old_pwd/*${STEM//\//_}/$STEM}
  [[ -d "$_new_wd" ]] && command pushd "${_new_wd}" > /dev/null

  __wa_setup
}

unset -f __wa_setup
__wa_setup() {
  [[ -n "$STEM" ]] && export PROJ_HOME=${STEM%$(whoami)*}$(whoami)

  # Source aliases etc.
  sosa; sosf
  [[ -f ~/.fzf.bash ]] && . ~/.fzf.bash
  [[ -f $PROJ_HOME/.bashrc ]] && . $PROJ_HOME/.bashrc

  # Start emacs daemon if one isn't present
  # [[ -n "${_workarea}" ]] && ~kshenoy/bin/emacs_daemon -s ${workarea//\//_} &> /dev/null &
}

unset -f pfrem
pfrem() {                                                                                                         # {{{2
  local _workarea=$(readlink -f ${1:-${REPO_PATH:-$PWD}})
  if [[ $_workarea != $REPO_PATH ]]; then
    command cd $_workarea
    . /proj/verif_release_ro/cbwa_initscript/nodisk_current/cbwa_init.bash
    loadenv
  fi

  local _scratch_dir=$(readlink -f ${_workarea}/build | command sed 's/build$//')
  echo -e "\nDeleting workarea: '$_workarea'"
  cd $_workarea/..

  p4w remove $_workarea
  local _exit_code=$?
  if (( $_exit_code != 0 )); then
    return $_exit_code;
  fi

  echo -e "\nDeleting workarea from scratch disk..."
  echo "  command rm -rf $_scratch_dir"
  rm_rf_silent $_scratch_dir

  # Kill emacs daemon. Use explicit path to avoid kill any other daemons
  ~kshenoy/bin/emacs_daemon -k ${_workarea//\//_}
}

unset -f trapbug_rm
trapbug_rm() {                                                                                                    # {{{2
ssh atlvsub01 xargs /home/ainfra/bin/rm_defunct_bug_data --bug_data_path /proj/aspen_bug_data/ASPEN --bug_dirs << BUGS
"$@"
BUGS
}
# }}}2
# }}}1


# Calling these as gpp/clangpp as I don't want it to interfere with my regular build flow
gpp() {
  g++ -Wall -Wextra -std=c++14 -L${GCC_HOME}/lib \
    -L${BOOST_HOME}/lib -I${BOOST_HOME}/include -Wl,-rpath ${BOOST_HOME}/lib "$@"
}
clangpp() {
  clang++ -Wall -Wextra -std=c++14 -L${GCC_HOME}/lib \
    -L${BOOST_HOME}/lib -I${BOOST_HOME}/include -Wl,-rpath ${BOOST_HOME}/lib "$@"
}

unset -f psig
psig() {
  perl -lne 'if(/^\s+-+$/../^\s*$/){if(/^\s+-+$/){$c=0;}elsif(/^\s*$/){print "  ($c) $s";}else{$c++;}}else{s/^\s+|\s+$//g;$s=$_}' $1
}

unset -f rgsig
rgsig() {
  for i in $(command grep FAIL ${REPO_PATH+$REPO_PATH/}release_gate_tmp/release_gate.log | colm -1); do
    local _sim=${i##*release_gate_tmp/}
    _sim=${_sim%%/*}
    echo -e "\n${_sim}";
    psig $i;
  done
}

unset -f rgww
rgww() {
  for i in $(command grep FAIL ${REPO_PATH+$REPO_PATH/}release_gate_tmp/release_gate.log | colm -1); do
    local _sim=${i##*release_gate_tmp/}
    _sim=${_sim%%/*}
    echo -e "\n${_sim}";
    pww $i | sed 's:/.*/\(release_gate_tmp/\):$STEM/\1:'
  done
}

unset -f plastlock
plastlock() {
  for i in $*; do
    echo -e "\n$i:"
    perl -ne 'if(/BUS_LOCK|SYS_MGMT/){$p="";}$p.=$_;END{print $p;}' $i
  done
}

unset -f vsig
vsig() {
  file_lnum=$(command grep -Po -m1 '(?<=source\=)[^:]+:\d+' summary.rj)
  file=${file_lnum%:*}
  lnum=${file_lnum#*:}

  file=$(pff ${file})

  # echo "File=${file} Line=${lnum}"
  vc +$lnum $file
}

unset -f tel
tel() {
  while (( $# > 0 )); do
    getent passwd $1 | \
    perl -aF/[:,]/ -lne 'map(s/^\s+//,@F);print "ID:;$F[0]\nName:;$F[4]\nCube:;$F[5]\nExt:;$F[6]"' | \
    /usr/bin/column -t -s \;

    shift
    if (( $# > 0 )); then echo "----"; fi
  done
}

unset -f dotty
dotty() {
  for i in $*; do
    dot -Tgif -o `basename $i .gv`.gif $i
  done
}

unset -f but
but() {
  model=unittest_${1#unittest_}
  shift;

  echo build -model $model
  rerun --norun --build --model $model $@
  local _ret=$?
  if (( $_ret != 0 )); then
    return $_ret;
  fi

  if [[ ${model} =~ _dbg$ ]]; then
    echo gdb $REPO_PATH/build/${model}/${model}
    gdb $REPO_PATH/build/${model}/${model}
  else
    echo $REPO_PATH/build/${model}/${model}
    $REPO_PATH/build/${model}/${model}
  fi
}

unset -f wtff
wtff() {
  model=`basename ${1%_rg.build.log}`
  wtf -m $model
}

# -*- org-log-into-drawer: nil; org-todo-keywords: (quote ((sequence "TODO" "DONE"))); -*-

#+TITLE: Emacs Configuration
#+PROPERTY: header-args :results output silent

* Init
** Archives
/package-archives/ uses HTTP access to GNU by default. Replacing it with the https version instead
#+BEGIN_SRC emacs-lisp
  (setq package-archives '(("repo-gnu"   . "https://elpa.gnu.org/packages/")
                           ("repo-melpa" . "https://melpa.milkbox.net/packages/")
                           ("repo-org"   . "http://orgmode.org/elpa/")))
#+END_SRC

** Bootstrap use-package
[[https://www.youtube.com/watch?v%3D2TSKxxYEbII][use-package video tutorial]]

Install and load use-package
#+BEGIN_SRC emacs-lisp
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  (defvar use-package-verbose t)
  (setq use-package-always-ensure t)

  ;; Disable lazy-loading if using a daemon
  (if (daemonp)
      (setq use-package-always-demand t))
#+END_SRC

** TODO Check if there's a way to keep all the config in this file itself with init.el being empty
Sacha Chua seems to have something like that. Her init.el is simply a link.
Maybe some information in this [[https://www.reddit.com/r/emacs/comments/4uo9r0/shaving_time_on_emacs_startup_from_org_literate/][reddit thread]].

* General
** Keybinds
#+BEGIN_SRC emacs-lisp
  (bind-keys* :prefix-map my-leader-map
              :prefix-docstring "Top-level map"
              :prefix "C-c")

  (bind-keys  :map my-leader-map
              :prefix-map my-jumper-command-map
              :prefix-docstring "This map is used to put all keybinds that I use to jump around eg. open files, buffers etc."
              :prefix "j")

  (bind-keys  :map my-leader-map
              :prefix-map my-s-bindings-map
              :prefix-docstring "This map is used to group together all s-mnemonic bindings such as substitution, sizing etc."
              :prefix "s")
#+END_SRC

I think the following would be handy
  =[= - Enable setting
  =~= - Toggle setting
  =]= - Disable setting
Original use of =C-c [= and =C-c ]= is to manipulate =org-agenda-files= and =C-c ~= is used to =org-create-table-with-table.el=.
Since I don't use any of these, might as well put them to better use.

#+BEGIN_SRC emacs-lisp
  (bind-keys  :map my-leader-map
              :prefix-map my-unimpaired-enable-map
              :prefix-docstring "This map is used to enable settings ala vim-unimpaired"
              :prefix "[")

  (bind-keys  :map my-leader-map
              :prefix-map my-unimpaired-disable-map
              :prefix-docstring "This map is used to disable settings ala vim-unimpaired"
              :prefix "]")

  (bind-keys  :map my-leader-map
              :prefix-map my-unimpaired-toggle-map
              :prefix-docstring "This map is used to toggle settings ala vim-unimpaired"
              :prefix "~")
#+END_SRC

*** Misc
#+BEGIN_SRC emacs-lisp
  (bind-key* "C-h B" 'describe-personal-keybindings)
#+END_SRC

By default C-x = is bound to /what-cursor-position/ but evil maps both =ga= and =g8= to that as well so might as well use it to show something useful.
#+BEGIN_SRC emacs-lisp
  (bind-key* "C-x =" 'describe-char)
#+end_src

#+begin_src emacs-lisp
  (defun my/revert-buffer-no-confirm ()
    "Revert buffer without confirmation."
    (interactive)
    (revert-buffer :ignore-auto :noconfirm))

  (bind-key* "<f5>" 'my/revert-buffer-no-confirm)
#+END_SRC

=key-translation-map= can be used to /map/ one set of keys to another [[id:f42c3dc8-c2f6-4f22-9f47-0c578479ef67][eg.]]

** Autosave, Backup and History
Change default location of backups to avoid littering PWD
#+BEGIN_SRC emacs-lisp
  (defvar backup-directory (concat user-emacs-directory "/tmp/backups"))
  (if (not (file-exists-p backup-directory)) (make-directory backup-directory t))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (setq backup-directory-alist `(("." . ,backup-directory)))
  (setq make-backup-files         t)  ; backup of a file the first time it is saved.
  (setq backup-by-copying         t)  ; don't clobber symlinks
  (setq version-control           t)  ; version numbers for backup files
  (setq delete-old-versions       t)  ; delete excess backup files silently
  (setq delete-by-moving-to-trash t)
  (setq kept-old-versions         6)  ; oldest versions to keep when a new numbered backup is made (default: 2)
  (setq kept-new-versions         9)  ; newest versions to keep when a new numbered backup is made (default: 2)
#+END_SRC

Change default location of autosaves to avoid littering PWD
#+BEGIN_SRC emacs-lisp
  (defvar autosave-directory (concat user-emacs-directory "tmp/autosaves/"))
  (if (not (file-exists-p autosave-directory)) (make-directory autosave-directory t))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  ;; (setq auto-save-file-name-transforms `(("." ,autosave-directory t)))
  (setq auto-save-default t)  ; auto-save every buffer that visits a file
#+END_SRC

Delete identical history entries
#+BEGIN_SRC emacs-lisp
(setq history-delete-duplicates t)
#+END_SRC

Save mini-buffer history
#+BEGIN_SRC emacs-lisp
  (use-package savehist
    :init
    (setq savehist-file (concat user-emacs-directory "tmp/history.el")
          history-length 100)
    :config
    (savehist-mode t))
#+END_SRC

** Clean-up & QoL
Remove visual clutter
#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-message t)
  (setq initial-scratch-message "")

  (menu-bar-mode -1)
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
  ;; (tooltip-mode -1)
#+END_SRC

We can also put something like this into =~/.Xresources= to enable/disable certain things as soon as Emacs starts
#+BEGIN_EXAMPLE
  Emacs.verticalScrollBars: off
  Emacs.toolBar: off
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp
  ;; Enable editing by visual lines
  (global-visual-line-mode t)

  ;; Let emacs react faster to keystrokes
  (setq echo-keystrokes 0.1)
  (setq idle-update-delay 0.35)

  ;; Jump to the help window when it's opened.
  ;; Press q to close it and restore the view to the previous buffer
  (setq help-window-select t)

  ;; Confirm before quitting - sometimes I fat-finger and press both C-x C-c instead of just C-c
  (setq confirm-kill-emacs 'y-or-n-p)

  ;; Simpler y/n answers
  (fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

*** Winner mode - Undo/redo window layouts
Undo and Redo changes in window configuration. Use =C-c right= and =C-c left= to switch between different layouts.
This is useful when I close a window by mistake to undo it and restore the window layout.
#+BEGIN_SRC emacs-lisp
  (winner-mode 1)
#+END_SRC

[[id:f42c3dc8-c2f6-4f22-9f47-0c578479ef67][More intuitive keybindings]] defined after evil is loaded

** Custom file
#+BEGIN_SRC emacs-lisp
  (setq custom-file (concat user-emacs-directory "custom.el"))
  (load custom-file)
#+END_SRC

** Diff
From [[http://pragmaticemacs.com/emacs/visualise-and-copy-differences-between-files/][Pragmatic Emacs]]
#+BEGIN_SRC emacs-lisp
  (use-package ediff
    :config

    ;; Don't start another frame
    (setq ediff-window-setup-function 'ediff-setup-windows-plain)

    ;; Put windows side by side
    (setq ediff-split-window-function (quote split-window-horizontally))

    ;; Revert windows on exit - needs winner mode
    (add-hook 'ediff-after-quit-hook-internal 'winner-undo))
#+END_SRC

** Electric pairs
#+BEGIN_SRC emacs-lisp
  (electric-pair-mode t)
#+END_SRC

** Emacs server
- Always start the emacs-server, except when run in daemon mode
- Already Disable prompt asking you if you want to kill a buffer with a live process attached to it.
  http://stackoverflow.com/questions/268088/how-to-remove-the-prompt-for-killing-emacsclient-buffers

#+BEGIN_SRC emacs-lisp
  (use-package server
    :disabled
    :config
    (unless (or (daemonp) (server-running-p))
      (server-mode 1))
    (add-hook 'server-switch-hook 'raise-frame))
#+END_SRC

Alias for emacsclient:
This will launch emacsclient if a server is already running and launch emacs if not
#+BEGIN_EXAMPLE
  alias e='emacsclient --alternate-editor="emacs" --create-frame --quiet'
#+END_EXAMPLE

** Fonts
:PROPERTIES:
:ID:       bd542328-7d1d-4806-936d-a50673beada6
:END:
Scale font size using =C-x C-+= and =C-x C--=. =C-x C-0= resets it.
=text-scale-mode-step= controls the scaling factor. For obvious reasons, don't set it to 1 else it won't change at all
#+BEGIN_SRC emacs-lisp
  (setq text-scale-mode-step 1.1)
  (setq-default line-spacing 1)
#+END_SRC

After installing a new font refresh the font cache by running
#+BEGIN_SRC bash
  fc-cache -fv
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun my/set-font-if-exists (font)
    " Check if FONT exists and set if it does"
    (when (x-list-fonts font)
      (set-face-attribute 'default        nil :font font)
      (set-face-attribute 'variable-pitch nil :font font)
      (set-face-attribute 'fixed-pitch    nil :font font)
      t))  ; This is required so that we can use this function in a cond block below

  (defun my/select-and-set-font ()
    " Select the font based on OS, hostname etc."
    (cond ((eq system-type 'windows-nt) (my/set-font-if-exists "Iosevka-10"))
          ((eq system-type 'gnu/linux) (my/set-font-if-exists "Iosevka-10"))))

  (if (daemonp)
      (add-hook 'after-make-frame-functions
                (lambda (frame)
                  (select-frame frame)
                  (my/select-and-set-font)))
    (my/select-and-set-font))
#+END_SRC
The reason for adding the hook is that if I try to create a daemon, it errors out with
    /error: Window system is not in use or not initialized/
This is because we try to set a face-attribute before a frame is created which is a no-no for some reason.

However, the downside to this is that if I have multiple such hooks (like in private.el) we can't dictate the order in which they're applied.

Fallback to DejaVu Sans when the font lacks support for some glyphs. Taken from [[https://github.com/joodie/emacs-literal-config/blob/c66e30ce961b140dd3e84116f4d45cbc19d0d944/emacs.org#font][github:joodie]]
How does this work? What is it supposed to do?
#+BEGIN_SRC emacs-lisp :tangle no
  (when (functionp 'set-fontset-font)
    (set-fontset-font "fontset-default" 'unicode
                      (font-spec :family "DejaVu Sans Mono"
                                 :width 'normal
                                 :size 11
                                 :weight 'normal)))
#+END_SRC

*** UTF-8 Please
#+BEGIN_SRC emacs-lisp
  (setq locale-coding-system   'utf-8)
  (set-terminal-coding-system  'utf-8)
  (set-keyboard-coding-system  'utf-8)
  (set-selection-coding-system 'utf-8)
  (set-language-environment    "UTF-8")
  (prefer-coding-system        'utf-8)
#+END_SRC

** Intelligent narrowing and widening
From [[http://endlessparentheses.com/emacs-narrow-or-widen-dwim.html][endless parentheses]]

#+BEGIN_SRC emacs-lisp
  (defun narrow-or-widen-dwim (p)
    "Widen if buffer is narrowed, narrow-dwim otherwise.
  Dwim means: region, org-src-block, org-subtree, or defun, whichever applies first.
  Narrowing to org-src-block actually calls `org-edit-src-code'.

  With prefix P, don't widen, just narrow even if buffer is already narrowed."
    (interactive "P")
    (declare (interactive-only))
    (cond ((and (buffer-narrowed-p) (not p)) (widen))
          ((region-active-p)
           (narrow-to-region (region-beginning)
                             (region-end)))
          ((derived-mode-p 'org-mode)
           ;; `org-edit-src-code' is not a real narrowing command.
           ;; Remove this first conditional if you don't want it.
           (cond ((ignore-errors (org-edit-src-code) t)
                  (delete-other-windows))
                 ((ignore-errors (org-narrow-to-block) t))
                 (t (org-narrow-to-subtree))))
          ((derived-mode-p 'latex-mode)
           (LaTeX-narrow-to-environment))
          (t (narrow-to-defun))))

  ;; This line actually replaces Emacs' entire narrowing keymap.
  (bind-key "n" 'narrow-or-widen-dwim ctl-x-map)
#+END_SRC

** Mode line
#+BEGIN_SRC emacs-lisp
  (column-number-mode t)
#+END_SRC

** Mouse
Mouse-wheel acts on the hovered window rather than the one where the typing focus is
#+BEGIN_SRC emacs-lisp
  (setq mouse-wheel-follow-mouse t)
#+END_SRC

** Prettify
*** Highlight current line
#+BEGIN_SRC emacs-lisp
  (bind-key "c" 'global-hl-line-mode my-unimpaired-toggle-map)
  (bind-key "c" '(lambda() (interactive) (global-hl-line-mode 1))  my-unimpaired-enable-map)
  (bind-key "c" '(lambda() (interactive) (global-hl-line-mode -1)) my-unimpaired-disable-map)
#+END_SRC

*** Show matching parens
#+BEGIN_SRC emacs-lisp
  (show-paren-mode 1)
  (setq show-paren-delay 0)
  ;; (setq show-paren-style 'expression)
#+END_SRC

*** Use symbols
eg. Replaces the text /lambda/ with λ. Full list of prettified symbols can be found in =prettify-symbols-alist=
#+BEGIN_SRC emacs-lisp
  (global-prettify-symbols-mode t)
#+END_SRC

** Tabs, Indentation and Spacing
:PROPERTIES:
:ID:       8d72d9c2-5b52-454f-892a-107b009563fa
:END:
Use only spaces and no tabs
#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
  (setq-default tab-width 2)
  (setq-default show-trailing-whitespace t)

  (setq-default sh-basic-offset 2)
  ;; (bind-key "RET" 'newline-and-indent)

  ;; Count 1 space after a period as the end of a sentence, instead of 2
  (setq sentence-end-double-space nil)
#+end_src
Since these are buffer-local variables, I have to use =setq-default=

*** Highlight trailing whitespace
#+BEGIN_SRC emacs-lisp
  (defun my/toggle-trailing-whitespace ()
    "Toggle trailing whitespace"
    (interactive)  ; Allows to be called as a command via M-x
    (setq-default show-trailing-whitespace (not show-trailing-whitespace)))

  (bind-key "SPC" '(lambda () (interactive)(setq-default show-trailing-whitespace t)) my-unimpaired-enable-map)
  (bind-key "SPC" '(lambda () (interactive)(setq-default show-trailing-whitespace nil)) my-unimpaired-disable-map)
  (bind-key "SPC" 'my/toggle-trailing-whitespace my-unimpaired-toggle-map)
#+END_SRC

*** Delete trailing whitespace
Automatically while saving (from [[https://www.emacswiki.org/emacs/DeletingWhitespace#toc3][emacswiki]])
#+BEGIN_SRC emacs-lisp
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC

Use =C-c s SPC= to delete trailing whitespace manually
#+BEGIN_SRC emacs-lisp
  (bind-key "SPC" 'delete-trailing-whitespace my-s-bindings-map)
#+END_SRC

*** Toggle wrap
#+BEGIN_SRC emacs-lisp
  (bind-key "w" 'toggle-truncate-lines my-unimpaired-toggle-map)
#+END_SRC

** Terminal
Specify the shell to use to avoid prompt. From [[https://youtu.be/L9vA7FHoQnk?list=PLX2044Ew-UVVv31a0-Qn3dA6Sd_-NyA1n&t=192][Uncle Dave's video]]
#+BEGIN_SRC emacs-lisp
  (defvar my-term-shell "/usr/bin/bash")
  (defadvice ansi-term (before force-bash)
    (interactive (list my-term-shell)))
  (ad-activate 'ansi-term)
#+END_SRC

Disable trailing whitespace hightlighting
#+BEGIN_SRC emacs-lisp
  ;; (add-hook 'term-mode-hook '(lambda() (setq show-trailing-whitespace nil)))
#+END_SRC

Launch
#+BEGIN_SRC emacs-lisp
  (bind-key* "<s-return>" 'ansi-term)
#+END_SRC

** Theme Directories
#+BEGIN_SRC emacs-lisp
  (add-to-list 'custom-theme-load-path (concat user-emacs-directory "/themes"))
  (add-to-list 'load-path (concat user-emacs-directory "/themes"))
#+END_SRC

** Visual
#+BEGIN_SRC emacs-lisp
  ;; Disable anoying beep
  (setq ring-bell-function 'ignore)

  ;; Improve rendering performance
  (setq redisplay-dont-pause t)

  ;; Display a special glyph in the fringe of each empty line at the end of the buffer
  (setq indicate-empty-lines t)
#+END_SRC

** TODO Frame related
Specify /width/ and /height/ /pixel-wise/ in /default-frame-alist/
#+BEGIN_SRC emacs-lisp
  ;; Set frame size pixelwise instead of characterwise
  (setq frame-resize-pixelwise t)

  ;; Set size of default frame
  (setq default-frame-alist
        '((top    . 0)
          (left   . 0)
          (width  . 237)
          (height . 65)))
#+END_SRC

Set frame size programatically
#+BEGIN_SRC emacs-lisp
  (bind-keys :map my-s-bindings-map
             ("l" . (lambda () "Set emacs frame size to fit the left desktop monitor"
                      (interactive)
                      (set-frame-position (selected-frame) 0    0)
                      (set-frame-size     (selected-frame) 1901 1122 t)))
             ("r" . (lambda () "Set emacs frame size to fit the right desktop monitor"
                      (interactive)
                      (set-frame-position (selected-frame) 1919 0)
                      (set-frame-size     (selected-frame) 1902 1122 t))))
#+END_SRC

Start maximized
#+BEGIN_SRC emacs-lisp :tangle no
  ;; Open in fullscreen
  (defun my/switch-fullscreen nil
    "Switch to fullscreen. Works in OSX."
    (interactive)
    (let* ((modes '(nil fullboth fullwidth fullheight))
           (cm (cdr (assoc 'fullscreen (frame-parameters))))
           (next (cadr (member cm modes))))
      (modify-frame-parameters
       (selected-frame)
       (list (cons 'fullscreen next)))))
  (my/switch-fullscreen)

  ;; Start maximized
  (custom-set-variables '(initial-frame-alist (quote ((fullscreen . maximized)))))
#+END_SRC

Transparency
#+BEGIN_SRC emacs-lisp :tangle no
  (set-frame-parameter (selected-frame) 'alpha '(85 85))
  (add-to-list 'default-frame-alist '(alpha 85 85))
#+END_SRC

Avoid Emacs hanging for a while after changing default font:
#+BEGIN_SRC emacs-lisp :tangle no
  (modify-frame-parameters nil '((wait-for-wm . nil)))
#+END_SRC

** TODO Scratch
Mode-specific scratch buffers?

* Packages
** diminish
Placing at top since it'll be used by most of the other packages
#+BEGIN_SRC emacs-lisp
  (use-package diminish
    :config
    (diminish 'visual-line-mode))
#+END_SRC

** aggressive-indent
#+BEGIN_SRC emacs-lisp
  (use-package aggressive-indent
    :config
    (global-aggressive-indent-mode t))
#+END_SRC

** beacon-mode
#+BEGIN_SRC emacs-lisp
  (use-package beacon
    :init
    (setq beacon-blink-when-window-scrolls nil
          beacon-color (face-attribute 'highlight :background))
    :config
    (beacon-mode 1)
    (add-hook 'after-load-theme-hook
              (lambda()
                "Update beacon's background color once a theme is loaded"
                (setq beacon-color (face-attribute 'highlight :background)))))
#+END_SRC

** company
Provides auto-completion
#+BEGIN_SRC emacs-lisp
  (use-package company
    :init
    (add-hook 'after-init-hook 'global-company-mode))
#+END_SRC

** evil
evil can be toggled using =C-z=
#+BEGIN_SRC emacs-lisp
  (use-package evil
    :init
    (setq evil-want-C-w-in-emacs-state t
          evil-want-Y-yank-to-eol t)
    (evil-mode t)
#+END_SRC

*** :config
#+BEGIN_SRC emacs-lisp
  :config
#+END_SRC
**** evil-args
#+BEGIN_SRC emacs-lisp
  (use-package evil-args
    :commands (evil-inner-arg evil-outer-arg evil-forward-arg evil-backward-arg)
    :init
    (bind-key "," 'evil-inner-arg evil-inner-text-objects-map)
    (bind-key "," 'evil-outer-arg evil-outer-text-objects-map)
    (bind-keys :map evil-normal-state-map
               ("] ," . evil-forward-arg)
               ("[ ," . evil-backward-arg)
               :map evil-motion-state-map
               ("] ," . evil-forward-arg)
               ("[ ," . evil-backward-arg)))
#+END_SRC

**** evil-commentary
#+BEGIN_SRC emacs-lisp
  (use-package evil-commentary
    :diminish evil-commentary-mode
    :config (evil-commentary-mode))
#+END_SRC

**** evil-exchange
#+BEGIN_SRC emacs-lisp
  (use-package evil-exchange
    :config (evil-exchange-cx-install))
#+END_SRC

**** evil-matchit
#+BEGIN_SRC emacs-lisp
  (use-package evil-matchit)
#+END_SRC

**** evil-numbers
#+BEGIN_SRC emacs-lisp
  (use-package evil-numbers
    :commands (evil-numbers/inc-at-pt evil-numbers/dec-at-pt)
    :init
    (bind-keys :map evil-normal-state-map
               ("C-c +" . evil-numbers/inc-at-pt)
               ("C-c -" . evil-numbers/dec-at-pt)
               :map evil-visual-state-map
               ("C-c +" . evil-numbers/inc-at-pt)
               ("C-c -" . evil-numbers/dec-at-pt)))
#+END_SRC

**** evil-string-inflection
Provides =g~= operator to cycle between snake_case → SCREAMING_SNAKE_CASE → TitleCase → CamelCase → kebab-case
#+BEGIN_SRC emacs-lisp
  (use-package evil-string-inflection
    :ensure t)
#+END_SRC

**** evil-surround
#+BEGIN_SRC emacs-lisp
  (use-package evil-surround
    :config (global-evil-surround-mode))
#+END_SRC

**** evil-visualstar
#+BEGIN_SRC emacs-lisp
  (use-package evil-visualstar
    :config (global-evil-visualstar-mode))
#+END_SRC

**** Keybinds
:PROPERTIES:
:ID:       f42c3dc8-c2f6-4f22-9f47-0c578479ef67
:END:
Make /Escape/ quit everything. From [[http://stackoverflow.com/a/10166400/734153][StackOverflow]].
#+BEGIN_SRC emacs-lisp :tangle no
  (defun my/minibuffer-keyboard-quit ()
    "Abort recursive edit.
          In Delete Selection mode, if the mark is active, just deactivate it;
          then it takes a second ESC to abort the minibuffer."
    (interactive)
    (if (and delete-selection-mode transient-mark-mode mark-active)
        (setq deactivate-mark  t)
      (when (get-buffer "*Completions*") (delete-windows-on "*Completions*"))
      (abort-recursive-edit)))

  (bind-key [escape] 'keyboard-quit               evil-normal-state-map          )
  (bind-key [escape] 'keyboard-quit               evil-visual-state-map          )
  (bind-key [escape] 'my/minibuffer-keyboard-quit minibuffer-local-map           )
  (bind-key [escape] 'my/minibuffer-keyboard-quit minibuffer-local-ns-map        )
  (bind-key [escape] 'my/minibuffer-keyboard-quit minibuffer-local-completion-map)
  (bind-key [escape] 'my/minibuffer-keyboard-quit minibuffer-local-must-match-map)
  (bind-key [escape] 'my/minibuffer-keyboard-quit minibuffer-local-isearch-map   )
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (define-key key-translation-map (kbd "ESC")     (kbd "C-g"))
  (define-key key-translation-map (kbd "C-w C-h") (kbd "C-w h"))
  (define-key key-translation-map (kbd "C-w C-j") (kbd "C-w j"))
  (define-key key-translation-map (kbd "C-w C-k") (kbd "C-w k"))
  (define-key key-translation-map (kbd "C-w C-l") (kbd "C-w l"))
#+END_SRC

Follow newly created splits
#+BEGIN_SRC emacs-lisp
  (bind-keys :map evil-motion-state-map
             ("C-w s" . (lambda() (interactive) (evil-window-split)(other-window 1)))
             ("C-w v" . (lambda() (interactive) (evil-window-vsplit)(other-window 1))))
  (define-key key-translation-map (kbd "C-w C-s") (kbd "C-w s"))
  (define-key key-translation-map (kbd "C-w C-v") (kbd "C-w v"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (bind-keys :map evil-normal-state-map
             ("U" . redo)
             ("] SPC" . (lambda() (interactive) (end-of-line)(newline)))
             ("[ SPC" . (lambda() (interactive) (beginning-of-line)(open-line 1))))
#+END_SRC

Move by visual lines. Note this is not a complete solution since it doesn't work when combined with operators (eg. =dj=)
#+BEGIN_SRC emacs-lisp
  (bind-keys :map evil-motion-state-map
             ("j"  . evil-next-visual-line)
             ("gj" . evil-next-line)
             ("k"  . evil-previous-visual-line)
             ("gk" . evil-previous-line)
             ("$"  . evil-end-of-line)
             ("g$" . evil-end-of-visual-line))
#+END_SRC

More intuitive keybinds for winner-mode
#+BEGIN_SRC emacs-lisp
  (bind-keys :map evil-motion-state-map
             ("u" . winner-undo)
             ("U" . winner-redo))
#+END_SRC

**** TODO Set emacs-state-cursor face to the default used by the colorscheme
#+BEGIN_SRC emacs-lisp
  ;; (add-hook 'after-load-theme-hook
  ;;           (lambda() (setq my-evil-emacs-state-cursor-color (face-attribute 'cursor :background)
  ;;                      evil-emacs-state-cursor '(my-evil-emacs-state-cursor-color box))))
#+END_SRC

*** END
#+BEGIN_SRC emacs-lisp
  )
#+END_SRC

** flycheck
#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :diminish flycheck-mode
    :init
    (global-flycheck-mode t)
    (setq flycheck-gcc-language-standard "c++14"
          flycheck-clang-language-standard "c++14"))
#+END_SRC

** ivy, swiper, counsel
#+BEGIN_SRC emacs-lisp
  (use-package ivy
    :diminish (ivy-mode . "")
    :config
    (ivy-mode 1)
    (bind-key "b" 'ivy-switch-buffer my-jumper-command-map)
    (setq ivy-count-format "%d/%d "
          ivy-height 12
          ivy-extra-directories nil
          ivy-use-virtual-buffers t)
#+END_SRC

From [[https://github.com/kaushalmodi/.emacs.d/blob/master/setup-files/setup-ivy.el][kaushalmodi's repo]]
#+BEGIN_SRC emacs-lisp
  (defun my/ivy-set-prompt-text-properties (prompt std-props)
    "Add a different face for the \"<..>\" string in `counsel-set-variable'."
    (ivy--set-match-props prompt "<\\(.*\\)>"
                          `(face font-lock-string-face ,@std-props) 1)
    (ivy-set-prompt-text-properties-default prompt std-props))

  (setq ivy-set-prompt-text-properties-function 'my/ivy-set-prompt-text-properties)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  )
#+END_SRC

*** swiper
#+BEGIN_SRC emacs-lisp
  (use-package swiper
    :bind* (("C-s" . swiper)))
#+END_SRC

*** counsel
#+BEGIN_SRC emacs-lisp
  (use-package counsel
    :bind* ("C-h a" . counsel-apropos)
#+END_SRC

Use =C-c j= as prefix for all counsel-related keybinds
#+BEGIN_SRC emacs-lisp
  :bind (:map my-jumper-command-map
              ("o" . counsel-semantic-or-imenu)
              ("/" . counsel-ag))
  :bind (:map org-mode-map
              ("C-c C-q" . counsel-org-tag))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  )
#+END_SRC

** org
This solution is by [[https://www.reddit.com/r/emacs/comments/5sx7j0/how_do_i_get_usepackage_to_ignore_the_bundled/ddixpr9/][/u/Wolfer1ne on reddit]].
#+BEGIN_SRC emacs-lisp
  (use-package org
    :ensure org-plus-contrib
    :pin repo-org
#+END_SRC

<<ensure_target>>
Passing an argument to =:ensure= (other than t or nil) allows us to use a different package than the one named in use-package
Also, using =:pin= allows us to prefer which package-archive we'd like to use to download the package from.
I don't remember why we need to specifically grab =org-plus-contrib= from the org repository instead of from one of the other ones.

Org customization guide: http://orgmode.org/worg/org-configs/org-customization-guide.html
*** :init
#+BEGIN_SRC emacs-lisp
  :init
  (setq org-indent-mode t)

  (setq org-directory "~/Notes/")
  (setq org-default-notes-file (concat org-directory "Inbox.org"))

  (setq org-M-RET-may-split-line '((item) (default . t)))
  ;; (setq org-special-ctrl-a/e t)
  ;; (setq org-return-follows-link nil)
  (setq org-use-speed-commands nil)
  ;; (setq org-speed-commands-user nil)
  (setq org-startup-align-all-tables nil)
  (setq org-use-property-inheritance t)
  (setq org-tags-column -100)
  (setq org-hide-emphasis-markers t)  ; Hide markers for bold/italics etc.
  (setq org-blank-before-new-entry '((heading . t) (plain-list-item . nil)))
  (setq org-link-search-must-match-exact-headline nil)
  (setq org-startup-with-inline-images t)
  (setq org-imenu-depth 10)
#+END_SRC

**** org-babel source blocks
Enable syntax highlighting within the source blocks and keep the editing popup window within the same window.
Also, strip leading and trailing empty lines if any.
/org-src-preserve-indentation/ will not add an extra level of indentation to the source code
#+BEGIN_SRC emacs-lisp
  (setq org-src-fontify-natively                       t
        org-src-window-setup                           'current-window
        org-src-strip-leading-and-trailing-blank-lines t
        ;; org-src-preserve-indentation                t
        org-src-tab-acts-natively                      t)
#+end_src

Languages which can be evaluated in Org-mode buffers.
#+begin_src emacs-lisp
  (org-babel-do-load-languages 'org-babel-load-languages
                               (append org-babel-load-languages
                                       '((python     . t)
                                         (ruby       . t)
                                         (perl       . t)
                                         (dot        . t)
                                         (C          . t))))
#+end_src

Ask for confirmation before evaluating? NO!
On second thought it's better not to do this because of the security implications.
A safer way to go about it is by enabling it on a file-by-file basis using the following modeline
#+BEGIN_EXAMPLE
  -*- org-confirm-babel-evaluate: nil -*-
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp :tangle no
  (defun my/org-babel-evaluate-silent (lang body)
    "Do not ask for confirmation to evaluate these languages."
    (not (or (string= lang "emacs-lisp"))))

  (setq org-confirm-babel-evaluate 'my/org-babel-evaluate-silent)
  ;; (setq org-confirm-babel-evaluate nil)
#+END_SRC

**** Clean View
#+BEGIN_SRC emacs-lisp
  (setq org-startup-indented t)
  (setq org-hide-leading-stars t)
  (setq org-odd-level-only nil)

  ;; others: ▼, ↴, ⬎, ⤷, …, ⋱
  (setq org-ellipsis " ▼")
#+END_SRC

***** TODO Hide the < and > around targets
From [[http://emacs.stackexchange.com/a/19239/9690][Emacs StackExchange]]
At the moment, it hides not just the angle braces but also the text between them.
#+BEGIN_SRC emacs-lisp :tangle no
  (defcustom org-hidden-links-additional-re "<<[<]?[[:alnum:]]+>>[>]?"
    "Regular expression that matches strings where the invisible-property is set to org-link."
    :type '(choice (const :tag "Off" nil) regexp)
    :group 'org-link)
  (make-variable-buffer-local 'org-hidden-links-additional-re)

  (defun org-activate-hidden-links-additional (limit)
    "Put invisible-property org-link on strings matching `org-hide-links-additional-re'."
    (if org-hidden-links-additional-re
        (re-search-forward org-hidden-links-additional-re limit t)
      (goto-char limit)
      nil))

  (add-hook 'org-font-lock-set-keywords-hook (lambda ()
                                               (add-to-list 'org-font-lock-extra-keywords
                                                            '(org-activate-hidden-links-additional
                                                              (0 '(face org-target invisible org-link))))))
#+END_SRC

***** TODO Show the emphasis and target markers on point
#+BEGIN_SRC emacs-lisp :tangle no
  (defun org-show-emphasis-markers-at-point ()
    (save-match-data
      (if (and (org-in-regexp org-emph-re 2)
               (>= (point) (match-beginning 3))
               (<= (point) (match-end 4))
               (member (match-string 3) (mapcar 'car org-emphasis-alist)))
          (with-silent-modifications
            (remove-text-properties
             (match-beginning 3) (match-beginning 5)
             '(invisible org-link)))
        (apply 'font-lock-flush (list (match-beginning 3) (match-beginning 5))))))

  (add-hook 'post-command-hook 'org-show-emphasis-markers-at-point nil t)
#+END_SRC

**** ToDo States
Custom keywords
#+BEGIN_SRC emacs-lisp
  (setq org-todo-keywords '((sequence "TODO(t!)" "WAITING(w@/!)" "|" "DONE(d@)" "CANCEL(c@)")))
  ;; (setq org-todo-keyword-faces
  ;;       (quote (("TODO" :foreground "red" :weight bold)
  ;;               ("WAITING" :foreground "orange" :weight bold)
  ;;               ("DONE" :foreground "forest green" bold)
  ;;               ("CANCEL" :foreground "forest green" bold))))
#+END_SRC
=!=   - Log timestamp
=@=   - Log timestamp and note
=x/y= - =x= takes affect when entering the state and
      =y= takes affect when exiting if the state being entered doesn't have any logging
Refer [[http://orgmode.org/manual/Tracking-TODO-state-changes.html][Tracking-TODO-state-changes]] for details

Add logging when task state changes
#+BEGIN_SRC emacs-lisp
  (setq org-log-done 'time) ; 'time/'note
  (setq org-log-redeadline 'note)
  (setq org-log-into-drawer t)  ; Save state changes into LOGBOOK drawer instead of in the body
  (setq org-treat-insert-todo-heading-as-state-change t)
#+END_SRC

Change from any todo state to any other state using =C-c C-t KEY=
#+BEGIN_SRC emacs-lisp
  (setq org-use-fast-todo-selection t)
#+END_SRC

This frees up S-left and S-right which I can then use to cycles through the todo states but skip setting timestamps and entering notes which is very convenient when all I want to do is change the status of an entry without changing its timestamps
#+BEGIN_SRC emacs-lisp
  (setq org-treat-S-cursor-todo-selection-as-state-change nil)
#+END_SRC

*** :config
#+BEGIN_SRC emacs-lisp
  :config
  (eval-after-load 'org-indent '(diminish org-indent-mode))
#+END_SRC

**** Make org-mode play nicely with Google Chrome
From [[http://stackoverflow.com/a/6309985/734153][StackOverflow]]
#+BEGIN_SRC emacs-lisp
  (setq browse-url-browser-function 'browse-url-generic
        browse-url-generic-program "google-chrome")
#+END_SRC

**** Templates
#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-structure-template-alist '("sc" "#+BEGIN_SRC C++\n  #include <iostream>\n\n  using namespace std;\n\n  int main() {\n    ?cout << \"Hello World!\" << endl;\n  }\n#+END_SRC"))

  (add-to-list 'org-structure-template-alist '("sl" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC\n" "<src lang=\"?\">\n\n</src>"))

  (add-to-list 'org-structure-template-alist '("sp" "#+BEGIN_SRC python\n?\n#+END_SRC\n" "<src lang=\"?\">\n\n</src>"))

  ;; (add-to-list 'org-structure-template-alist '("sd" "#+BEGIN_SRC dot :file /tmp/out.png\n?\n#+END_SRC\n" "<src lang=\"?\">\n\n</src>"))

  (add-to-list 'org-structure-template-alist '("ss" "#+BEGIN_SRC bash\n?\n#+END_SRC\n" "<src lang=\"?\">\n\n</src>"))
#+END_SRC

=?= in each string controls where the point will be placed after expansion

**** Fonts
Variable pitch for non-code text taken from [[http://www.xiangji.me/2015/07/13/a-few-of-my-org-mode-customizations][here]].
#+BEGIN_SRC emacs-lisp
  (defun my/set-buffer-variable-pitch ()
    (interactive)
    (variable-pitch-mode t)
    (set-face-attribute 'org-table nil :inherit 'fixed-pitch)
    (set-face-attribute 'org-code  nil :inherit 'fixed-pitch)
    (set-face-attribute 'org-block nil :inherit 'fixed-pitch))

  ;; (add-hook 'org-mode-hook      'my/set-buffer-variable-pitch)
  ;; (add-hook 'eww-mode-hook      'my/set-buffer-variable-pitch)
  ;; (add-hook 'markdown-mode-hook 'my/set-buffer-variable-pitch)
  ;; (add-hook 'Info-mode-hook     'my/set-buffer-variable-pitch)
#+END_SRC

NOTE: =org-block-background= has been removed in Org 8.3.1 and from 9.0.0,
has been completely deprecated and it inherits from =org-block=

General configuration [[id:bd542328-7d1d-4806-936d-a50673beada6][here]]

**** Delete links
This is the counterpart to =org-insert-link=. From [[http://emacs.stackexchange.com/a/10714/9690][here]].
#+BEGIN_SRC emacs-lisp
  (defun my/org-replace-link-with-description ()
    "Replace an org link with its description. If a description doesn't exist, replace with its address"
    (interactive)
    (if (org-in-regexp org-bracket-link-regexp 1)
        (let ((remove (list (match-beginning 0) (match-end 0)))
              (description (if (match-end 3)
                               (org-match-string-no-properties 3)
                             (org-match-string-no-properties 1))))
          (apply 'delete-region remove)
          (insert description))))
#+END_SRC

**** Complete multiple org tags
From [[https://blog.aaronbieber.com/2016/03/05/playing-tag-in-org-mode.html][Aaron Bieber's blog]]

Once the first tag is set (using helm), we don't get completion support after that.
This is because, the entire tag string is treated as a single value and Helm tries to complete based only on the full value.
#+BEGIN_SRC emacs-lisp
  (defun my/org-set-tags (tag)
    "Add TAG if it is not in the list of tags, remove it otherwise.

  TAG is chosen interactively from the global tags completion table."
    (interactive
     (list (let ((org-last-tags-completion-table
                  (if (derived-mode-p 'org-mode)
                      (org-uniquify
                       (delq nil (org-get-buffer-tags)))
                    (org-global-tags-completion-table))))
             (org-icompleting-read
              "Tag: " 'org-tags-completion-function nil nil nil
              'org-tags-history))))
    (let* ((my/org-swap-tags (lambda (tags)
                               "Replace any tags on the current headline with TAGS.

  The assumption is that TAGS will be a string conforming to Org Mode's
  tag format specifications, or nil to remove all tags."
                               (let ((old-tags (org-get-tags-string))
                                     (tags (if tags
                                               (concat " " tags)
                                             "")))
                                 (save-excursion
                                   (beginning-of-line)
                                   (re-search-forward
                                    (concat "[ \t]*" (regexp-quote old-tags) "[ \t]*$")
                                    (line-end-position) t)
                                   (replace-match tags)
                                   (org-set-tags t)))))
           (cur-list (org-get-tags))
           (new-tags (mapconcat 'identity
                                (if (member tag cur-list)
                                    (delete tag cur-list)
                                  (append cur-list (list tag)))
                                ":"))
           (new (if (> (length new-tags) 1) (concat " :" new-tags ":")
                  nil)))
      (funcall my/org-swap-tags new)))

  ;; (bind-keys :map org-mode-map
  ;;            ("C-c C-q" . my/org-set-tags)
  ;;            ("C-c M-q" . org-set-tags-command))
#+END_SRC

**** Use ! to toggle timestamp type
:PROPERTIES:
:ID:       d4634d95-be37-4bdf-987e-22da5778e958
:END:
[[https://orgmode.org/manual/Creating-timestamps.html][By default]], org-mode uses =C-c .= and =C-c != to create active and inactive timestamps respectively.
However, I also have flycheck installed which uses the C-c ! binding.

Thus, this allows me to use =C-c .= to insert a timestamp and when prompted to enter the date+time in the minibuffer,
use =!= to toggle between active and inactive timestamps. Also see [[Custom timestamp keymap]].
From [[http://emacs.stackexchange.com/questions/38062/configure-key-to-toggle-between-active-and-inactive-timestamps#38065][Emacs StackExchange]]

#+BEGIN_SRC emacs-lisp
  (defun org-toggle-time-stamp-activity ()
    "Toggle activity of time stamp or range at point."
    (interactive)
    (let ((pt (point)))
      (when (org-at-timestamp-p t)
        (goto-char (match-beginning 0))
        (when-let ((el (org-element-timestamp-parser))
                   (type (org-element-property :type el))
                   (type-str (symbol-name type))
                   (begin (org-element-property :begin el))
                   (end (org-element-property :end el)))
          (setq type-str
                (if (string-match "inactive" type-str)
                    (replace-regexp-in-string "inactive" "active" type-str)
                  (replace-regexp-in-string "active" "inactive" type-str)))
          (org-element-put-property el :type (intern type-str))
          (goto-char end)
          (skip-syntax-backward "-")
          (delete-region begin (point))
          (insert (org-element-timestamp-interpreter el nil))
          (goto-char pt)))))

  (defvar-local calendar-previous-buffer nil
    "Buffer been active when `calendar' was called.")

  (defun calendar-save-previous-buffer (oldfun &rest args)
    "Save buffer been active at `calendar' in `calendar-previous-buffer'."
    (let ((buf (current-buffer)))
      (apply oldfun args)
      (setq calendar-previous-buffer buf)))

  (advice-add #'calendar :around #'calendar-save-previous-buffer)

  (defvar-local my-org-time-stamp-toggle nil
    "Make time inserted time stamp inactive after inserting with `my-org-time-stamp'.")

  (defun org-time-stamp-toggle ()
    "Make time stamp active at the end of `my-org-time-stamp'."
    (interactive)
    (when-let ((win (minibuffer-selected-window))
               (buf (window-buffer win)))
      (when (buffer-live-p buf)
        (with-current-buffer buf
          (when (buffer-live-p calendar-previous-buffer)
            (set-buffer calendar-previous-buffer))
          (setq my-org-time-stamp-toggle (null my-org-time-stamp-toggle))
          (setq org-read-date-inactive my-org-time-stamp-toggle)))))

  (define-key org-read-date-minibuffer-local-map "!" #'org-time-stamp-toggle)

  (defun my-org-time-stamp (arg)
    "Like `org-time-stamp' with ARG but toggle activity with character ?!."
    (interactive "P")
    (setq my-org-time-stamp-toggle nil)
    (org-time-stamp arg)
    (when my-org-time-stamp-toggle
      (backward-char)
      (org-toggle-time-stamp-activity)
      (forward-char)))

  ;; (org-defkey org-mode-map (kbd "C-c .") #'my-org-time-stamp)
#+END_SRC

**** org-babel
***** Set default options
#+BEGIN_SRC emacs-lisp
  (setq org-babel-default-header-args
        '((:results . "verbatim replace")))

  (setq org-babel-C++-compiler "clang++")
  (setq org-babel-default-header-args:C++
        '((:flags   . "-std=c++14 -Wall -Wextra -Werror ${BOOST_HOME:+-L ${BOOST_HOME}/lib -I ${BOOST_HOME}/include} -Wl,${BOOST_HOME:+-rpath ${BOOST_HOME}/lib}")))

  (setq org-babel-default-header-args:perl
        '((:results . "output")))

  (setq org-babel-python-command "python3")
#+END_SRC

***** Display errors and warnings in an org-babel code block
From [[http://emacs.stackexchange.com/questions/2952/display-errors-and-warnings-in-an-org-mode-code-block][Emacs StackExchange]]
#+BEGIN_SRC emacs-lisp :tangle no
  (defvar org-babel-eval-verbose t
    "A non-nil value makes `org-babel-eval' display")

  (defun org-babel-eval (cmd body)
    "Run CMD on BODY.
  If CMD succeeds then return its results, otherwise display
  STDERR with `org-babel-eval-error-notify'."
    (let ((err-buff (get-buffer-create " *Org-Babel Error*")) exit-code)
      (with-current-buffer err-buff (erase-buffer))
      (with-temp-buffer
        (insert body)
        (setq exit-code
              (org-babel--shell-command-on-region
               (point-min) (point-max) cmd err-buff))
        (if (or (not (numberp exit-code)) (> exit-code 0)
                (and org-babel-eval-verbose (> (buffer-size err-buff) 0))) ; new condition
            (progn
              (with-current-buffer err-buff
                (org-babel-eval-error-notify exit-code (buffer-string)))
              nil)
          (buffer-string)))))

  (setq org-babel-eval-verbose t)
#+END_SRC

**** org-bullets
Other bullets to consider:
Default: "◉ ○ ✸ ✿"
Large: ♥ ● ◇ ✚ ✜ ☯ ◆ ♠ ♣ ♦ ☢ ❀ ◆ ◖ ▶
Small: ► • ★ ▸

#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :config
    (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
#+END_SRC

A good way to find more characters is to use =M-x insert-char=

**** org-agenda
#+BEGIN_SRC emacs-lisp
  (use-package org-agenda
    :ensure nil
#+END_SRC

***** :init
#+BEGIN_SRC emacs-lisp
  :init
  (setq org-agenda-files
        (seq-filter (lambda (x)
                      (and 'file-exists-p
                           (not (string= x "Spanish.org"))))
                    (mapcar (lambda (x) (concat org-directory x))
                            '("Inbox.org" "Software/" "Personal/"))))

  (setq org-agenda-tags-column            -120) ; Monitors are wide, might as well use it :/
  (setq org-agenda-skip-scheduled-if-done t)    ; Why isn't this default?
  (setq org-agenda-skip-deadline-if-done  t)
  (setq org-agenda-window-setup 'only-window)
  (setq org-agenda-restore-windows-after-quit t)
#+END_SRC

***** org-agenda custom commands
Based on https://blog.aaronbieber.com/2016/09/24/an-agenda-for-life-with-org-mode.html
#+BEGIN_SRC emacs-lisp
  (defun my/org-skip-subtree-if-habit ()
    "Skip an agenda entry if it has a STYLE property equal to \"habit\"."
    (let ((subtree-end (save-excursion (org-end-of-subtree t))))
      (if (string= (org-entry-get nil "STYLE") "habit")
          subtree-end
        nil)))

  (defun my/org-skip-subtree-if-priority (priority)
    "Skip an agenda subtree if it has a priority of PRIORITY.

  PRIORITY may be one of the characters ?A, ?B, or ?C."
    (let ((subtree-end (save-excursion (org-end-of-subtree t)))
          (pri-value (* 1000 (- org-lowest-priority priority)))
          (pri-current (org-get-priority (thing-at-point 'line t))))
      (if (= pri-value pri-current)
          subtree-end
        nil)))

  (setq org-agenda-custom-commands
        '(("d" "Daily agenda and all TODOs"
           ((tags "PRIORITY=\"A\""
                  ((org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
                   (org-agenda-overriding-header "High-priority unfinished tasks:")))
            (agenda "" ((org-agenda-span 14)))
            (alltodo ""
                     ((org-agenda-skip-function '(or (my/org-skip-subtree-if-habit)
                                                     (my/org-skip-subtree-if-priority ?A)
                                                     (org-agenda-skip-if nil '(scheduled deadline))))
                      (org-agenda-overriding-header "ALL normal priority tasks:"))))
           ((org-agenda-compact-blocks t)))

          ("w" "Daily agenda and all TODOs for Work"
           ((tags "PRIORITY=\"A\""
                  ((org-agenda-tag-filter-preset '("+Work"))
                   (org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
                   (org-agenda-overriding-header "High-priority unfinished tasks:")))
            (agenda "" ((org-agenda-span 14)))
            (alltodo ""
                     ((org-agenda-tag-filter-preset '("+Work"))
                      (org-agenda-skip-function '(or (my/org-skip-subtree-if-habit)
                                                     (my/org-skip-subtree-if-priority ?A)
                                                     (org-agenda-skip-if nil '(scheduled deadline))))
                      (org-agenda-overriding-header "ALL normal priority tasks:"))))
           ((org-agenda-compact-blocks t)))))
#+END_SRC

***** Keybinds
[[id:ebbf9970-d072-4b59-bcaa-5f4b3d71a7d7][General org keybinds]]

#+BEGIN_SRC emacs-lisp
  :config
#+END_SRC

Use j/k in org-agenda
#+BEGIN_SRC emacs-lisp :tangle no
  (bind-keys :map org-agenda-mode-map
             ("j" . org-agenda-next-item)       ;; Bound to 'goto-date' by default
             ("k" . org-agenda-previous-item))  ;; Bound to 'org-capture' by default
#+END_SRC

Open the custom "Daily agenda and all TODOs" directly. Based on [[http://emacs.stackexchange.com/a/868/9690][Emacs StackExchange]].
#+BEGIN_SRC emacs-lisp
  (bind-key* "<f12>" '(lambda (&optional arg) (interactive "P")(org-agenda arg "w")))
#+END_SRC

***** org-agenda END
#+BEGIN_SRC emacs-lisp
  )
#+END_SRC

**** org-refile
By [[https://www.reddit.com/r/emacs/comments/4366f9/how_do_orgrefiletargets_work/czg008y/][/u/awalker4 on reddit]].
Show upto 3 levels of headings from the current file and two levels of headings from all agenda files
#+BEGIN_SRC emacs-lisp
  (setq org-refile-targets
        '((nil . (:maxlevel . 3))
          (org-agenda-files . (:maxlevel . 2))))
#+END_SRC
Each element of the list generates a set of possible targets.
/nil/ indicates that all the headings in the current buffer will be considered.

Following are from Aaron Bieber's post [[https://blog.aaronbieber.com/2017/03/19/organizing-notes-with-refile.html][Organizing Notes with Refile]]

Creating new parents - To create new heading, add =/HeadingName= to the end when using refile (=C-c C-w=)
#+BEGIN_SRC emacs-lisp
  (setq org-refile-allow-creating-parent-nodes 'confirm)
#+END_SRC

Refile to top level
#+BEGIN_SRC emacs-lisp
  (setq org-refile-use-outline-path 'file)
  (setq org-outline-path-complete-in-steps nil)
#+END_SRC

***** TODO Show filename while refiling to headings in other files
***** TODO Set org-refile targets based on current file
Why would I want to refile something work-related under Softwares etc.
A way to do it is by writing a function that sets /org-refile-targets/ in a let binding making it local.
eg. implementation by abo-abo: [[https://github.com/abo-abo/worf/blob/master/worf.el][worf-refile-other]]

#+BEGIN_SRC emacs-lisp :tangle no
  (load-library "find-lisp")

  (defun my/org-refile-targets ()
    "Refile the current heading to another heading.
  The other heading can be in the current file or in a file that resides
  anywhere below the directory the current file resides in.

  The intent is to move to a similar file. If I'm in work-related file,
  I almost never have to refile something to a personal file."
    (interactive "p")
    (let* ((org-refile-targets '((nil . (:maxlevel . 9)))))
      (org-refile)))

  (bind-key* "C-c C-w" 'my/org-refile-targets)
#+END_SRC

**** org-capture
Show hierarchical headlines when refiling instead of flattening it out
Show all the hierarchical headlines instead of having to step down them

#+BEGIN_SRC emacs-lisp
  (setq org-refile-use-outline-path t)
  (setq org-outline-path-complete-in-steps nil)
#+END_SRC

From [[http://cestlaz.github.io/posts/using-emacs-23-capture-1][Using Emacs 23 - Capture 1]] and [[http://cestlaz.github.io/posts/using-emacs-24-capture-2][Using Emacs 24 - Capture 2]]
#+BEGIN_SRC emacs-lisp
  (setq org-capture-templates
        '(("t" "TODO" entry
           (file+headline org-default-notes-file "Inbox")
           "* TODO %^{Task}\n\n%?"
           :jump-to-captured t :empty-lines 1)

          ("c" "Misc" entry
           (file+headline org-default-notes-file "Inbox")
           "* %^{Task}\n\n%?"
           :jump-to-captured t :empty-lines 1)

          ;; ("l"  "Spanish")

          ;; ("ls" "Item" entry
          ;;  (file+headline (concat org-directory "Personal/Spanish.org") "Misc")
          ;;  "\n* %?%(setq my-spanish-capture (read-string \"Spanish: \")) :drill:%(org-set-property \"DRILL_CARD_TYPE\" \"hide1_firstmore\")\n\nSpanish: [%(message my-spanish-capture)]\nEnglish: [%^{English}]"
          ;;  :jump-to-captured t :empty-lines 1)

          ;; ("ln" "Noun" entry
          ;;  (file+headline (concat org-directory "Personal/Spanish.org") "Nouns")
          ;;  "\n* %?[%(setq my-spanish-capture (read-string \"Spanish: \"))] :drill:%(org-set-property \"DRILL_CARD_TYPE\" \"twosided\")\n\nTranslate this noun.\n\n** Spanish\n/%(message my-spanish-capture)/\n\n** English\n%^{English}"
          ;;  :jump-to-captured t :empty-lines 1)

          ;; ("lv" "Verb" entry
          ;;  (file+headline (concat org-directory "Personal/Spanish.org") "Verbs")
          ;;  "\n* %(setq my-spanish-capture (read-string \"Spanish: \")) :drill:%(org-set-property \"DRILL_CARD_TYPE\" \"hide1cloze\")%(org-set-property \"VERB_INFINITIVE\" (concat \"\\\"\" my-spanish-capture \"\\\"\"))%(org-set-property \"VERB_TRANSLATION\" (concat \"\\\"to \" (setq my-english-capture (read-from-minibuffer \"English: to \")) \"\\\"\"))%(org-set-property \"VERB_INFINITIVE_HINT\" (concat \"\\\"\" (substring my-spanish-capture 0 1) \"...\\\"\"))\n\nSpanish: [%(message my-spanish-capture)]\nEnglish: [to %(message my-english-capture)]\n\n** Notes\n** Examples\n** Simple Present Tense :drill:%(org-set-property \"DRILL_CARD_TYPE\" \"conjugate\")%(org-set-property \"VERB_TENSE\" \"\\\"simple present\\\"\")\n\n| yo               | %?  |\n| tú               |   |\n| él/ella/Ud.      |   |\n| nosotros         |   |\n| vosotros         |   |\n| ellos/ellas/Uds. |   |"
          ;;  :jump-to-captured t :empty-lines 1)

          ("s"  "Code snippets")

          ("se" "Emacs" entry
           (file "~/Notes/Software/emacs.org")
           :jump-to-captured t)

          ("ss" "Shell" entry
           (file (concat org-directory "Software/shell.org"))
           :jump-to-captured t)

          ("sv" "Vim" entry
           (file (concat org-directory "Software/vim.org"))
           :jump-to-captured t)))
#+END_SRC

NOTE: When using several keys, keys using the same prefix key must be sequential in the list and preceded by a 2-element entry explaining the prefix key.
[[http://orgmode.org/manual/Template-elements.html#Template-elements][Template elements]], [[http://orgmode.org/manual/Template-elements.html#Template-expansion][Template expansion]]

We use this to create frames for org-capture directly from the OS as shown [[http://cestlaz.github.io/posts/using-emacs-24-capture-2/][here]].
#+BEGIN_SRC emacs-lisp
  (use-package noflet)

  (defun my/make-capture-frame ()
    "Create a new frame and run org-capture."
    (interactive)
    (make-frame '((name . "capture")))
    (select-frame-by-name "capture")
    (delete-other-windows)
    (noflet ((switch-to-buffer-other-window (buf) (switch-to-buffer buf)))
      (org-capture)))

  (defadvice org-capture-finalize
      (after delete-capture-frame activate)
    "Advise capture-finalize to close the frame"
    (if (equal "capture" (frame-parameter nil 'name))
        (delete-frame)))

  (defadvice org-capture-destroy
      (after delete-capture-frame activate)
    "Advise capture-destroy to close the frame"
    (if (equal "capture" (frame-parameter nil 'name))
        (delete-frame)))
#+END_SRC

***** TODO Using %^{prompt} in org-capture template doesn't allow specifying accented characters with =C-x 8=
Hence, I'm using a hacky way of explicitly prompting for input (since I can specify accented characters that way),
saving it to a variable and printing it out later in the capture template.

**** org-id
I grab the /org-plus-contrib/ version of org-id to match org. Also look at [[ensure_target]].
#+BEGIN_SRC emacs-lisp
  (use-package org-id
    :ensure org-plus-contrib
    :pin repo-org
    :init
    (setq org-id-link-to-org-use-id 'create-if-interactive-and-no-custom-id)

    :config
#+END_SRC

To effectively use custom ID, refer [[https://writequit.org/articles/emacs-org-mode-generate-ids.html#update-2016-09-07][this]].
Note that =org-id= has been updated since then and now supports a method =org-id-get-create= which creates an ID if one is not present.
Also, it uses the identifier /ID/ instead of /CUSTOM_ID/

***** TODO Use org-id globally across all files
Example on [[http://stackoverflow.com/a/27158715/734153][Emacs StackExchange]]
#+BEGIN_SRC emacs-lisp
  (setq org-id-track-globally t)
  (setq org-id-extra-files '("~/.emacs.d/config.org"))
#+END_SRC

***** Completion while inserting link
:PROPERTIES:
:ID:       be086bdd-ffcf-4f4e-beb2-a948191895eb
:END:
To use completion, insert link using =C-c C-l= and select =id:= as type and completion should trigger.
=org-id-get-with-outline-path-completion= returns the ID of the selected heading and creates it if it doesn't have one already.
Details at [[http://emacs.stackexchange.com/a/12434/9690][Emacs StackExchange]]
#+BEGIN_SRC emacs-lisp
  (defun org-id-complete-link (&optional arg)
    "Create an id: link using completion"
    (concat "id:" (org-id-get-with-outline-path-completion)))

  (org-link-set-parameters "id" :complete 'org-id-complete-link)
#+END_SRC

***** END
#+BEGIN_SRC emacs-lisp
  )
#+END_SRC

**** org-drill
I grab the /org-plus-contrib/ version of org-id to match org. Also look at [[ensure_target]].
#+BEGIN_SRC emacs-lisp
  (use-package org-drill
    :disabled
    :ensure org-plus-contrib
    :init
    (setq org-drill-learn-fraction 0.4)
    :config
    (add-to-list 'org-modules 'org-drill)
    (setq org-drill-add-random-noise-to-intervals-p t)
    (setq org-drill-hide-item-headings-p t)

    (use-package org-drill-table
      :disabled
      :load-path "bundle/org-drill-table"))
#+END_SRC

**** htmlize
Syntax highlighting when exporting to HTML? Yes, please!
#+BEGIN_SRC emacs-lisp
  (use-package htmlize
    :disabled)
#+END_SRC

*** Keybinds
:PROPERTIES:
:ID:       ebbf9970-d072-4b59-bcaa-5f4b3d71a7d7
:END:
Custom keymap for org-mode bindings.
#+BEGIN_SRC emacs-lisp
  (bind-keys :map my-leader-map
             :prefix-map my-org-bindings-map
             :prefix-docstring "This map is used to group together all org-mode settings"
             :prefix "o"
             ("a" . org-agenda)
             ("c" . org-capture))
  ;; :bind (("c" . calendar))
#+END_SRC

<<Custom timestamp keymap>>. Also see [[id:d4634d95-be37-4bdf-987e-22da5778e958][Using ! to toggle timestamp type]]
#+BEGIN_SRC emacs-lisp
  (bind-keys :map my-leader-map
             :prefix-map my-org-timestamp-bindings-map
             :prefix-docstring "This map is used to group together all timestamp related bindings"
             :prefix "."
             ("." . my-org-time-stamp)
             ("!" . org-time-stamp-inactive)
             ("<" . org-date-from-calendar)
             (">" . org-goto-calendar)
             ("C-o" . org-open-at-point))
#+END_SRC

Note that org-mode usually has the same command mapped to both =<Prefix> [a-z]= and =<Prefix> C-[a-z]=.
In such cases, I can use =<Prefix> [a-z]= to bind to something else and leave =<Prefix> C-[a-z]= alone.
The mnemonic is that Org leaves =C-c [a-z]= free for the user. Thus, I'm using =[a-z]= in other places too.

Delete the result block using =C-c C-v C-k= where =C-c C-v= is the /org-babel-key-prefix/
#+BEGIN_SRC emacs-lisp
  :bind (:map org-babel-map
              ("C-k" . org-babel-remove-result))
#+END_SRC

*** use-package END
#+BEGIN_SRC emacs-lisp
  )
#+END_SRC

*** TODO Diminish org-indent-mode
** pcre2el
From [[https://www.reddit.com/r/emacs/comments/60nb8b/favorite_builtin_emacs_commands/df8h8hm/][/u/Irkry on reddit]]
#+BEGIN_SRC emacs-lisp
  (use-package pcre2el
    :diminish pcre-mode
    :config
    (pcre-mode t))
#+END_SRC

** rainbow-delimiters
Use brighter colors
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :config
    (progn
      (set-face-attribute 'rainbow-delimiters-depth-1-face nil :foreground "dark orange")
      (set-face-attribute 'rainbow-delimiters-depth-2-face nil :foreground "deep pink")
      (set-face-attribute 'rainbow-delimiters-depth-3-face nil :foreground "chartreuse")
      (set-face-attribute 'rainbow-delimiters-depth-4-face nil :foreground "deep sky blue")
      (set-face-attribute 'rainbow-delimiters-depth-5-face nil :foreground "yellow")
      (set-face-attribute 'rainbow-delimiters-depth-6-face nil :foreground "orchid")
      (set-face-attribute 'rainbow-delimiters-depth-7-face nil :foreground "spring green")
      (set-face-attribute 'rainbow-delimiters-depth-8-face nil :foreground "sienna1"))

    :bind (:map my-unimpaired-toggle-map ("r" . rainbow-delimiters-mode)))
#+END_SRC

** rainbow-mode
When a color is specified as a hex code or with its name, set the background of the face to the value of the color itself
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-mode
    :defer t)
#+END_SRC

Provides command =rainbow-mode= to toggle this

** undo-tree
This lets us visually walk through the changes we've made, undo back to a certain point (or redo), and go down different branches.
Default binding is =C-x u=
#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :diminish undo-tree-mode
    :commands (undo-tree-visualize)
    :config
    (global-undo-tree-mode)
    (setq undo-tree-visualizer-timestamps t)
    (setq undo-tree-visualizer-diff t))
#+END_SRC

** verilog-mode
#+BEGIN_SRC emacs-lisp
  (use-package verilog-mode
    :load-path "bundle/verilog-mode"
    :mode (("\\.v\\'"    . verilog-mode)
           ("\\.svh?\\'" . verilog-mode)
           ("\\.x\\'"    . verilog-mode))
    :config
    (font-lock-mode 1))
#+END_SRC

** yasnippet
#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :diminish yas-minor-mode

    :init
    (setq-default yas-snippet-dirs (list (concat user-emacs-directory "snippets")))
    (setq yas-wrap-around-region t)  ; Automatically insert selected text at $0, if any

    ;; :config
    ;; (defun my/add-yasnippet-ac-sources ()
    ;;   (add-to-list 'ac-sources 'ac-source-yasnippet))
    ;; (add-hook 'c++-mode-hook 'my/add-yasnippet-ac-sources)

    ;; Use S-Tab instead of Tab to avoid conflict with auto-complete. Unbind Tab
    ;; We have to do this two separate ways: http://ergoemacs.org/emacs/emacs_key_notation_return_vs_RET.html
    ;; (define-key yas-minor-mode-map (kbd "TAB") nil)
    ;; (define-key yas-minor-mode-map (kbd "<tab>") nil)

    :bind (:map yas-minor-mode-map
                ("C-c & n"   . yas-new-snippet)
                ("C-c & s"   . yas-insert-snippet)
                ("C-c & v"   . yas-visit-snippet-file)
                ("C-c & r"   . yas-reload-all)
                ("C-c & &"   . yas-describe-tables)))
#+END_SRC

Enable yasnippet only for certain modes
#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook 'yas-minor-mode)
  (add-hook 'c++-mode-hook 'yas-minor-mode)
#+END_SRC

** which-key
Shows which keys can be pressed next. Eg. if you press =C-x= and wait a few seconds, a window pops up with all the key bindings following the currently entered incomplete command.
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :diminish which-key-mode
    :config  (which-key-mode))
#+END_SRC

** Themes
Useful commands:
=list-faces-display= - List all faces with colors and sample text
=list-colors-display= - List all colors with their names

*** load-theme hook
Emacs doesn't have a native hook that is called after a theme has loaded. So we've to create one. (from [[https://www.reddit.com/r/emacs/comments/4v7tcj/does_emacs_have_a_hook_for_when_the_theme_changes/d5wyu1r/][reddit]])
#+BEGIN_SRC emacs-lisp
  (defvar after-load-theme-hook nil
    "Hook run after a color theme is loaded using `load-theme'.")
  (defadvice load-theme (after run-after-load-theme-hook activate)
    "Run `after-load-theme-hook'."
    (run-hooks 'after-load-theme-hook))
#+END_SRC

eg.
#+BEGIN_SRC emacs-lisp :tangle no
  (add-hook 'after-load-theme-hook (lambda() (message "Theme loaded")))
#+END_SRC

*** leuven
[[https://github.com/fniessen/emacs-leuven-theme][Github Link]]
#+BEGIN_SRC emacs-lisp
  (use-package leuven-theme
    :disabled
    :config
    (load-theme 'leuven t)

    (setq evil-normal-state-cursor   '("#008000" box)
          evil-visual-state-cursor   '("#006FE0" box)
          evil-insert-state-cursor   '("#0000FF" bar)
          evil-replace-state-cursor  '("#D0372D" bar)
          evil-operator-state-cursor '("#D0372D" hollow))

    (set-face-attribute 'org-agenda-date         nil :height 1.4)
    (set-face-attribute 'org-agenda-date-today   nil :height 1.4)
    (set-face-attribute 'org-agenda-date-weekend nil :height 1.4)
    (set-face-attribute 'trailing-whitespace     nil :background "#DDDDFF"))
#+END_SRC

Load theme first and then override the colors

*** solarized
https://github.com/bbatsov/solarized-emacs
#+BEGIN_SRC emacs-lisp
  (use-package solarized-theme
    ;; :disabled
    :config
    (load-theme 'solarized-light t)

    (setq evil-normal-state-cursor   '("#719e07" box)
          evil-visual-state-cursor   '("#b58900" box)
          evil-insert-state-cursor   '("#268bd2" bar)
          evil-replace-state-cursor  '("#dc322f" bar)
          evil-operator-state-cursor '("#dc322f" hollow)))
#+END_SRC

*** base16
#+BEGIN_SRC emacs-lisp
  (use-package base16-theme
    :disabled
    :config
    (load-theme 'base16-tomorrow-night t)
    (setq evil-normal-state-cursor   '("#719e07" box)
          evil-visual-state-cursor   '("#b58900" box)
          evil-insert-state-cursor   '("#268bd2" bar)
          evil-replace-state-cursor  '("#dc322f" bar)
          evil-operator-state-cursor '("#dc322f" hollow)))
#+END_SRC

** TODO hydra
Ideas in https::/github.com/kana/vim-submode

* ProgLangEmacs
:PROPERTIES:
:header-args: :tangle no
:END:
** sml-mode
#+BEGIN_SRC emacs-lisp
  (use-package sml-mode
    :if (eq system-type 'gnu/linux)
    :config
    (add-to-list 'org-structure-template-alist
                 '("sml" "#+BEGIN_SRC sml\n?\n#+END_SRC\n" "<src lang=\"?\">\n\n</src>")

    (use-package flycheck-sml
      :ensure nil
      :disabled
      :load-path "bundle/flycheck-sml/"))
#+END_SRC

*** TODO Restart the SML REPL
#+BEGIN_SRC emacs-lisp :tangle no
  (defun my/restart-sml-repl ()
    "Restarts the SML REPL"
    (interactive)
    (progn
      (when (get-buffer-process (current-buffer))
        (goto-char (point-max)) ; First go to the end of the buffer
        (comint-delchar-or-maybe-eof 1); Then kill the REPL (C-d)
        (sleep-for 0.1)) ; This is needed for some reason
      (sml-run "sml" nil)))

  (bind-key* "C-c C-s" 'my/restart-sml-repl)
#+END_SRC

*** Restart SML REPL and load the correct file
#+BEGIN_SRC emacs-lisp
  (defun my/restart-sml-and-run ()
    "Restarts the SML REPL and tries to load the correct .sml file.

  The sml file loaded is the one at the top of the list returned by
  `buffer-list'.

  If this command is executed while in an sml buffer, the point is returned back
  to that buffer after restarting the REPL and loading that file."
    (interactive)
    (let* ((in-sml-buf (derived-mode-p 'sml-mode))
           (repl-buf (get-buffer "*sml*"))
           (sml-file (if in-sml-buf
                         (buffer-file-name)
                       (catch 'break
                         (dolist (buf (buffer-list))
                           (let ((file (buffer-file-name buf)))
                             (when (and (stringp file)
                                        (string-match-p ".*\\.sml\\'" file))
                               ;; Return the first .sml file name from the list
                               ;; and end the loop.
                               (throw 'break file)))))))
           (msg "Restarted SML"))
      (when repl-buf
        (when in-sml-buf
          ;; If the REPL buffer already exists and you are not in it, switch
          ;; to it.
          (switch-to-buffer-other-window repl-buf))
        ;; If the REPL has a live process, kill it
        (when (get-buffer-process (current-buffer))
          (goto-char (point-max)) ; First go to the EOB
          (comint-delchar-or-maybe-eof 1) ; Then kill the REPL (C-d)
          (sleep-for 0.1))) ; Somehow this is needed between kill and respawn
      (if sml-file
          (setq msg (concat msg (format " and now loading `%s'"
                                        (file-name-nondirectory sml-file))))
        ;; If no sml file was found in the buffer list
        (setq sml-file ""))
      (setq msg (concat msg "."))
      (message msg)
      ;; Then start a new process
      (sml-run "sml" sml-file) ; C-c C-s + typing "use foo.sml" in REPL
      ;; Switch back to the sml buffer if you executed this command from there
      (when in-sml-buf
        (switch-to-buffer-other-window (get-file-buffer sml-file)))))

  (bind-key "C-c <C-return>" #'my/restart-sml-and-run inferior-sml-mode-map)
  (bind-key "C-c <C-return>" #'my/restart-sml-and-run sml-mode-map)
#+END_SRC

*** ob-sml
#+BEGIN_SRC emacs-lisp
  (use-package ob-sml
    :config
    (add-to-list 'org-babel-load-languages '(sml . t))
    (org-babel-do-load-languages 'org-babel-load-languages org-babel-load-languages)
#+END_SRC

**** TODO Launch sml-repl if not running when evaluating a code-block
**** END
#+BEGIN_SRC emacs-lisp
  )
#+END_SRC

*** END
#+BEGIN_SRC emacs-lisp
  )
#+END_SRC

* After
** Private config
#+BEGIN_SRC emacs-lisp
  (when (string< "atlhen" system-name)
    (load (concat user-emacs-directory "private_work.el") t))
#+END_SRC

#+TITLE: Emacs Configuration
#+PROPERTY: header-args :results output silent
#+TODO: TODO | DONE

* Init
** Archives
/package-archives/ uses HTTP access to GNU by default. Replacing it with the https version instead
#+BEGIN_SRC emacs-lisp
  (setq package-archives '(("repo-gnu"   . "https://elpa.gnu.org/packages/")
                           ("repo-melpa" . "https://melpa.milkbox.net/packages/")
                           ("repo-org"   . "http://orgmode.org/elpa/")))
#+END_SRC

** Bootstrap use-package
[[https://www.youtube.com/watch?v%3D2TSKxxYEbII][use-package video tutorial]]

Install and load use-package
#+BEGIN_SRC emacs-lisp
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  (defvar use-package-verbose t)
  (setq use-package-always-ensure t)

  ;; Disable lazy-loading if using a daemon
  (if (daemonp)
      (setq use-package-always-demand t))
#+END_SRC

** TODO Simplify init process
Check if there's a way to keep all the config in this file itself with init.el being empty
Sacha Chua seems to have something like that. Her init.el is simply a link.
Maybe some information in this [[https://www.reddit.com/r/emacs/comments/4uo9r0/shaving_time_on_emacs_startup_from_org_literate/][reddit thread]].

* General
** Convenience functions
Loop over all hooks (from [[https://github.com/cofi/dotfiles/blob/master/emacs.d/config/cofi-util.el#L38][cofi@github]])
#+BEGIN_SRC emacs-lisp
  (defun my/add-hooks (hooks fun)
    "Add function FUN to all HOOKS"
    (dolist (hook hooks)
      (add-hook hook fun)))
#+END_SRC

** Keybindings
#+BEGIN_SRC emacs-lisp
  (bind-keys* :prefix-map my-leader-map
              :prefix-docstring "Top-level map"
              :prefix "C-c")

  (bind-keys  :map my-leader-map
              :prefix-map my-jumper-command-map
              :prefix-docstring "This map is used to put all keybindings that I use to jump around eg. open files, buffers etc."
              :prefix "j")

  (bind-keys  :map my-leader-map
              :prefix-map my-s-bindings-map
              :prefix-docstring "This map is used to group together all s-mnemonic bindings such as substitution, sizing etc."
              :prefix "s")
#+END_SRC

I think the following would be handy
  =[= - Enable setting
  =~= - Toggle setting
  =]= - Disable setting
Original use of =C-c [= and =C-c ]= is to manipulate =org-agenda-files= and =C-c ~= is used to =org-create-table-with-table.el=.
Since I don't use any of these, might as well put them to better use.

#+BEGIN_SRC emacs-lisp
  (bind-keys  :map my-leader-map
              :prefix-map my-unimpaired-enable-map
              :prefix-docstring "This map is used to enable settings ala vim-unimpaired"
              :prefix "[")

  (bind-keys  :map my-leader-map
              :prefix-map my-unimpaired-disable-map
              :prefix-docstring "This map is used to disable settings ala vim-unimpaired"
              :prefix "]")

  (bind-keys  :map my-leader-map
              :prefix-map my-unimpaired-toggle-map
              :prefix-docstring "This map is used to toggle settings ala vim-unimpaired"
              :prefix "~")
#+END_SRC

To delete existing bindings, use =(unbind-key ...)=

*** Misc
#+BEGIN_SRC emacs-lisp
  (bind-key* "C-h B" 'describe-personal-keybindings)
#+END_SRC

By default C-x = is bound to /what-cursor-position/ but evil maps both =ga= and =g8= to that as well so might as well use it to show something useful.
#+BEGIN_SRC emacs-lisp
  (bind-key* "C-x =" 'describe-char)
#+end_src

#+begin_src emacs-lisp
  (defun my/revert-buffer-no-confirm ()
    "Revert buffer without confirmation."
    (interactive)
    (revert-buffer :ignore-auto :noconfirm))

  (bind-key* "<f5>" 'my/revert-buffer-no-confirm)
#+END_SRC

=key-translation-map= can be used to /map/ one set of keys to another [[id:f42c3dc8-c2f6-4f22-9f47-0c578479ef67][eg.]]

** Autosave, Backup and History
Change default location of backups to avoid littering PWD
#+BEGIN_SRC emacs-lisp
  (defvar backup-directory (concat user-emacs-directory "/tmp/backups"))
  (if (not (file-exists-p backup-directory)) (make-directory backup-directory t))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (setq backup-directory-alist `(("." . ,backup-directory)))
  (setq make-backup-files         t)  ; backup of a file the first time it is saved.
  (setq backup-by-copying         t)  ; don't clobber symlinks
  (setq version-control           t)  ; version numbers for backup files
  (setq delete-old-versions       t)  ; delete excess backup files silently
  (setq delete-by-moving-to-trash t)
  (setq kept-old-versions         6)  ; oldest versions to keep when a new numbered backup is made (default: 2)
  (setq kept-new-versions         9)  ; newest versions to keep when a new numbered backup is made (default: 2)
#+END_SRC

Change default location of autosaves to avoid littering PWD
#+BEGIN_SRC emacs-lisp
  (defvar autosave-directory (concat user-emacs-directory "tmp/autosaves/"))
  (if (not (file-exists-p autosave-directory)) (make-directory autosave-directory t))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  ;; (setq auto-save-file-name-transforms `(("." ,autosave-directory t)))
  (setq auto-save-default t)  ; auto-save every buffer that visits a file
#+END_SRC

Delete identical history entries
#+BEGIN_SRC emacs-lisp
(setq history-delete-duplicates t)
#+END_SRC

Save mini-buffer history
#+BEGIN_SRC emacs-lisp
  (use-package savehist
    :init
    (setq savehist-file (concat user-emacs-directory "tmp/history.el")
          history-length 100)
    :config
    (savehist-mode t))
#+END_SRC

** Clean-up & QoL
Remove visual clutter
#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-message t)
  (setq initial-scratch-message "")

  (menu-bar-mode 0)
  (tool-bar-mode 0)
  (scroll-bar-mode 0)
  ;; (tooltip-mode 0)
#+END_SRC

We can also put something like this into =~/.Xresources= to enable/disable certain things as soon as Emacs starts
#+BEGIN_EXAMPLE
  Emacs.verticalScrollBars: off
  Emacs.toolBar: off
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp
  ;; Enable editing by visual lines
  (global-visual-line-mode t)

  ;; Let emacs react faster to keystrokes
  (setq echo-keystrokes 0.1)
  (setq idle-update-delay 0.35)

  ;; Jump to the help window when it's opened.
  ;; Press q to close it and restore the view to the previous buffer
  (setq help-window-select t)

  ;; Confirm before quitting - sometimes I fat-finger and press both C-x C-c instead of just C-c
  (setq confirm-kill-emacs 'y-or-n-p)

  ;; Simpler y/n answers
  (fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

*** Winner mode - Undo/redo window layouts
Undo and Redo changes in window configuration. Use =C-c right=, =C-c left= (default bindings) to switch between different layouts.
This is useful when I close a window by mistake to undo it and restore the window layout.
#+BEGIN_SRC emacs-lisp
  (winner-mode 1)
#+END_SRC

[[id:f42c3dc8-c2f6-4f22-9f47-0c578479ef67][More intuitive keybindings]] defined after evil is loaded

** Diff
From [[http://pragmaticemacs.com/emacs/visualise-and-copy-differences-between-files/][Pragmatic Emacs]]
#+BEGIN_SRC emacs-lisp
  (use-package ediff
    :config

    ;; Don't start another frame
    (setq ediff-window-setup-function 'ediff-setup-windows-plain)

    ;; Put windows side by side
    (setq ediff-split-window-function (quote split-window-horizontally))

    ;; Revert windows on exit - needs winner mode
    (add-hook 'ediff-after-quit-hook-internal 'winner-undo))
#+END_SRC

** Electric pairs
#+BEGIN_SRC emacs-lisp
  (electric-pair-mode t)
#+END_SRC

** Emacs server
- Always start the emacs-server, except when run in daemon mode
- Already Disable prompt asking you if you want to kill a buffer with a live process attached to it.
  http://stackoverflow.com/questions/268088/how-to-remove-the-prompt-for-killing-emacsclient-buffers

#+BEGIN_SRC emacs-lisp
  (use-package server
    :disabled
    :config
    (unless (or (daemonp) (server-running-p))
      (server-mode 1))
    (add-hook 'server-switch-hook 'raise-frame))
#+END_SRC

Alias for emacsclient:
This will launch emacsclient if a server is already running and launch emacs if not
#+BEGIN_EXAMPLE
  alias e='emacsclient --alternate-editor="emacs" --create-frame --quiet'
#+END_EXAMPLE

** Fonts
:PROPERTIES:
:ID:       bd542328-7d1d-4806-936d-a50673beada6
:END:
Scale font size using =C-x C-+= and =C-x C--=. =C-x C-0= resets it.
=text-scale-mode-step= controls the scaling factor. For obvious reasons, don't set it to 1 else it won't change at all
#+BEGIN_SRC emacs-lisp
  (setq text-scale-mode-step 1.1)
  (setq-default line-spacing 1)
#+END_SRC

After installing a new font refresh the font cache by running
#+BEGIN_SRC bash
  fc-cache -fv
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun my/set-font-if-exists (font)
    " Check if FONT exists and set if it does"
    (when (and (display-graphic-p)(x-list-fonts font))
      (set-face-attribute 'default        nil :font font)
      (set-face-attribute 'variable-pitch nil :font font)
      (set-face-attribute 'fixed-pitch    nil :font font)
      t))  ; This is required so that we can use this function in a cond block below

  (defun my/select-and-set-font ()
    " Select the font based on OS, hostname etc."
    (cond ((eq system-type 'windows-nt) (my/set-font-if-exists "Iosevka-10"))
          ((eq system-type 'gnu/linux) (my/set-font-if-exists "Iosevka-9"))))

  (if (daemonp)
      (add-hook 'after-make-frame-functions
                (lambda (frame)
                  (select-frame frame)
                  (my/select-and-set-font)))
    (my/select-and-set-font))
#+END_SRC
#+BEGIN_SRC emacs-lisp :tangle no
  (when (and (display-graphic-p) (x-list-fonts "Iosevka"))
    (add-to-list 'default-frame-alist '(font . "Iosevka-10:weight=book"))
    (set-face-attribute 'default t :font "Iosevka-10:weight=book"))
#+END_SRC

The reason for adding the hook is that if I try to create a daemon, it errors out with
    /error: Window system is not in use or not initialized/
This is because we try to set a face-attribute before a frame is created which is a no-no for some reason.

However, the downside to this is that if I have multiple such hooks (like in private.el) we can't dictate the order in which they're applied.

Fallback to DejaVu Sans when the font lacks support for some glyphs. Taken from [[https://github.com/joodie/emacs-literal-config/blob/c66e30ce961b140dd3e84116f4d45cbc19d0d944/emacs.org#font][github:joodie]]
How does this work? What is it supposed to do?
#+BEGIN_SRC emacs-lisp :tangle no
  (when (functionp 'set-fontset-font)
    (set-fontset-font "fontset-default" 'unicode
                      (font-spec :family "DejaVu Sans Mono"
                                 :width 'normal
                                 :size 11
                                 :weight 'normal)))
#+END_SRC

*** UTF-8 Please
#+BEGIN_SRC emacs-lisp
  (setq locale-coding-system   'utf-8)
  (set-terminal-coding-system  'utf-8)
  (set-keyboard-coding-system  'utf-8)
  (set-selection-coding-system 'utf-8)
  (set-language-environment    "UTF-8")
  (prefer-coding-system        'utf-8)
#+END_SRC

** Intelligent narrowing and widening
From [[http://endlessparentheses.com/emacs-narrow-or-widen-dwim.html][endless parentheses]]

#+BEGIN_SRC emacs-lisp
  (defun narrow-or-widen-dwim (p)
    "Widen if buffer is narrowed, narrow-dwim otherwise.
  Dwim means: region, org-src-block, org-subtree, or defun, whichever applies first.
  Narrowing to org-src-block actually calls `org-edit-src-code'.

  With prefix P, don't widen, just narrow even if buffer is already narrowed."
    (interactive "P")
    (declare (interactive-only))
    (cond ((and (buffer-narrowed-p) (not p)) (widen))
          ((region-active-p)
           (narrow-to-region (region-beginning)
                             (region-end)))
          ((derived-mode-p 'org-mode)
           ;; `org-edit-src-code' is not a real narrowing command.
           ;; Remove this first conditional if you don't want it.
           (cond ((ignore-errors (org-edit-src-code) t)
                  (delete-other-windows))
                 ((ignore-errors (org-narrow-to-block) t))
                 (t (org-narrow-to-subtree))))
          ((derived-mode-p 'latex-mode)
           (LaTeX-narrow-to-environment))
          (t (narrow-to-defun))))

  ;; This line actually replaces Emacs' entire narrowing keymap.
  (bind-key "n" 'narrow-or-widen-dwim ctl-x-map)
#+END_SRC

** Mode line
#+BEGIN_SRC emacs-lisp
  (column-number-mode t)
#+END_SRC

** Mouse
Mouse-wheel acts on the hovered window rather than the one where the typing focus is
#+BEGIN_SRC emacs-lisp
  (setq mouse-wheel-follow-mouse t)
#+END_SRC

** Prettify
*** Highlight current line
#+BEGIN_SRC emacs-lisp
  (bind-key "c" 'global-hl-line-mode my-unimpaired-toggle-map)
  (bind-key "c" '(lambda() (interactive) (global-hl-line-mode 1))  my-unimpaired-enable-map)
  (bind-key "c" '(lambda() (interactive) (global-hl-line-mode -1)) my-unimpaired-disable-map)
#+END_SRC

*** Show matching parens
#+BEGIN_SRC emacs-lisp
  (show-paren-mode 1)
  (setq show-paren-delay 0)
  ;; (setq show-paren-style 'expression)
#+END_SRC

*** Pretty symbols
Replaces the text /lambda/ with λ. Full list of prettified symbols can be found in =prettify-symbols-alist=
The =inhibit-compacting-font-caches= stops garbage collect from trying to handle font caches making things a lot faster
#+BEGIN_SRC emacs-lisp
  (global-prettify-symbols-mode t)
  (setq inhibit-compacting-font-caches t)
  (setq prettify-symbols-unprettify-at-point 'right-edge)
#+END_SRC

Default symbols that must be applied to all modes
#+BEGIN_SRC emacs-lisp
  (defun my/pretty-symbols-default()
    (mapc (lambda(pair) (push pair prettify-symbols-alist))
          '(("!=" . ?≠)
            ("<=" . ?≤)
            (">=" . ?≥))))

  (add-hook 'prog-mode-hook (lambda() (my/pretty-symbols-default)))
#+END_SRC

C/C++ specific symbols
#+BEGIN_SRC emacs-lisp
  (add-hook 'c++-mode-hook
            (lambda() (mapc (lambda(pair) (push pair prettify-symbols-alist))
                       '(("->" . (?- (Br . Bc) ?- (Br . Bc) ?>))))))
#+END_SRC


NOTE: Some symbols occupy less space and may affect indendation. In order to avoid this,

**** Using prettify-symbols without breaking indentation
(From [[http://endlessparentheses.com/using-prettify-symbols-in-clojure-and-elisp-without-breaking-indentation.html][endlessparentheses]])
Use ~(">=" . (?\s (Br . Bl) ?\s (Bc . Bc) ?≥))~ instead of =?≥=

** Tabs, Indentation and Spacing
:PROPERTIES:
:ID:       8d72d9c2-5b52-454f-892a-107b009563fa
:END:
Use only spaces and no tabs
#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
  (setq-default tab-width 2)
  (setq-default show-trailing-whitespace nil)

  (setq-default sh-basic-offset 2)
  ;; (bind-key "RET" 'newline-and-indent)

  ;; Count 1 space after a period as the end of a sentence, instead of 2
  (setq sentence-end-double-space nil)
#+end_src
Since these are buffer-local variables, I have to use =setq-default=

*** Highlight trailing whitespace
#+BEGIN_SRC emacs-lisp
  (defun my/toggle-trailing-whitespace ()
    "Toggle trailing whitespace"
    (interactive)  ; Allows to be called as a command via M-x
    (setq-default show-trailing-whitespace (not show-trailing-whitespace)))

  (bind-key "SPC" '(lambda () (interactive)(setq-default show-trailing-whitespace t)) my-unimpaired-enable-map)
  (bind-key "SPC" '(lambda () (interactive)(setq-default show-trailing-whitespace nil)) my-unimpaired-disable-map)
  (bind-key "SPC" 'my/toggle-trailing-whitespace my-unimpaired-toggle-map)
#+END_SRC

Enable it only in some modes
#+BEGIN_SRC emacs-lisp
  (my/add-hooks '(prog-mode-hook text-mode-hook) (lambda() (setq show-trailing-whitespace t)))
#+END_SRC

*** Delete trailing whitespace
Automatically while saving (from [[https://www.emacswiki.org/emacs/DeletingWhitespace#toc3][emacswiki]])
#+BEGIN_SRC emacs-lisp
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC

Use =C-c s SPC= to delete trailing whitespace manually
#+BEGIN_SRC emacs-lisp
  (bind-key "SPC" 'delete-trailing-whitespace my-s-bindings-map)
#+END_SRC

*** Toggle wrap
#+BEGIN_SRC emacs-lisp
  (bind-key "w" 'toggle-truncate-lines my-unimpaired-toggle-map)
#+END_SRC

** Terminal
Specify the shell to use to avoid prompt. From [[https://youtu.be/L9vA7FHoQnk?list=PLX2044Ew-UVVv31a0-Qn3dA6Sd_-NyA1n&t=192][Uncle Dave's video]]
#+BEGIN_SRC emacs-lisp
  (defvar my-term-shell "/bin/bash")
  (defadvice ansi-term (before force-bash)
    (interactive (list my-term-shell)))
  (ad-activate 'ansi-term)
#+END_SRC

Launch
#+BEGIN_SRC emacs-lisp
  (bind-key* "<s-return>" 'ansi-term)
#+END_SRC

** Theme Directories
#+BEGIN_SRC emacs-lisp
  (add-to-list 'custom-theme-load-path (concat user-emacs-directory "/themes"))
  (add-to-list 'load-path (concat user-emacs-directory "/themes"))
#+END_SRC

** Visual
#+BEGIN_SRC emacs-lisp
  ;; Disable anoying beep
  (setq ring-bell-function 'ignore)

  ;; Improve rendering performance
  (setq redisplay-dont-pause t)

  ;; Display a special glyph in the fringe of each empty line at the end of the buffer
  (setq indicate-empty-lines t)
#+END_SRC

** TODO Frame related
Specify width and height /pixel-wise
#+BEGIN_SRC emacs-lisp
  ;; Set frame size pixelwise instead of characterwise
  (setq frame-resize-pixelwise t)

  ;; Set size of default frame
  (setq default-frame-alist
        '((top    . 0)
          (left   . 0)
          (width  . 319)
          (height . 74)))
#+END_SRC

Set frame size programatically
#+BEGIN_SRC emacs-lisp
  (bind-keys :map my-s-bindings-map
             ("l" . (lambda () "Set emacs frame size to fit the left desktop monitor"
                      (interactive)
                      (set-frame-position (selected-frame) 0    0)
                      (set-frame-size     (selected-frame) 1901 1122 t)))
             ("r" . (lambda () "Set emacs frame size to fit the right desktop monitor"
                      (interactive)
                      (set-frame-position (selected-frame) 1919 0)
                      (set-frame-size     (selected-frame) 1902 1122 t))))
#+END_SRC

For reasons I don't understand, when I start a server and create a frame it still shows scroll-bars.
So, I have to disable this explicitly
#+BEGIN_SRC emacs-lisp
  (add-to-list 'default-frame-alist
               '(vertical-scroll-bars . nil))
#+END_SRC

** TODO Scratch
Mode-specific scratch buffers?

* Packages
=(featurep 'FEATURE)= can be used to determine if the package has been loaded or not.
eg. if we do =C-h f ivy-mode=, it says it's defined in /ivy.el/ and at the bottom of the file, we see =(provide 'ivy)=
Thus, ivy is the feature-name.

Other examples:
- /rainbow-mode/ is a mode provided by the file /rainbow-mode.el/ and the feature is also called /rainbow-mode/
- /yas-minor-mode/ is a mode provided by the file /yasnippet.el/ and the feature is called /yasnippet/

** aggressive-indent
#+BEGIN_SRC emacs-lisp
  (use-package aggressive-indent
    :hook (emacs-lisp-mode . aggressive-indent-mode))
#+END_SRC

** avy
#+BEGIN_SRC emacs-lisp
  (use-package avy
    :after evil
    :bind (:map evil-normal-state-map
                ("g s" . avy-goto-char)))
#+END_SRC

** beacon
#+BEGIN_SRC emacs-lisp
  (use-package beacon
    :init
    (setq beacon-blink-when-window-scrolls nil
          beacon-color (face-attribute 'highlight :background))
    :config
    (beacon-mode 1)
    (add-hook 'after-load-theme-hook
              (lambda()
                "Update beacon's background color once a theme is loaded"
                (setq beacon-color (face-attribute 'highlight :background)))))
#+END_SRC

** completion
Create a keybinding map specifically for auto-completion
#+BEGIN_SRC emacs-lisp
  (bind-keys :map my-leader-map
             :prefix-map my-auto-completion-map
             :prefix-docstring "This map is used to put all auto-completion related keybindings"
             :prefix "c")
#+END_SRC

*** company
Provides auto-completion. Refer to [[https://youtu.be/XeWZfruRu6k][Uncle Dave's video]] for an introduction.
#+BEGIN_SRC emacs-lisp
  (use-package company
    :init
    (add-hook 'after-init-hook 'global-company-mode)

    :bind (:map my-auto-completion-map
                ("y" . company-yasnippet))

    :config
    (setq company-idle-delay 0
          company-minimum-prefix-length 2
          company-show-numbers t           ; Show numbers in the drop-down menu to simplify selection
          company-selection-wrap-around t)

    (add-hook 'c++-mode-hook 'company-mode)
    (add-hook 'c-mode-hook 'company-mode)
#+END_SRC

**** Keybindings
Replace Meta bindings with Ctrl
#+BEGIN_SRC emacs-lisp
  (unbind-key "M-n" company-active-map)
  (unbind-key "M-p" company-active-map)

  (bind-keys :map company-active-map
             ("C-n" . company-select-next)
             ("C-p" . company-select-previous))
#+END_SRC

**** Misc plugins
#+BEGIN_SRC emacs-lisp
  (use-package company-irony
    :config
    (add-to-list 'company-backends 'company-irony))
#+END_SRC

**** Don't get in the way of mah typing!
The intent of this section is to make company as unobtrusive as possible; I want company to show me completions as I type
but I want complete control over if I want to accept it or not.

When the completion menu pops-up, the =company-active-map= is activated and it stays open while any key in it is pressed.
To fix this, I'm going to use [[https://github.com/company-mode/company-mode/blob/master/company-tng.el][company-tng]] (/tab-n-go/) as the frontend which allows showing the menu with no entry selected.
I'm going to call this as not having explicitly interacted with company and while in this state, I want to reduce the
number of keys bound in =company-active-map= to minimize my chances of needing to kill it to just be able to continue typing.
This also inserts the selected entry automatically and since there's no need to confirm, it frees up =RET= as well.
#+BEGIN_SRC emacs-lisp
  (use-package company-tng
    :config
    (setq company-frontends '(company-tng-frontend
                              company-pseudo-tooltip-frontend
                              company-echo-metadata-frontend)))
#+END_SRC

Unsetting =company-require-match= allows free typing at any point
#+BEGIN_SRC emacs-lisp
  (setq company-require-match nil)
#+END_SRC

Next I'm going to unbind keys that I don't use much so that I can use them for emacs' actions rather than for company's.
#+BEGIN_SRC emacs-lisp
  (unbind-key "C-w"      company-active-map)
  (unbind-key "C-h"      company-active-map)
  (unbind-key "<f1>"     company-active-map)
  (unbind-key "<up>"     company-active-map)
  (unbind-key "<down>"   company-active-map)
  (unbind-key "<return>" company-active-map)
  (unbind-key "RET"      company-active-map)
  (unbind-key "<tab>"    company-active-map)
  (unbind-key "TAB"      company-active-map)
#+END_SRC
(=<return>= and =<tab>= are for windowed emacs while =RET= and =TAB= are for terminal)

Now that I've trimmed the fat, I'm going to work on stuff that I can't remove as I want to use them in the completion menu.
Some of the keys defined in the keymap are =C-s=, =C-M-s=, =M-[0-9]= etc. are hijacked as soon as the completion menu opens and
I can't use those for typing normally until I close it even if I haven't explicitly interacted with it.
So, I'm going to bind these only if I have explicitly interacted with Company. (credit: [[https://github.com/raxod502/radian/blob/223abc524f693504af6ebbc70ad2d84d9a6e2d1b/radian-emacs/radian-autocomplete.el#L6-L182][link]])
#+BEGIN_SRC emacs-lisp
  (bind-keys :map company-active-map
             :filter (company-explicit-action-p)
             ("C-s"   . company-search-candiates)
             ("C-M-s" . company-filter-candidates))
#+END_SRC

All done! Now, while I type, company shows me a list of completions but doesn't highlight any of them till I select one.
Also, I can use almost all keys to continue typing with the exception of =C-n=, =C-p= and =M-[0-9]= which I use to interact with company.
Pressing =C-n= or =C-p= selects the first or last entry from the completion menu and highlights it.
Once I've explicitly interacted with the completion menu, I can cycle through the entries using =C-n= and =C-p= and use
=C-s= or =C-M-s= to search or filter the entries
Once I select an entry, it's automatically inserted and there's no need to confirm the selection.
I can also use =M-[0-9]= to directly select and insert any specific entry.
At any time I can abort the completion using =C-g= and it restores the text to its state before completion.

**** Enable yasnippet for all backends
Disabled to avoid clutter. If required, it can still be triggered using =C-c c y=

(from [[https://emacs.stackexchange.com/a/10520/9690][emacs.stackexchange]])
Keeping this at the end to be run after we've added all backends
#+BEGIN_SRC emacs-lisp :tangle no
  (defun company-mode/backend-with-yas (backend)
    (if (and (listp backend) (member 'company-yasnippet backend))
        backend
      (append (if (consp backend) backend (list backend))
              '(:with company-yasnippet))))

  (setq company-backends (mapcar #'company-mode/backend-with-yas company-backends))
#+END_SRC

**** /fin/
#+BEGIN_SRC emacs-lisp
)
#+END_SRC

*** irony
#+BEGIN_SRC emacs-lisp
  (use-package irony
    :config
    (add-hook 'c++-mode-hook 'irony-mode)
    (add-hook 'c-mode-hook 'irony-mode)
    (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options))
#+END_SRC

*** yasnippet
Use =C-d= to clear the field without accepting the default field name

#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :commands (yas-reload-all yas-minor-mode)
    :init
    (add-hook 'c++-mode-hook (lambda() (yas-reload-all)(yas-minor-mode)))
    (setq-default yas-snippet-dirs (list (concat user-emacs-directory "snippets")))
    (setq yas-wrap-around-region t)  ; Automatically insert selected text at $0, if any
    :config
    (bind-keys :map yas-minor-mode-map
               ("C-c & n" . yas-new-snippet)
               ("C-c & s" . yas-insert-snippet)
               ("C-c & v" . yas-visit-snippet-file)
               ("C-c & r" . yas-reload-all)
               ("C-c & &" . yas-describe-tables)))
#+END_SRC

NOTE:
- Normally, I would've used =:hook= to defer loading. However, just running =yas-minor-mode= isn't sufficient and yasnippet
  requires that I run =yas-reload-all= before it ()
  As a result, I've to do it in a round-about manner by adding a hook.
- I can't use =:bind= here to defer loading because I'm adding bindings to a map which doesn't exist till the plugin is loaded.
  I could use =:bind-keymap= here instead but as explained above, I need to do =yas-reload-all= as well and I don't know how to do that with =:bind-keymap=.
  Also, I want to avoid confusion when I read this 3 months later wondering how it works.

** evil
evil can be toggled using =C-z=
#+BEGIN_SRC emacs-lisp
  (use-package evil
    :init
    (setq evil-want-C-w-in-emacs-state t
          evil-want-Y-yank-to-eol t)
    :config
    (evil-mode t)
#+END_SRC

*** :config
#+BEGIN_SRC emacs-lisp
  :config
#+END_SRC
**** evil-args
#+BEGIN_SRC emacs-lisp
  (use-package evil-args
    :bind (:map evil-inner-text-objects-map
                ("," . evil-inner-arg)
           :map evil-outer-text-objects-map
                ("," . evil-outer-arg)
           :map evil-normal-state-map
                ("] ," . evil-forward-arg)
                ("[ ," . evil-backward-arg)
           :map evil-motion-state-map
                ("] ," . evil-forward-arg)
                ("[ ," . evil-backward-arg)))
#+END_SRC

**** evil-commentary
#+BEGIN_SRC emacs-lisp
  (use-package evil-commentary
    :bind (:map evil-normal-state-map
                ("g c" . evil-commentary)
                :map evil-visual-state-map
                ("g c" . evil-commentary)))
#+END_SRC

**** evil-exchange
#+BEGIN_SRC emacs-lisp
  (use-package evil-exchange
    :config (evil-exchange-cx-install))
#+END_SRC

**** evil-matchit
#+BEGIN_SRC emacs-lisp
  (use-package evil-matchit)
#+END_SRC

**** evil-numbers
#+BEGIN_SRC emacs-lisp
  (use-package evil-numbers
    :bind (:map evil-normal-state-map
               ("C-c +" . evil-numbers/inc-at-pt)
               ("C-c -" . evil-numbers/dec-at-pt)
           :map evil-visual-state-map
               ("C-c +" . evil-numbers/inc-at-pt)
               ("C-c -" . evil-numbers/dec-at-pt)))
#+END_SRC

**** evil-string-inflection
Provides =g~= operator to cycle between snake_case → SCREAMING_SNAKE_CASE → TitleCase → CamelCase → kebab-case
#+BEGIN_SRC emacs-lisp
  (use-package evil-string-inflection
    :bind (:map evil-normal-state-map
                ("g ~" . evil-operator-string-inflection)
           :map evil-visual-state-map
                ("g ~" . evil-operator-string-inflection)))
#+END_SRC

**** evil-surround
#+BEGIN_SRC emacs-lisp
  (use-package evil-surround
    :config (global-evil-surround-mode))
#+END_SRC

**** evil-visualstar
#+BEGIN_SRC emacs-lisp
  (use-package evil-visualstar
    :config (global-evil-visualstar-mode))
#+END_SRC

**** Keybindings
:PROPERTIES:
:ID:       f42c3dc8-c2f6-4f22-9f47-0c578479ef67
:END:

#+BEGIN_SRC emacs-lisp
  (bind-keys :map evil-normal-state-map
             ("] SPC" . (lambda() (interactive) (end-of-line)(newline)))
             ("[ SPC" . (lambda() (interactive) (beginning-of-line)(open-line 1))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook (lambda() (bind-key "z v" 'org-reveal evil-normal-state-map)))
#+END_SRC

***** Make Escape quit everything
From [[http://stackoverflow.com/a/10166400/734153][StackOverflow]].
#+BEGIN_SRC emacs-lisp :tangle no
  (defun my/minibuffer-keyboard-quit ()
    "Abort recursive edit.
          In Delete Selection mode, if the mark is active, just deactivate it;
          then it takes a second ESC to abort the minibuffer."
    (interactive)
    (if (and delete-selection-mode transient-mark-mode mark-active)
        (setq deactivate-mark  t)
      (when (get-buffer "*Completions*") (delete-windows-on "*Completions*"))
      (abort-recursive-edit)))

  (bind-key [escape] 'keyboard-quit               evil-normal-state-map          )
  (bind-key [escape] 'keyboard-quit               evil-visual-state-map          )
  (bind-key [escape] 'my/minibuffer-keyboard-quit minibuffer-local-map           )
  (bind-key [escape] 'my/minibuffer-keyboard-quit minibuffer-local-ns-map        )
  (bind-key [escape] 'my/minibuffer-keyboard-quit minibuffer-local-completion-map)
  (bind-key [escape] 'my/minibuffer-keyboard-quit minibuffer-local-must-match-map)
  (bind-key [escape] 'my/minibuffer-keyboard-quit minibuffer-local-isearch-map   )
#+END_SRC

***** Sensible rebindings
#+BEGIN_SRC emacs-lisp
  (define-key key-translation-map (kbd "ESC")     (kbd "C-g"))
  (define-key key-translation-map (kbd "C-w C-h") (kbd "C-w h"))
  (define-key key-translation-map (kbd "C-w C-j") (kbd "C-w j"))
  (define-key key-translation-map (kbd "C-w C-k") (kbd "C-w k"))
  (define-key key-translation-map (kbd "C-w C-l") (kbd "C-w l"))

  (bind-key "U" 'redo evil-normal-state-map)
#+END_SRC

More intuitive keybindings for winner-mode
#+BEGIN_SRC emacs-lisp
  (bind-keys :map evil-motion-state-map
             ("u" . winner-undo)
             ("U" . winner-redo))
#+END_SRC

***** Follow newly created splits
#+BEGIN_SRC emacs-lisp
  (bind-keys :map evil-motion-state-map
             ("C-w s" . (lambda() (interactive) (evil-window-split)(other-window 1)))
             ("C-w v" . (lambda() (interactive) (evil-window-vsplit)(other-window 1))))
  (define-key key-translation-map (kbd "C-w C-s") (kbd "C-w s"))
  (define-key key-translation-map (kbd "C-w C-v") (kbd "C-w v"))
#+END_SRC

***** Move by visual lines
Note this is not a complete solution since it doesn't work when combined with operators (eg. =dj=)
#+BEGIN_SRC emacs-lisp
  (bind-keys :map evil-motion-state-map
             ("j"  . evil-next-visual-line)
             ("gj" . evil-next-line)
             ("k"  . evil-previous-visual-line)
             ("gk" . evil-previous-line)
             ("$"  . evil-end-of-line)
             ("g$" . evil-end-of-visual-line))
#+END_SRC

**** TODO Set evil-emacs-state-cursor based on the theme loaded
Also set the cursor to a box if the buffer is not modifiable (eg. org-agenda view) or a bar if it is

*** /fin/
#+BEGIN_SRC emacs-lisp
  )
#+END_SRC

** flycheck
#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :hook (prog-mode . flycheck-mode)
    :init
    (setq flycheck-gcc-language-standard "c++14"
          flycheck-clang-language-standard "c++14"))
#+END_SRC

** hydra
#+BEGIN_SRC emacs-lisp
  (use-package hydra)
#+END_SRC

Currently I'm using this only for =ivy-hydra=. More ideas in https::/github.com/kana/vim-submode

** ivy et al.
#+BEGIN_SRC emacs-lisp
  (use-package ivy
    :config
    (ivy-mode 1)
    (setq ivy-count-format "%d/%d "
          ivy-height 12
          ivy-extra-directories nil)
#+END_SRC

Do not add a =^= (beginning of line anchor) while completing. Refer [[https://github.com/abo-abo/swiper/issues/140][this]] and [[https://github.com/abo-abo/swiper/issues/1126][this]].
#+BEGIN_SRC emacs-lisp
  (setq ivy-initial-inputs-alist nil)
#+END_SRC

From [[https://github.com/kaushalmodi/.emacs.d/blob/master/setup-files/setup-ivy.el][kaushalmodi's repo]]
#+BEGIN_SRC emacs-lisp
  (defun my/ivy-set-prompt-text-properties (prompt std-props)
    "Add a different face for the current value in `counsel-set-variable'."
    (ivy--set-match-props prompt "<\\(.*\\)>"
                          `(face font-lock-constant-face ,@std-props) 1)
    (ivy-set-prompt-text-properties-default prompt std-props))

  (setq ivy-set-prompt-text-properties-function 'my/ivy-set-prompt-text-properties)
#+END_SRC

*** Keybindings
By default =C-r= is bound to =isearch-backward=. Since I'm using swiper, it's no longer required and is way more useful this way.
Also =C-h k= says that =C-r= is bound to =undo-tree-redo= found in =undo-tree-map= while it's really defined in =evil-normal-state-map= in evil_maps.el
#+BEGIN_SRC emacs-lisp
  (unbind-key "C-r" evil-normal-state-map)
  (bind-key* "C-r" 'ivy-resume)
#+END_SRC

#+BEGIN_SRC emacs-lisp
#+END_SRC

Create binding to show buffers, recent files and bookmarks. There is a variable =ivy-use-virtual-buffers= that does this. However, it is static and when set, dumps everything in =ivy-switch-buffer=.
As a result, by default I have to choose one or the other; I can't have both. This fixes that.
=C-c j j= will show buffers, recent files and bookmarks while =C-c j b= will only show buffers
#+BEGIN_SRC emacs-lisp
  (defun my/ivy-switch-virtual-buffer ()
    "Show recent files and bookmarks in the buffer list"
    (interactive)
    (let* ((ivy-use-virtual-buffers t))
      (ivy-switch-buffer)))

  (bind-keys :map my-jumper-command-map
             ("b" . ivy-switch-buffer)
             ("j" . my/ivy-switch-virtual-buffer))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  )
#+END_SRC

*** swiper
#+BEGIN_SRC emacs-lisp
  (use-package swiper
    :bind* (("C-s" . swiper)
            ("C-M-s" . swiper-all)))
#+END_SRC

*** counsel
NOTE: I'm deferring loading using =:commands= for those commands for which I cannot use =:bind= here
=counsel-org-tag= binding is defined only after org is loaded so I'm defining it there instead.
=counsel-org-goto= is set conditionally only if we're in org-mode

#+BEGIN_SRC emacs-lisp
  (use-package counsel
    :commands (counsel-org-tag counsel-org-goto counsel-semantic-or-imenu)
    :bind* ("C-h a" . counsel-apropos)
#+END_SRC

Use =C-c j= as prefix for all counsel-related keybindings
#+BEGIN_SRC emacs-lisp
  :init
  (bind-key "i" '(lambda() (interactive) (if (string= major-mode "org-mode")
                                        (counsel-org-goto)
                                      (counsel-semantic-or-imenu)))
            my-jumper-command-map)

  :bind (:map my-jumper-command-map
              ("/" . counsel-ag)))
#+END_SRC

NOTE: I'm deferring loading by using the =commands= keyword for =counsel-org-tag= because the binding for it,
=C-c C-q= is found in =org-mode-map= which hasn't been defined yet.

** ivy-hydra
#+BEGIN_SRC emacs-lisp
  (use-package ivy-hydra
    :after (ivy hydra)
    :config
#+END_SRC

*** Customize the default ivy-hydra
Provides some vim-ish movements and calling methods. From [[https://github.com/abo-abo/hydra/wiki/hydra-ivy-replacement][here]]
eg. To kill multiple buffers
- =C-x b= to open the buffer list
- =C-o= to open the hydra menu
- Select the 'kill' action by pressing =o k= or select it by cycling through the actions using =w= and =s=
- Once the 'kill' action has been selected, select the buffer to kill using the movement keys and press =f= to execute the action
- Pressing =f= keeps the hydra menu open to allow selecting other buffers to execute the selected action

#+BEGIN_SRC emacs-lisp
  (bind-key "\C-o"
    (defhydra soo-ivy (:hint nil :color pink)
      "
   Move     ^^^^^^^^^^ | Call        ^^^^ | Cancel^^ | Options^^ | Action _w_/_s_ _o_: %s(ivy-action-name)
  ----------^^^^^^^^^^-+-------------^^^^-+-------^^-+--------^^-+---------------------------------
   _g_ ^ ^ _k_ ^ ^ _u_ | _f_ollow occu_r_ | _i_nsert | _c_alling: %-7s(if ivy-calling \"on\" \"off\") _C_ase-fold: %-10`ivy-case-fold-search
   ^↕^ _h_ ^+^ _l_ ^↕^ | _RET_ done     ^^| _q_uit   | _m_atcher: %-7s(ivy--matcher-desc)^^^^^^^^^^^^ _t_runcate: %-11`truncate-lines
   _G_ ^ ^ _j_ ^ ^ _d_ | _TAB_ alt-done ^^| ^ ^      | _<_/_>_: shrink/grow
  "
      ;; arrows
      ("j" ivy-next-line)
      ("k" ivy-previous-line)
      ("l" ivy-alt-done)
      ("h" ivy-backward-delete-char)
      ("g" ivy-beginning-of-buffer)
      ("G" ivy-end-of-buffer)
      ("d" ivy-scroll-up-command)
      ("u" ivy-scroll-down-command)
      ("e" ivy-scroll-down-command)
      ;; actions
      ("q" keyboard-escape-quit :exit t)
      ("C-g" keyboard-escape-quit :exit t)
      ("<escape>" keyboard-escape-quit :exit t)
      ("C-o" nil)
      ("i" nil)
      ("TAB" ivy-alt-done :exit nil)
      ("C-j" ivy-alt-done :exit nil)
      ;; ("d" ivy-done :exit t)
      ("RET" ivy-done :exit t)
      ("C-m" ivy-done :exit t)
      ("f" ivy-call)
      ("c" ivy-toggle-calling)
      ("m" ivy-toggle-fuzzy)
      (">" ivy-minibuffer-grow)
      ("<" ivy-minibuffer-shrink)
      ("w" ivy-prev-action)
      ("s" ivy-next-action)
      ("o" ivy-read-action)
      ("t" (setq truncate-lines (not truncate-lines)))
      ("C" ivy-toggle-case-fold)
      ("r" ivy-occur :exit t))
    ivy-minibuffer-map)
#+END_SRC

*** /fin/
#+BEGIN_SRC emacs-lisp
  )
#+END_SRC

** modern-c++-font-lock
#+BEGIN_SRC emacs-lisp
  (use-package modern-cpp-font-lock
    :hook (c++-mode . modern-c++-font-lock-mode))
#+END_SRC

** nlinum-relative
#+BEGIN_SRC emacs-lisp
  (use-package nlinum-relative
    :hook (prog-mode . nlinum-relative-mode)
    :config
    (setq nlinum-relative-redisplay-delay 0)
    ;; Solarized colors
    (set-face-attribute 'nlinum-relative-current-face nil :inherit 'linum :background nil :foreground "#d33682" :weight 'bold))
#+END_SRC

** org
This solution is by [[https://www.reddit.com/r/emacs/comments/5sx7j0/how_do_i_get_usepackage_to_ignore_the_bundled/ddixpr9/][/u/Wolfer1ne on reddit]].
#+BEGIN_SRC emacs-lisp
  (use-package org
    :ensure org-plus-contrib
    :pin repo-org
#+END_SRC

<<ensure_target>>
Passing an argument to =:ensure= (other than t or nil) allows us to use a different package than the one named in use-package
Also, using =:pin= allows us to prefer which package-archive we'd like to use to download the package from.
I don't remember why we need to specifically grab =org-plus-contrib= from the org repository instead of from one of the other ones.

Org customization guide: http://orgmode.org/worg/org-configs/org-customization-guide.html
*** :init
#+BEGIN_SRC emacs-lisp
  :init
  (setq org-indent-mode t)

  (setq org-directory "~/Notes/")
  (setq org-default-notes-file (concat org-directory "Inbox.org"))

  (setq org-M-RET-may-split-line '((item) (default . t)))
  ;; (setq org-special-ctrl-a/e t)
  ;; (setq org-return-follows-link nil)
  (setq org-use-speed-commands nil)
  ;; (setq org-speed-commands-user nil)
  (setq org-startup-align-all-tables nil)
  (setq org-use-property-inheritance t)
  (setq org-tags-column -100)
  (setq org-hide-emphasis-markers t)  ; Hide markers for bold/italics etc.
  (setq org-blank-before-new-entry '((heading . t) (plain-list-item . nil)))
  (setq org-link-search-must-match-exact-headline nil)
  (setq org-startup-with-inline-images t)
  (setq org-imenu-depth 10)
#+END_SRC

**** org-babel source blocks
Enable syntax highlighting within the source blocks and keep the editing popup window within the same window.
Also, strip leading and trailing empty lines if any.
/org-src-preserve-indentation/ will not add an extra level of indentation to the source code
#+BEGIN_SRC emacs-lisp
  (setq org-src-fontify-natively                       t
        org-src-window-setup                           'current-window
        org-src-strip-leading-and-trailing-blank-lines t
        ;; org-src-preserve-indentation                t
        org-src-tab-acts-natively                      t)
#+end_src

Languages which can be evaluated in Org-mode buffers.
#+begin_src emacs-lisp
  (org-babel-do-load-languages 'org-babel-load-languages
                               (append org-babel-load-languages
                                       '((python     . t)
                                         (ruby       . t)
                                         (perl       . t)
                                         (dot        . t)
                                         (C          . t))))
#+end_src

Ask for confirmation before evaluating? NO!
On second thought it's better not to do this because of the security implications.
A safer way to go about it is by enabling it on a file-by-file basis using the following modeline
#+BEGIN_EXAMPLE
  -*- org-confirm-babel-evaluate: nil -*-
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp :tangle no
  (defun my/org-babel-evaluate-silent (lang body)
    "Do not ask for confirmation to evaluate these languages."
    (not (or (string= lang "emacs-lisp"))))

  (setq org-confirm-babel-evaluate 'my/org-babel-evaluate-silent)
  ;; (setq org-confirm-babel-evaluate nil)
#+END_SRC

**** Clean View
#+BEGIN_SRC emacs-lisp
  (setq org-startup-indented t)
  (setq org-hide-leading-stars t)
  (setq org-odd-level-only nil)

  ;; others: ▼, ↴, ⬎, ⤷, …, ⋱
  (setq org-ellipsis " ▼")
#+END_SRC

***** TODO Hide the < and > around targets
From [[http://emacs.stackexchange.com/a/19239/9690][Emacs StackExchange]]
At the moment, it hides not just the angle braces but also the text between them.
#+BEGIN_SRC emacs-lisp :tangle no
  (defcustom org-hidden-links-additional-re "<<[<]?[[:alnum:]]+>>[>]?"
    "Regular expression that matches strings where the invisible-property is set to org-link."
    :type '(choice (const :tag "Off" nil) regexp)
    :group 'org-link)
  (make-variable-buffer-local 'org-hidden-links-additional-re)

  (defun org-activate-hidden-links-additional (limit)
    "Put invisible-property org-link on strings matching `org-hide-links-additional-re'."
    (if org-hidden-links-additional-re
        (re-search-forward org-hidden-links-additional-re limit t)
      (goto-char limit)
      nil))

  (add-hook 'org-font-lock-set-keywords-hook (lambda ()
                                               (add-to-list 'org-font-lock-extra-keywords
                                                            '(org-activate-hidden-links-additional
                                                              (0 '(face org-target invisible org-link))))))
#+END_SRC

***** TODO Show the emphasis and target markers on point
#+BEGIN_SRC emacs-lisp :tangle no
  (defun org-show-emphasis-markers-at-point ()
    (save-match-data
      (if (and (org-in-regexp org-emph-re 2)
               (>= (point) (match-beginning 3))
               (<= (point) (match-end 4))
               (member (match-string 3) (mapcar 'car org-emphasis-alist)))
          (with-silent-modifications
            (remove-text-properties
             (match-beginning 3) (match-beginning 5)
             '(invisible org-link)))
        (apply 'font-lock-flush (list (match-beginning 3) (match-beginning 5))))))

  (add-hook 'post-command-hook 'org-show-emphasis-markers-at-point nil t)
#+END_SRC

**** ToDo States
Custom keywords
#+BEGIN_SRC emacs-lisp
  (setq org-todo-keywords '((sequence "TODO(t!)" "WAITING(w@/!)" "|" "DONE(d@)" "CANCEL(c@)")))
  ;; (setq org-todo-keyword-faces
  ;;       (quote (("TODO" :foreground "red" :weight bold)
  ;;               ("WAITING" :foreground "orange" :weight bold)
  ;;               ("DONE" :foreground "forest green" bold)
  ;;               ("CANCEL" :foreground "forest green" bold))))
#+END_SRC
=!=   - Log timestamp
=@=   - Log timestamp and note
=x/y= - =x= takes affect when entering the state and
      =y= takes affect when exiting if the state being entered doesn't have any logging
Refer [[http://orgmode.org/manual/Tracking-TODO-state-changes.html][Tracking-TODO-state-changes]] for details

Add logging when task state changes
#+BEGIN_SRC emacs-lisp
  (setq org-log-done 'time) ; 'time/'note
  (setq org-log-redeadline 'note)
  (setq org-log-into-drawer t)  ; Save state changes into LOGBOOK drawer instead of in the body
  (setq org-treat-insert-todo-heading-as-state-change t)
#+END_SRC

Change from any todo state to any other state using =C-c C-t KEY=
#+BEGIN_SRC emacs-lisp
  (setq org-use-fast-todo-selection t)
#+END_SRC

This frees up S-left and S-right which I can then use to cycles through the todo states but skip setting timestamps and entering notes which is very convenient when all I want to do is change the status of an entry without changing its timestamps
#+BEGIN_SRC emacs-lisp
  (setq org-treat-S-cursor-todo-selection-as-state-change nil)
#+END_SRC

*** :config
#+BEGIN_SRC emacs-lisp
  :config
#+END_SRC

**** Make org-mode play nicely with Google Chrome
From [[http://stackoverflow.com/a/6309985/734153][StackOverflow]]
#+BEGIN_SRC emacs-lisp
  (setq browse-url-browser-function 'browse-url-generic
        browse-url-generic-program "google-chrome")
#+END_SRC

**** Templates
#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-structure-template-alist
               '("sc" "#+BEGIN_SRC C++\n  #include <iostream>\n\n  using namespace std;\n\n  int main() {\n    ?cout << \"Hello World!\" << endl;\n  }\n#+END_SRC"))

  (add-to-list 'org-structure-template-alist
               '("sl" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC\n" "<src lang=\"?\">\n\n</src>"))

  (add-to-list 'org-structure-template-alist
               '("sp" "#+BEGIN_SRC python\n?\n#+END_SRC\n" "<src lang=\"?\">\n\n</src>"))

  ;; (add-to-list 'org-structure-template-alist
  ;;              '("sd" "#+BEGIN_SRC dot :file /tmp/out.png\n?\n#+END_SRC\n" "<src lang=\"?\">\n\n</src>"))

  (add-to-list 'org-structure-template-alist
               '("ss" "#+BEGIN_SRC bash\n?\n#+END_SRC\n" "<src lang=\"?\">\n\n</src>"))
#+END_SRC

=?= in each string controls where the point will be placed after expansion

**** Delete links
This is the counterpart to =org-insert-link=. From [[http://emacs.stackexchange.com/a/10714/9690][here]].
#+BEGIN_SRC emacs-lisp
  (defun my/org-replace-link-with-description ()
    "Replace an org link with its description. If a description doesn't exist, replace with its address"
    (interactive)
    (if (org-in-regexp org-bracket-link-regexp 1)
        (let ((remove (list (match-beginning 0) (match-end 0)))
              (description (if (match-end 3)
                               (org-match-string-no-properties 3)
                             (org-match-string-no-properties 1))))
          (apply 'delete-region remove)
          (insert description))))
#+END_SRC

**** Use ! to toggle timestamp type
:PROPERTIES:
:ID:       d4634d95-be37-4bdf-987e-22da5778e958
:END:
[[https://orgmode.org/manual/Creating-timestamps.html][By default]], org-mode uses =C-c .= and =C-c != to create active and inactive timestamps respectively.
However, I also have flycheck installed which uses the C-c ! binding.

Thus, this allows me to use =C-c .= to insert a timestamp and when prompted to enter the date+time in the minibuffer,
use =!= to toggle between active and inactive timestamps. Also see [[Custom timestamp keymap]].
From [[http://emacs.stackexchange.com/questions/38062/configure-key-to-toggle-between-active-and-inactive-timestamps#38065][Emacs StackExchange]]

#+BEGIN_SRC emacs-lisp
  (defun org-toggle-time-stamp-activity ()
    "Toggle activity of time stamp or range at point."
    (interactive)
    (let ((pt (point)))
      (when (org-at-timestamp-p t)
        (goto-char (match-beginning 0))
        (when-let ((el (org-element-timestamp-parser))
                   (type (org-element-property :type el))
                   (type-str (symbol-name type))
                   (begin (org-element-property :begin el))
                   (end (org-element-property :end el)))
          (setq type-str
                (if (string-match "inactive" type-str)
                    (replace-regexp-in-string "inactive" "active" type-str)
                  (replace-regexp-in-string "active" "inactive" type-str)))
          (org-element-put-property el :type (intern type-str))
          (goto-char end)
          (skip-syntax-backward "-")
          (delete-region begin (point))
          (insert (org-element-timestamp-interpreter el nil))
          (goto-char pt)))))

  (defvar-local calendar-previous-buffer nil
    "Buffer been active when `calendar' was called.")

  (defun calendar-save-previous-buffer (oldfun &rest args)
    "Save buffer been active at `calendar' in `calendar-previous-buffer'."
    (let ((buf (current-buffer)))
      (apply oldfun args)
      (setq calendar-previous-buffer buf)))

  (advice-add #'calendar :around #'calendar-save-previous-buffer)

  (defvar-local my-org-time-stamp-toggle nil
    "Make time inserted time stamp inactive after inserting with `my-org-time-stamp'.")

  (defun org-time-stamp-toggle ()
    "Make time stamp active at the end of `my-org-time-stamp'."
    (interactive)
    (when-let ((win (minibuffer-selected-window))
               (buf (window-buffer win)))
      (when (buffer-live-p buf)
        (with-current-buffer buf
          (when (buffer-live-p calendar-previous-buffer)
            (set-buffer calendar-previous-buffer))
          (setq my-org-time-stamp-toggle (null my-org-time-stamp-toggle))
          (setq org-read-date-inactive my-org-time-stamp-toggle)))))

  (define-key org-read-date-minibuffer-local-map "!" #'org-time-stamp-toggle)

  (defun my-org-time-stamp (arg)
    "Like `org-time-stamp' with ARG but toggle activity with character ?!."
    (interactive "P")
    (setq my-org-time-stamp-toggle nil)
    (org-time-stamp arg)
    (when my-org-time-stamp-toggle
      (backward-char)
      (org-toggle-time-stamp-activity)
      (forward-char)))

  ;; (org-defkey org-mode-map (kbd "C-c .") #'my-org-time-stamp)
#+END_SRC

**** org-babel
***** Set default options
#+BEGIN_SRC emacs-lisp
  (setq org-babel-default-header-args
        '((:results . "verbatim replace")))

  (setq org-babel-C++-compiler "clang++")
  (setq org-babel-default-header-args:C++
        '((:flags   . "-std=c++14 -Wall -Wextra -Werror ${BOOST_HOME:+-L ${BOOST_HOME}/lib -I ${BOOST_HOME}/include} -Wl,${BOOST_HOME:+-rpath ${BOOST_HOME}/lib}")))

  (setq org-babel-default-header-args:perl
        '((:results . "output")))

  (setq org-babel-python-command "python3")
#+END_SRC

***** Display errors and warnings in an org-babel code block
From [[http://emacs.stackexchange.com/questions/2952/display-errors-and-warnings-in-an-org-mode-code-block][Emacs StackExchange]]
#+BEGIN_SRC emacs-lisp :tangle no
  (defvar org-babel-eval-verbose t
    "A non-nil value makes `org-babel-eval' display")

  (defun org-babel-eval (cmd body)
    "Run CMD on BODY.
  If CMD succeeds then return its results, otherwise display
  STDERR with `org-babel-eval-error-notify'."
    (let ((err-buff (get-buffer-create " *Org-Babel Error*")) exit-code)
      (with-current-buffer err-buff (erase-buffer))
      (with-temp-buffer
        (insert body)
        (setq exit-code
              (org-babel--shell-command-on-region
               (point-min) (point-max) cmd err-buff))
        (if (or (not (numberp exit-code)) (> exit-code 0)
                (and org-babel-eval-verbose (> (buffer-size err-buff) 0))) ; new condition
            (progn
              (with-current-buffer err-buff
                (org-babel-eval-error-notify exit-code (buffer-string)))
              nil)
          (buffer-string)))))

  (setq org-babel-eval-verbose t)
#+END_SRC

**** org-bullets
Other bullets to consider:
Default: "◉ ○ ✸ ✿"
Large: ♥ ● ◇ ✚ ✜ ☯ ◆ ♠ ♣ ♦ ☢ ❀ ◆ ◖ ▶
Small: ► • ★ ▸

#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :config
    (add-hook 'org-mode-hook (lambda() (org-bullets-mode 1))))
#+END_SRC

A good way to find more characters is to use =M-x insert-char=

**** org-agenda
#+BEGIN_SRC emacs-lisp
  (use-package org-agenda
    :ensure nil
#+END_SRC

***** :init
Don't add some files to the agenda
#+BEGIN_SRC emacs-lisp
  :init
  (setq org-agenda-files
        (seq-filter (lambda (x)
                      (and 'file-exists-p
                           (not (string= "Spanish.org" x))
                           (not (string-match-p "Orgzly" x))))
                    (mapcar (lambda (x) (concat org-directory x))
                            '("Inbox.org" "Software/" "Personal/" "Work/"))))

  (setq org-agenda-tags-column            -120) ; Monitors are wide, might as well use it :/
  (setq org-agenda-skip-scheduled-if-done t)    ; Why isn't this default?
  (setq org-agenda-skip-deadline-if-done  t)
  (setq org-agenda-window-setup 'only-window)
  (setq org-agenda-restore-windows-after-quit t)
#+END_SRC

***** org-agenda custom commands
Based on https://blog.aaronbieber.com/2016/09/24/an-agenda-for-life-with-org-mode.html
#+BEGIN_SRC emacs-lisp
  (defun my/org-skip-subtree-if-habit ()
    "Skip an agenda entry if it has a STYLE property equal to \"habit\"."
    (let ((subtree-end (save-excursion (org-end-of-subtree t))))
      (if (string= (org-entry-get nil "STYLE") "habit")
          subtree-end
        nil)))

  (defun my/org-skip-subtree-if-priority (priority)
    "Skip an agenda subtree if it has a priority of PRIORITY.

  PRIORITY may be one of the characters ?A, ?B, or ?C."
    (let ((subtree-end (save-excursion (org-end-of-subtree t)))
          (pri-value (* 1000 (- org-lowest-priority priority)))
          (pri-current (org-get-priority (thing-at-point 'line t))))
      (if (= pri-value pri-current)
          subtree-end
        nil)))

  (setq org-agenda-custom-commands
        '(("d" "Daily agenda and all TODOs"
           ((tags "PRIORITY=\"A\""
                  ((org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
                   (org-agenda-overriding-header "High-priority unfinished tasks:")))
            (agenda "" ((org-agenda-span 14)))
            (alltodo ""
                     ((org-agenda-skip-function '(or (my/org-skip-subtree-if-habit)
                                                     (my/org-skip-subtree-if-priority ?A)
                                                     (org-agenda-skip-if nil '(scheduled deadline))))
                      (org-agenda-overriding-header "ALL normal priority tasks:"))))
           ((org-agenda-compact-blocks t)))

          ("w" "Daily agenda and all TODOs for Work"
           ((tags "PRIORITY=\"A\""
                  ((org-agenda-tag-filter-preset '("+Work"))
                   (org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
                   (org-agenda-overriding-header "High-priority unfinished tasks:")))
            (agenda "" ((org-agenda-span 14)))
            (alltodo ""
                     ((org-agenda-tag-filter-preset '("+Work"))
                      (org-agenda-skip-function '(or (my/org-skip-subtree-if-habit)
                                                     (my/org-skip-subtree-if-priority ?A)
                                                     (org-agenda-skip-if nil '(scheduled deadline))))
                      (org-agenda-overriding-header "ALL normal priority tasks:"))))
           ((org-agenda-compact-blocks t)))))
#+END_SRC

***** Keybindings
[[id:ebbf9970-d072-4b59-bcaa-5f4b3d71a7d7][General org keybindings]]

#+BEGIN_SRC emacs-lisp
  :config
#+END_SRC

Use j/k in org-agenda
#+BEGIN_SRC emacs-lisp :tangle no
  (bind-keys :map org-agenda-mode-map
             ("j" . org-agenda-next-item)       ;; Bound to 'goto-date' by default
             ("k" . org-agenda-previous-item))  ;; Bound to 'org-capture' by default
#+END_SRC

Open the custom "Daily agenda and all TODOs" directly. Based on [[http://emacs.stackexchange.com/a/868/9690][Emacs StackExchange]].
#+BEGIN_SRC emacs-lisp
  (bind-key* "<f12>" '(lambda (&optional arg) (interactive "P")(org-agenda arg "w")))
#+END_SRC

***** /fin/
#+BEGIN_SRC emacs-lisp
  )
#+END_SRC

**** org-refile
By [[https://www.reddit.com/r/emacs/comments/4366f9/how_do_orgrefiletargets_work/czg008y/][/u/awalker4 on reddit]].
Show upto 3 levels of headings from the current file and two levels of headings from all agenda files
#+BEGIN_SRC emacs-lisp
  (setq org-refile-targets
        '((nil . (:maxlevel . 3))
          (org-agenda-files . (:maxlevel . 2))))
#+END_SRC
Each element of the list generates a set of possible targets.
/nil/ indicates that all the headings in the current buffer will be considered.

Following are from Aaron Bieber's post [[https://blog.aaronbieber.com/2017/03/19/organizing-notes-with-refile.html][Organizing Notes with Refile]]

Creating new parents - To create new heading, add =/HeadingName= to the end when using refile (=C-c C-w=)
#+BEGIN_SRC emacs-lisp
  (setq org-refile-allow-creating-parent-nodes 'confirm)
  (setq org-refile-use-outline-path 'file)
  (setq org-outline-path-complete-in-steps nil)
#+END_SRC

***** TODO Set org-refile targets based on current file
Why would I want to refile something work-related under Softwares etc.
A way to do it is by writing a function that sets /org-refile-targets/ in a let binding making it local.
eg. implementation by abo-abo: [[https://github.com/abo-abo/worf/blob/master/worf.el][worf-refile-other]]

#+BEGIN_SRC emacs-lisp :tangle no
  (load-library "find-lisp")

  (defun my/org-refile-targets ()
    "Refile the current heading to another heading.
  The other heading can be in the current file or in a file that resides
  anywhere below the directory the current file resides in.

  The intent is to move to a similar file. If I'm in work-related file,
  I almost never have to refile something to a personal file."
    (interactive "p")
    (let* ((org-refile-targets '((nil . (:maxlevel . 9)))))
      (org-refile)))

  (bind-key* "C-c C-w" 'my/org-refile-targets)
#+END_SRC

***** TODO Rice org-refile
eg. https://emacs-china.org/t/topic/3622

**** org-capture
Show hierarchical headlines when refiling instead of flattening it out
Show all the hierarchical headlines instead of having to step down them

From [[http://cestlaz.github.io/posts/using-emacs-23-capture-1][Using Emacs 23 - Capture 1]] and [[http://cestlaz.github.io/posts/using-emacs-24-capture-2][Using Emacs 24 - Capture 2]]
#+BEGIN_SRC emacs-lisp
  (setq org-capture-templates
        '(("t" "TODO" entry
           (file+headline org-default-notes-file "Inbox")
           "* TODO %?"
           :jump-to-captured t :empty-lines 1)

          ("c" "Misc" entry
           (file+headline org-default-notes-file "Inbox")
           "* %?%(org-set-property \"CAPTURED\" \"%U\")"
           :jump-to-captured t :empty-lines 1)

          ("s"  "Code snippets")

          ("se" "Emacs snippets" entry (file "Software/emacs.org")
           "* %?%(org-set-property \"CAPTURED\" \"%U\")"
           :jump-to-captured t :empty-lines 1)

          ("ss" "Shell snippets" entry (file "Software/shell.org")
           "* %?%(org-set-property \"CAPTURED\" \"%U\")"
           :jump-to-captured t :empty-lines 1)

          ("sv" "Vim snippets" entry (file "Software/vim.org")
           "* %?%(org-set-property \"CAPTURED\" \"%U\")"
           :jump-to-captured t :empty-lines 1)))
#+END_SRC

NOTE:
- When using several keys, keys using the same prefix key must be sequential in the list and preceded by a 2-element entry explaining the prefix key.
  [[http://orgmode.org/manual/Template-elements.html#Template-elements][Template elements]], [[http://orgmode.org/manual/Template-elements.html#Template-expansion][Template expansion]]
- Quick-note related to current state can be taken using =C-c C-z= and get added to the =LOGBOOK=

***** Capture template for learning Spanish
#+BEGIN_SRC emacs-lisp :tangle no
  (add-to-list 'org-capture-templates '(("l"  "Spanish")

                                        ("ls" "Item" entry
                                         (file+headline "Personal/Spanish.org" "Misc")
                                         "\n* %?%(setq my-spanish-capture (read-string \"Spanish: \")) :drill:%(org-set-property \"DRILL_CARD_TYPE\" \"hide1_firstmore\")\n\nSpanish: [%(message my-spanish-capture)]\nEnglish: [%^{English}]"
                                         :jump-to-captured t :empty-lines 1)

                                        ("ln" "Noun" entry
                                         (file+headline "Personal/Spanish.org" "Nouns")
                                         "\n* %?[%(setq my-spanish-capture (read-string \"Spanish: \"))] :drill:%(org-set-property \"DRILL_CARD_TYPE\" \"twosided\")\n\nTranslate this noun.\n\n** Spanish\n/%(message my-spanish-capture)/\n\n** English\n%^{English}"
                                         :jump-to-captured t :empty-lines 1)

                                        ("lv" "Verb" entry
                                         (file+headline "Personal/Spanish.org" "Verbs")
                                         "\n* %(setq my-spanish-capture (read-string \"Spanish: \")) :drill:%(org-set-property \"DRILL_CARD_TYPE\" \"hide1cloze\")%(org-set-property \"VERB_INFINITIVE\" (concat \"\\\"\" my-spanish-capture \"\\\"\"))%(org-set-property \"VERB_TRANSLATION\" (concat \"\\\"to \" (setq my-english-capture (read-from-minibuffer \"English: to \")) \"\\\"\"))%(org-set-property \"VERB_INFINITIVE_HINT\" (concat \"\\\"\" (substring my-spanish-capture 0 1) \"...\\\"\"))\n\nSpanish: [%(message my-spanish-capture)]\nEnglish: [to %(message my-english-capture)]\n\n** Notes\n** Examples\n** Simple Present Tense :drill:%(org-set-property \"DRILL_CARD_TYPE\" \"conjugate\")%(org-set-property \"VERB_TENSE\" \"\\\"simple present\\\"\")\n\n| yo               | %?  |\n| tú               |   |\n| él/ella/Ud.      |   |\n| nosotros         |   |\n| vosotros         |   |\n| ellos/ellas/Uds. |   |"
                                         :jump-to-captured t :empty-lines 1))
               t)
#+END_SRC

****** TODO Using %^{prompt} in org-capture template doesn't allow specifying accented characters with =C-x 8=
Hence, I'm using a hacky way of explicitly prompting for input (since I can specify accented characters that way),
saving it to a variable and printing it out later in the capture template.

***** TODO Creating TODOs doesn't log it as a state change
***** Create frames for easy org-capture directly from the OS
(credit: [[http://cestlaz.github.io/posts/using-emacs-24-capture-2/][here]])
#+BEGIN_SRC emacs-lisp
  (use-package noflet)

  (defun my/make-capture-frame ()
    "Create a new frame and run org-capture."
    (interactive)
    (make-frame '((name . "capture")))
    (select-frame-by-name "capture")
    (delete-other-windows)
    (noflet ((switch-to-buffer-other-window (buf) (switch-to-buffer buf)))
      (counsel-org-capture)))

  (defadvice org-capture-finalize
      (after delete-capture-frame activate)
    "Advise capture-finalize to close the frame"
    (if (equal "capture" (frame-parameter nil 'name))
        (delete-frame)))

  (defadvice org-capture-destroy
      (after delete-capture-frame activate)
    "Advise capture-destroy to close the frame"
    (if (equal "capture" (frame-parameter nil 'name))
        (delete-frame)))
#+END_SRC

**** org-id
I grab the /org-plus-contrib/ version of org-id to match org. Also look at [[ensure_target]].
#+BEGIN_SRC emacs-lisp
  (use-package org-id
    :ensure org-plus-contrib
    :pin repo-org
    :init
    (setq org-id-link-to-org-use-id 'create-if-interactive-and-no-custom-id)

    :config
#+END_SRC

To effectively use custom ID, refer [[https://writequit.org/articles/emacs-org-mode-generate-ids.html#update-2016-09-07][this]].
Note that =org-id= has been updated since then and now supports a method =org-id-get-create= which creates an ID if one is not present.
Also, it uses the identifier /ID/ instead of /CUSTOM_ID/

***** TODO Use org-id globally across all files
Example on [[http://stackoverflow.com/a/27158715/734153][Emacs StackExchange]]
#+BEGIN_SRC emacs-lisp
  (setq org-id-track-globally t)
  (setq org-id-extra-files '("~/.emacs.d/config.org"))
#+END_SRC

***** Completion while inserting link
:PROPERTIES:
:ID:       be086bdd-ffcf-4f4e-beb2-a948191895eb
:END:
To use completion, insert link using =C-c C-l= and select =id:= as type and completion should trigger.
=org-id-get-with-outline-path-completion= returns the ID of the selected heading and creates it if it doesn't have one already.
Details at [[http://emacs.stackexchange.com/a/12434/9690][Emacs StackExchange]]
#+BEGIN_SRC emacs-lisp
  (defun org-id-complete-link (&optional arg)
    "Create an id: link using completion"
    (concat "id:" (org-id-get-with-outline-path-completion)))

  (eval-after-load 'org '(org-link-set-parameters "id" :complete 'org-id-complete-link))
#+END_SRC

***** /fin/
#+BEGIN_SRC emacs-lisp
  )
#+END_SRC

**** org-drill
I grab the /org-plus-contrib/ version of org-id to match org. Also look at [[ensure_target]].
#+BEGIN_SRC emacs-lisp
  (use-package org-drill
    :disabled
    :ensure org-plus-contrib
    :init
    (setq org-drill-learn-fraction 0.4)
    :config
    (add-to-list 'org-modules 'org-drill)
    (setq org-drill-add-random-noise-to-intervals-p t)
    (setq org-drill-hide-item-headings-p t)

    (use-package org-drill-table
      :disabled
      :load-path "bundle/org-drill-table"))
#+END_SRC

**** htmlize
Syntax highlighting when exporting to HTML? Yes, please!
#+BEGIN_SRC emacs-lisp
  (use-package htmlize
    :disabled)
#+END_SRC

*** Keybindings
:PROPERTIES:
:ID:       ebbf9970-d072-4b59-bcaa-5f4b3d71a7d7
:END:
Custom keymap for org-mode bindings.
#+BEGIN_SRC emacs-lisp
  (bind-keys :map my-leader-map
             :prefix-map my-org-bindings-map
             :prefix-docstring "This map is used to group together all org-mode settings"
             :prefix "o"
             ("a" . org-agenda)
             ("c" . counsel-org-capture))
  ;; :bind (("c" . calendar))
#+END_SRC

<<Custom timestamp keymap>>. Also see [[id:d4634d95-be37-4bdf-987e-22da5778e958][Using ! to toggle timestamp type]]
#+BEGIN_SRC emacs-lisp
  (bind-keys :map my-leader-map
             :prefix-map my-org-timestamp-bindings-map
             :prefix-docstring "This map is used to group together all timestamp related bindings"
             :prefix "."
             ("." . my-org-time-stamp)
             ("!" . org-time-stamp-inactive)
             ("<" . org-date-from-calendar)
             (">" . org-goto-calendar)
             ("C-o" . org-open-at-point))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (bind-key "C-c C-q" 'counsel-org-tag org-mode-map)
#+END_SRC

Note that org-mode usually has the same command mapped to both =<Prefix> [a-z]= and =<Prefix> C-[a-z]=.
In such cases, I can use =<Prefix> [a-z]= to bind to something else and leave =<Prefix> C-[a-z]= alone.
The mnemonic is that Org leaves =C-c [a-z]= free for the user. Thus, I'm using =[a-z]= in other places too.

Delete the result block using =C-c C-v C-k= where =C-c C-v= is the /org-babel-key-prefix/
#+BEGIN_SRC emacs-lisp
  (bind-key "C-k" 'org-babel-remove-result org-babel-map)
#+END_SRC

*** /fin/
#+BEGIN_SRC emacs-lisp
  )
#+END_SRC

** pcre2el
From [[https://www.reddit.com/r/emacs/comments/60nb8b/favorite_builtin_emacs_commands/df8h8hm/][/u/Irkry on reddit]]
#+BEGIN_SRC emacs-lisp
  (use-package pcre2el
    :config
    (pcre-mode t))
#+END_SRC

** popup-kill-ring
Use =M-y= to show a list of all killed/yanked text to paste at the cursor location
#+BEGIN_SRC emacs-lisp
  (use-package popup-kill-ring
    :bind ("M-y" . popup-kill-ring))
#+END_SRC

** rainbow-delimiters
Use brighter colors
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :config
    (progn
      (set-face-attribute 'rainbow-delimiters-depth-1-face nil :foreground "dark orange")
      (set-face-attribute 'rainbow-delimiters-depth-2-face nil :foreground "deep pink")
      (set-face-attribute 'rainbow-delimiters-depth-3-face nil :foreground "chartreuse")
      (set-face-attribute 'rainbow-delimiters-depth-4-face nil :foreground "deep sky blue")
      (set-face-attribute 'rainbow-delimiters-depth-5-face nil :foreground "yellow")
      (set-face-attribute 'rainbow-delimiters-depth-6-face nil :foreground "orchid")
      (set-face-attribute 'rainbow-delimiters-depth-7-face nil :foreground "spring green")
      (set-face-attribute 'rainbow-delimiters-depth-8-face nil :foreground "sienna1"))

    :bind (:map my-unimpaired-toggle-map
                ("r" . rainbow-delimiters-mode)))
#+END_SRC

** rainbow-mode
When a color is specified as a hex code or with its name, set the background of the face to the value of the color itself
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-mode
    :defer t)
#+END_SRC

Provides command =rainbow-mode= to toggle this

** undo-tree
This lets us visually walk through the changes we've made, undo back to a certain point (or redo), and go down different branches.
Default binding is =C-x u=
#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :bind (:map my-unimpaired-enable-map
                ("U" . undo-tree-visualize)
           :map my-unimpaired-disable-map
                ("U" . undo-tree-visualizer-quit))
    :config
    (setq undo-tree-visualizer-timestamps t)
    (setq undo-tree-visualizer-diff t))
#+END_SRC

*** TODO Defer loading

** verilog-mode
#+BEGIN_SRC emacs-lisp
  (use-package verilog-mode
    :load-path "bundle/verilog-mode"
    :mode (("\\.v\\'"    . verilog-mode)
           ("\\.svh?\\'" . verilog-mode)
           ("\\.x\\'"    . verilog-mode))
    :config
    (font-lock-mode 1))
#+END_SRC

** which-key
Shows which keys can be pressed next. Eg. if you press =C-x= and wait a few seconds, a window pops up with all the key bindings following the currently entered incomplete command.
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :config  (which-key-mode))
#+END_SRC

** Themes
Useful commands:
=list-faces-display= - List all faces with colors and sample text
=list-colors-display= - List all colors with their names

*** load-theme hook
Emacs doesn't have a native hook that is called after a theme has loaded. So we've to create one. (from [[https://www.reddit.com/r/emacs/comments/4v7tcj/does_emacs_have_a_hook_for_when_the_theme_changes/d5wyu1r/][reddit]])
#+BEGIN_SRC emacs-lisp
  (defvar after-load-theme-hook nil
    "Hook run after a color theme is loaded using `load-theme'.")
  (defadvice load-theme (after run-after-load-theme-hook activate)
    "Run `after-load-theme-hook'."
    (run-hooks 'after-load-theme-hook))
#+END_SRC

eg.
#+BEGIN_SRC emacs-lisp :tangle no
  (add-hook 'after-load-theme-hook (lambda() (message "Theme loaded")))
#+END_SRC

*** leuven
[[https://github.com/fniessen/emacs-leuven-theme][Github Link]]
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package leuven-theme
    :config
    (load-theme 'leuven t)

    (setq evil-normal-state-cursor   '("#008000" box)
          evil-visual-state-cursor   '("#006FE0" box)
          evil-insert-state-cursor   '("#0000FF" bar)
          evil-replace-state-cursor  '("#D0372D" bar)
          evil-operator-state-cursor '("#D0372D" hollow))

    (set-face-attribute 'org-agenda-date         nil :height 1.4)
    (set-face-attribute 'org-agenda-date-today   nil :height 1.4)
    (set-face-attribute 'org-agenda-date-weekend nil :height 1.4)
    (set-face-attribute 'trailing-whitespace     nil :background "#DDDDFF"))
#+END_SRC

Load theme first and then override the colors

*** solarized
https://github.com/bbatsov/solarized-emacs
#+BEGIN_SRC emacs-lisp
  (use-package solarized-theme
    ;; :disabled
    :init
    (setq solarized-distinct-fringe-background nil)
    :config
    (load-theme 'solarized-light t)

    (setq evil-normal-state-cursor   '("#859900" box)
          evil-visual-state-cursor   '("#b58900" box)
          evil-insert-state-cursor   '("#268bd2" bar)
          evil-replace-state-cursor  '("#dc322f" bar)
          evil-operator-state-cursor '("#dc322f" hollow)
          evil-emacs-state-cursor    '("#839496" bar)))
#+END_SRC

*** base16
#+BEGIN_SRC emacs-lisp
  (use-package base16-theme
    :config
    ;; (load-theme 'base16-tomorrow-night t)
    (setq evil-normal-state-cursor   '("#719e07" box)
          evil-visual-state-cursor   '("#b58900" box)
          evil-insert-state-cursor   '("#268bd2" bar)
          evil-replace-state-cursor  '("#dc322f" bar)
          evil-operator-state-cursor '("#dc322f" hollow)
          evil-emacs-state-cursor    '("#839496" bar)))
#+END_SRC

** delight
Placing at end to be called after all packages are loaded
#+BEGIN_SRC emacs-lisp
  (use-package delight
    :config
    (delight '((abbrev-mode nil t)
               (aggressive-indent-mode nil aggressive-indent)
               (beacon-mode nil beacon)
               (company-mode nil company)
               (flycheck-mode nil flycheck)
               (irony-mode nil irony)
               (ivy-mode nil ivy)
               (org-indent-mode nil org-indent)
               (pcre-mode nil pcre2el)
               (rainbow-mode)
               (undo-tree-mode nil undo-tree)
               (visual-line-mode nil t)
               (yas-minor-mode nil yasnippet)
               (which-key-mode nil which-key))))
#+END_SRC

* ProgLangEmacs
:PROPERTIES:
:header-args: :tangle no
:END:
** sml-mode
#+BEGIN_SRC emacs-lisp
  (use-package sml-mode
    :if (eq system-type 'gnu/linux)
    :config
    (add-to-list 'org-structure-template-alist
                 '("sml" "#+BEGIN_SRC sml\n?\n#+END_SRC\n" "<src lang=\"?\">\n\n</src>")

    (use-package flycheck-sml
      :ensure nil
      :disabled
      :load-path "bundle/flycheck-sml/"))
#+END_SRC

*** TODO Restart the SML REPL
#+BEGIN_SRC emacs-lisp :tangle no
  (defun my/restart-sml-repl ()
    "Restarts the SML REPL"
    (interactive)
    (progn
      (when (get-buffer-process (current-buffer))
        (goto-char (point-max)) ; First go to the end of the buffer
        (comint-delchar-or-maybe-eof 1); Then kill the REPL (C-d)
        (sleep-for 0.1)) ; This is needed for some reason
      (sml-run "sml" nil)))

  (bind-key* "C-c C-s" 'my/restart-sml-repl)
#+END_SRC

*** Restart SML REPL and load the correct file
#+BEGIN_SRC emacs-lisp
  (defun my/restart-sml-and-run ()
    "Restarts the SML REPL and tries to load the correct .sml file.

  The sml file loaded is the one at the top of the list returned by
  `buffer-list'.

  If this command is executed while in an sml buffer, the point is returned back
  to that buffer after restarting the REPL and loading that file."
    (interactive)
    (let* ((in-sml-buf (derived-mode-p 'sml-mode))
           (repl-buf (get-buffer "*sml*"))
           (sml-file (if in-sml-buf
                         (buffer-file-name)
                       (catch 'break
                         (dolist (buf (buffer-list))
                           (let ((file (buffer-file-name buf)))
                             (when (and (stringp file)
                                        (string-match-p ".*\\.sml\\'" file))
                               ;; Return the first .sml file name from the list
                               ;; and end the loop.
                               (throw 'break file)))))))
           (msg "Restarted SML"))
      (when repl-buf
        (when in-sml-buf
          ;; If the REPL buffer already exists and you are not in it, switch
          ;; to it.
          (switch-to-buffer-other-window repl-buf))
        ;; If the REPL has a live process, kill it
        (when (get-buffer-process (current-buffer))
          (goto-char (point-max)) ; First go to the EOB
          (comint-delchar-or-maybe-eof 1) ; Then kill the REPL (C-d)
          (sleep-for 0.1))) ; Somehow this is needed between kill and respawn
      (if sml-file
          (setq msg (concat msg (format " and now loading `%s'"
                                        (file-name-nondirectory sml-file))))
        ;; If no sml file was found in the buffer list
        (setq sml-file ""))
      (setq msg (concat msg "."))
      (message msg)
      ;; Then start a new process
      (sml-run "sml" sml-file) ; C-c C-s + typing "use foo.sml" in REPL
      ;; Switch back to the sml buffer if you executed this command from there
      (when in-sml-buf
        (switch-to-buffer-other-window (get-file-buffer sml-file)))))

  (bind-key "C-c <C-return>" #'my/restart-sml-and-run inferior-sml-mode-map)
  (bind-key "C-c <C-return>" #'my/restart-sml-and-run sml-mode-map)
#+END_SRC

*** ob-sml
#+BEGIN_SRC emacs-lisp
  (use-package ob-sml
    :config
    (add-to-list 'org-babel-load-languages '(sml . t))
    (org-babel-do-load-languages 'org-babel-load-languages org-babel-load-languages)
#+END_SRC

**** TODO Launch sml-repl if not running when evaluating a code-block
*** /fin/
#+BEGIN_SRC emacs-lisp
  ))
#+END_SRC

* After
** Private config
#+BEGIN_SRC emacs-lisp
  (when (string-match-p "atlhen" (system-name))
    (load (concat user-emacs-directory "private_work.el") t))
#+END_SRC

** File-local variables
# Local Variables:
# org-confirm-babel-evaluate: nil
# End:

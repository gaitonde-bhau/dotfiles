#+TITLE: Emacs Configuration
#+PROPERTY: header-args+ :results output silent
#+PROPERTY: header-args+ :comments both :mkdirp yes
#+TODO: FIXME(!) | DONE

* Resources
:PROPERTIES:
:CREATED:  [2019-01-15 Tue 07:17]
:END:
** Useful literate config files
:PROPERTIES:
:ID:       b2032342-6c4c-48be-b370-6ae538a48e2c
:CREATED:  [2019-01-15 Tue 05:25]
:END:
https://github.com/caisah/emacs.dz
[[http://wolfecub.github.io/dotfiles/][Wolfe's Literate Emacs Config]]
[[https://huytd.github.io/emacs-from-scratch.html][Emacs from scratch]]
[[https://github.com/angrybacon/dotemacs/blob/master/dotemacs.org][AngryBacon]]
[[https://to1ne.gitlab.io/literate-dotfiles/][Toon's Literate Dotfiles]]
https://brainlessdeveloper.com/2017/12/27/making-emacs-work-like-my-vim-setup/

Check if there's a way to keep all the config in this file itself with init.el being empty
Sacha Chua seems to have something like that. Her init.el is simply a link.
Maybe some information in this [[https://www.reddit.com/r/emacs/comments/4uo9r0/shaving_time_on_emacs_startup_from_org_literate/][reddit thread]]?

** Debugging
:PROPERTIES:
:ID:       4e219760-3d5e-4a51-9837-8f24298b44d9
:CREATED:  [2019-01-15 Tue 05:25]
:END:
Use =C-u C-M-x= with the point over the function to debug. This puts us into debugging minor mode in which the following bindings are useful

| SPC | Step next      |
| b   | Set breakpoint |
| g   | Go (run)       |
| h   | Goto here      |
| i   | Step into      |
| q   | Quit           |

* General
** custom file
#+BEGIN_SRC emacs-lisp
  (setq-default custom-file (expand-file-name "custom.el" user-emacs-directory))
  (load custom-file t)
#+END_SRC

** Keybindings
#+BEGIN_SRC emacs-lisp
  (bind-keys* :prefix-map my-fuzzy-jumper-command-map
              :prefix-docstring "This map is used to put all keybindings that I use to jump around eg. open files, buffers etc."
              :prefix "C-c f")

  (bind-keys* :prefix-map my-auto-completion-map
              :prefix-docstring "This map is used to put all auto-completion related keybindings"
              :prefix "C-c c")

  (bind-keys* :prefix-map my-goto-map
              :prefix-docstring "This map is used to put all movement related keybindings"
              :prefix "C-c g")

  (bind-keys* :prefix-map my-s-bindings-map
              :prefix-docstring "This map is used to group together all s-mnemonic bindings such as substitution, sizing etc."
              :prefix "C-c s")
#+END_SRC

I think the following would be handy
  =[= - Enable setting
  =t= - Toggle setting
  =]= - Disable setting
Original use of =C-c [= and =C-c ]= is to manipulate =org-agenda-files=. Since I don't use either of these, might as well put them to better use.

#+BEGIN_SRC emacs-lisp
  (bind-keys* :prefix-map my-settings-enable-map
              :prefix-docstring "This map is used to enable settings ala vim-unimpaired"
              :prefix "C-c [")

  (bind-keys* :prefix-map my-settings-disable-map
              :prefix-docstring "This map is used to disable settings ala vim-unimpaired"
              :prefix "C-c ]")

  (bind-keys* :prefix-map my-settings-toggle-map
              :prefix-docstring "This map is used to toggle settings"
              :prefix "C-c t")
#+END_SRC

To delete existing bindings, use =(unbind-key ...)=

#+BEGIN_SRC emacs-lisp
  (bind-key* "C-h B" 'describe-personal-keybindings)
#+END_SRC

By default C-x = is bound to /what-cursor-position/ but evil maps both =ga= and =g8= to that as well so might as well use it to show something useful.
#+BEGIN_SRC emacs-lisp
  (bind-key* "C-x =" 'describe-char)
#+end_src

=key-translation-map= can be used to /map/ one set of keys to another [[Make Escape quit everything][eg.]]

*** revert-buffer
#+begin_src emacs-lisp
  (defun my-revert-buffer-no-confirm ()
    "Revert buffer without confirmation."
    (interactive)
    (revert-buffer :ignore-auto :noconfirm))

  (bind-key* "<f5>" 'my-revert-buffer-no-confirm)
#+END_SRC

*** describe-keymap
[[https://stackoverflow.com/a/36994486/734153][From StackOverflow]]
#+BEGIN_SRC emacs-lisp
  (defun my-describe-keymap (keymap)
    "Describe a keymap using `substitute-command-keys'."
    (interactive
     (list (completing-read
            "Keymap: " (let (maps)
                         (mapatoms (lambda (sym)
                                     (and (boundp sym)
                                          (keymapp (symbol-value sym))
                                          (push sym maps))))
                         maps)
            nil t)))
    (with-output-to-temp-buffer (format "*keymap: %s*" keymap)
      (princ (format "%s\n\n" keymap))
      (princ (substitute-command-keys (format "\\{%s}" keymap)))
      (with-current-buffer standard-output ;; temp buffer
        (setq help-xref-stack-item (list #'my-describe-keymap keymap)))))

  (bind-key "K" 'my-describe-keymap help-map)
#+END_SRC

eg. =(my-describe-keymap 'evil-window-map)=

** Autosave, Backup and History
Change default location of backups to avoid littering PWD
#+BEGIN_SRC emacs-lisp
  (defvar backup-directory (concat user-emacs-directory "/tmp/backups"))
  (if (not (file-exists-p backup-directory)) (make-directory backup-directory t))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (setq backup-directory-alist `(("." . ,backup-directory)))
  (setq make-backup-files         t)  ; backup of a file the first time it is saved.
  (setq backup-by-copying         t)  ; don't clobber symlinks
  (setq version-control           t)  ; version numbers for backup files
  (setq delete-old-versions       t)  ; delete excess backup files silently
  (setq delete-by-moving-to-trash t)
  (setq kept-old-versions         6)  ; oldest versions to keep when a new numbered backup is made (default: 2)
  (setq kept-new-versions         9)  ; newest versions to keep when a new numbered backup is made (default: 2)
#+END_SRC

Change default location of autosaves to avoid littering PWD
#+BEGIN_SRC emacs-lisp
  (defvar autosave-directory (concat user-emacs-directory "tmp/autosaves/"))
  (if (not (file-exists-p autosave-directory)) (make-directory autosave-directory t))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  ;; (setq auto-save-file-name-transforms `(("." ,autosave-directory t)))
  (setq auto-save-default t)  ; auto-save every buffer that visits a file
#+END_SRC

Delete identical history entries
#+BEGIN_SRC emacs-lisp
(setq history-delete-duplicates t)
#+END_SRC

Save mini-buffer history
#+BEGIN_SRC emacs-lisp
  (use-package savehist
    :init
    (setq savehist-file (concat user-emacs-directory "tmp/history.el")
          history-length 100)
    :config
    (savehist-mode t))
#+END_SRC

** QoL changes
*** Remove visual clutter
#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-message t)
  (setq initial-scratch-message "")

  (menu-bar-mode 0)
  (tool-bar-mode 0)
  (scroll-bar-mode 0)
#+END_SRC

We can also put something like this into =~/.Xresources= to enable/disable certain things as soon as Emacs starts
#+BEGIN_EXAMPLE
  Emacs.verticalScrollBars: off
  Emacs.toolBar: off
#+END_EXAMPLE

*** Better defaults
#+BEGIN_SRC emacs-lisp
  (setq-default
   mouse-wheel-follow-mouse t          ; Mouse-wheel acts on the hovered window instead of where the typing focus is
   echo-keystrokes 0.1                 ; Let emacs react faster to keystrokes
   confirm-kill-emacs 'y-or-n-p        ; Confirm before quitting
   ring-bell-function 'ignore          ; Disable anoying beep
   redisplay-dont-pause t              ; Improve rendering performance
   indicate-empty-lines t              ; Display a special glyph in the fringe of each empty line at the end of the buffer
   help-window-select t                ; Jump to the help window when it's opened.
   right-margin-width 1
   uniquify-buffer-name-style 'forward ; Better unique buffer names
   window-combination-resize t         ; Resize windows proportionally
   x-stretch-cursor t)                 ; Stretch cursor to the glyph width

  (column-number-mode t)               ; Show column no. in mode-line
  (global-visual-line-mode t)          ; Enable editing by visual lines
  (fset 'yes-or-no-p 'y-or-n-p)        ; Simpler y/n answers
#+END_SRC

*** Winner mode - Undo/redo window layouts
Undo and Redo changes in window configuration. Use =C-c right=, =C-c left= (default bindings) to switch between different layouts.
This is useful when I close a window by mistake to undo it and restore the window layout.
#+BEGIN_SRC emacs-lisp
  (winner-mode 1)
#+END_SRC

[[id:f42c3dc8-c2f6-4f22-9f47-0c578479ef67][More intuitive keybindings]] defined after evil is loaded

** Diff
From [[http://pragmaticemacs.com/emacs/visualise-and-copy-differences-between-files/][Pragmatic Emacs]]
#+BEGIN_SRC emacs-lisp
  (use-package ediff
    :config
    (setq ediff-window-setup-function 'ediff-setup-windows-plain  ; Don't start another frame
          ediff-split-window-function 'split-window-horizontally) ; Put windows side by side
    (add-hook 'ediff-after-quit-hook-internal 'winner-undo)) ; Revert windows on exit (needs winner mode)
#+END_SRC

** Emacs server
A daemon can be started from the shell
#+BEGIN_SRC bash
  emacs --daemon=SERVERNAME
#+END_SRC

or from within emacs:
#+BEGIN_SRC emacs-lisp :tangle no
  (setq server-name "SERVERNAME")
  (server-start)
#+END_SRC
The downside of this is that this seems to restart the server instead of creating multiple instances

Once a daemon is started, a client can be started with
#+BEGIN_SRC bash
  emacsclient --alternate-editor="" --create-frame --quiet --socket-name=SERVERNAME
#+END_SRC
This will launch emacsclient if a daemon is already running and create one if not.
Note that alternate-editor has been left blank. This forces it to create a daemon.

To check whether a server is running, we can use
#+BEGIN_SRC emacs-lisp :tangle no
  (server-running-p "SERVERNAME")
#+END_SRC
A complete list of all running servers can be found under /tmp/emacs$UID but it's [[http://emacshorrors.com/posts/determining-if-the-server-is-started-or-the-wonders-of-server-running-p.html][a little more complicated]] than that.

So, let's just start a server if one isn't running. A downside of this is that it won't persist once emacs is killed
#+BEGIN_SRC emacs-lisp
  (use-package server
    :ensure nil
    :defer 5
    :config
    (unless (server-running-p server-name)
      (server-start)))
#+END_SRC

** Fonts
:PROPERTIES:
:ID:       bd542328-7d1d-4806-936d-a50673beada6
:END:
Scale font size using =C-x C-+= and =C-x C--=. =C-x C-0= resets it.
=text-scale-mode-step= controls the scaling factor. For obvious reasons, don't set it to 1 else it won't change at all
#+BEGIN_SRC emacs-lisp
  (setq-default text-scale-mode-step 1.1
                line-spacing 1)
#+END_SRC

After installing a new font refresh the font cache by running
#+BEGIN_SRC bash
  fc-cache -fv
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun my-set-font-if-exists (type font)
    "Check if FONT exists and set TYPE if it does."
    (when (and (display-graphic-p)(x-list-fonts font))
      (set-face-attribute type nil :font font)
      t))  ; This is required so that we can use this function in a cond block below

  (defun my-set-fonts()
    (my-set-font-if-exists 'default "Iosevka SS05-9")
    (my-set-font-if-exists 'fixed-pitch "Fira Code Medium-9")
    (my-set-font-if-exists 'variable-pitch "Iosevka SS05-9")
    ;; (cond ((eq system-type 'gnu/linux) (my-set-font-if-exists 'variable-pitch "Ubuntu Condensed-9"))
    ;;       ((eq system-type 'windows-nt) (my-set-font-if-exists 'variable-pitch "Iosevka SS05-9")))
  )
  (my-set-fonts)
#+END_SRC

*** UTF-8 Please
#+BEGIN_SRC emacs-lisp
  (setq locale-coding-system   'utf-8)
  (set-terminal-coding-system  'utf-8)
  (set-keyboard-coding-system  'utf-8)
  (set-selection-coding-system 'utf-8)
  (set-language-environment    "UTF-8")
  (prefer-coding-system        'utf-8)
#+END_SRC

** Intelligent narrowing and widening
From [[http://endlessparentheses.com/emacs-narrow-or-widen-dwim.html][endless parentheses]]

#+BEGIN_SRC emacs-lisp
  (defun my-narrow-or-widen-dwim (p)
    "Widen if buffer is narrowed, narrow-dwim otherwise.
  Dwim means: region, org-src-block, org-subtree, or defun, whichever applies first.
  Narrowing to org-src-block actually calls `org-edit-src-code'.

  With prefix P, don't widen, just narrow even if buffer is already narrowed."
    (interactive "P")
    (declare (interactive-only))
    (cond ((and (buffer-narrowed-p) (not p)) (widen))
          ((region-active-p)
           (narrow-to-region (region-beginning)
                             (region-end)))
          ((derived-mode-p 'org-mode)
           ;; `org-edit-src-code' is not a real narrowing command.
           ;; Remove this first conditional if you don't want it.
           (cond ((ignore-errors (org-edit-src-code) t)
                  (delete-other-windows))
                 ((ignore-errors (org-narrow-to-block) t))
                 (t (org-narrow-to-subtree))))
          ((derived-mode-p 'latex-mode)
           (LaTeX-narrow-to-environment))
          (t (narrow-to-defun))))

  ;; This line actually replaces Emacs' entire narrowing keymap.
  (bind-key "n" 'my-narrow-or-widen-dwim ctl-x-map)
#+END_SRC

** Prettify
*** Highlight current line
#+BEGIN_SRC emacs-lisp
  (bind-key "c" 'global-hl-line-mode my-settings-toggle-map)
#+END_SRC

*** Insert and show matching delimiters
#+BEGIN_SRC emacs-lisp
  (electric-pair-mode t)
  (show-paren-mode 1)
  (setq show-paren-delay 0)
  ;; (setq show-paren-style 'expression)
#+END_SRC

*** Pretty symbols
Replaces the text /lambda/ with λ. Full list of prettified symbols can be found in =prettify-symbols-alist=
The =inhibit-compacting-font-caches= stops garbage collect from trying to handle font caches making things a lot faster
#+BEGIN_SRC emacs-lisp
  (global-prettify-symbols-mode t)
  (setq inhibit-compacting-font-caches t)
  (setq prettify-symbols-unprettify-at-point 'right-edge)
#+END_SRC

Default symbols that must be applied to all modes
#+BEGIN_SRC emacs-lisp
  (defun my-pretty-symbols-default()
    (mapc (lambda(pair) (push pair prettify-symbols-alist))
          '(("!=" . ?≠)
            ("<=" . ?≤)
            (">=" . ?≥))))

  (add-hook 'prog-mode-hook (lambda() (my-pretty-symbols-default)))
#+END_SRC

C/C++ specific symbols
#+BEGIN_SRC emacs-lisp
  (add-hook 'c++-mode-hook
            (lambda() (mapc (lambda(pair) (push pair prettify-symbols-alist))
                       '(("->" . (?- (Br . Bc) ?- (Br . Bc) ?>))))))
#+END_SRC


NOTE: Some symbols occupy less space and may affect indendation. In order to avoid this,

**** Using prettify-symbols without breaking indentation
(From [[http://endlessparentheses.com/using-prettify-symbols-in-clojure-and-elisp-without-breaking-indentation.html][endlessparentheses]])
Use ~(">=" . (?\s (Br . Bl) ?\s (Bc . Bc) ?≥))~ instead of =?≥=

** Tabs, Indentation and Spacing
:PROPERTIES:
:ID:       8d72d9c2-5b52-454f-892a-107b009563fa
:END:
Use only spaces and no tabs
#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil
                tab-width 2
                show-trailing-whitespace nil
                sh-basic-offset 2)

  (setq sentence-end-double-space nil) ; Count 1 space after a period as the end of a sentence, instead of 2

  ;; (bind-key "RET" 'newline-and-indent)
#+END_SRC
Since these are buffer-local variables, I have to use =setq-default=

*** Highlight trailing whitespace
#+BEGIN_SRC emacs-lisp
  (defun my-toggle-trailing-whitespace ()
    "Toggle trailing whitespace"
    (interactive)  ; Allows to be called as a command via M-x
    (setq-default show-trailing-whitespace (not show-trailing-whitespace)))

  (bind-key "SPC" 'my-toggle-trailing-whitespace my-settings-toggle-map)
#+END_SRC

Enable it only in some modes
#+BEGIN_SRC emacs-lisp
  (dolist (hook '(prog-mode-hook text-mode-hook))
    (add-hook hook (lambda() (setq show-trailing-whitespace t))))
#+END_SRC

*** Delete trailing whitespace
Automatically while saving (from [[https://www.emacswiki.org/emacs/DeletingWhitespace#toc3][emacswiki]])
#+BEGIN_SRC emacs-lisp
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC

Use =C-c s SPC= to delete trailing whitespace manually
#+BEGIN_SRC emacs-lisp
  (bind-key "SPC" 'delete-trailing-whitespace my-s-bindings-map)
#+END_SRC

*** Toggle wrap
#+BEGIN_SRC emacs-lisp
  (bind-key "w" 'toggle-truncate-lines my-settings-toggle-map)
#+END_SRC

** Terminal
Specify the shell to use to avoid prompt. From [[https://youtu.be/L9vA7FHoQnk?list=PLX2044Ew-UVVv31a0-Qn3dA6Sd_-NyA1n&t=192][Uncle Dave's video]]
#+BEGIN_SRC emacs-lisp
  (defvar my-term-shell "/bin/bash")
  (defadvice ansi-term (before force-bash)
    (interactive (list my-term-shell)))
  (ad-activate 'ansi-term)
#+END_SRC

Launch
#+BEGIN_SRC emacs-lisp
  (bind-key* "<s-return>" 'ansi-term)
#+END_SRC

** Themes
Misc info:
=list-faces-display= - List all faces with colors and sample text
=list-colors-display= - List all colors with their names

*** Unload all loaded themes before loading new theme
http://www.greghendershott.com/2017/02/emacs-themes.html
By default emacs layers the new theme on top of all previously applied themes.

*** load-theme hook
Emacs doesn't have a native hook that is called after a theme has loaded. So we've to create one. (from [[https://www.reddit.com/r/emacs/comments/4v7tcj/does_emacs_have_a_hook_for_when_the_theme_changes/d5wyu1r/][reddit]])
#+BEGIN_SRC emacs-lisp
  (defvar after-load-theme-hook nil
    "Hook run after a color theme is loaded using `load-theme'.")
  (defadvice load-theme (after run-after-load-theme-hook activate)
    "Run `after-load-theme-hook'."
    (run-hooks 'after-load-theme-hook))
#+END_SRC

#+BEGIN_EXAMPLE
  (add-hook 'after-load-theme-hook (lambda() (message "Theme loaded")))
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp :tangle no
  (add-hook 'after-load-theme-hook
            (lambda()
              "Update fringe background color once a theme is loaded"
              (set-face-attribute 'fringe nil :background (face-attribute 'highlight :background))))
#+END_SRC

*** [[https://github.com/bbatsov/solarized-emacs][solarized]]
#+BEGIN_SRC emacs-lisp
  (use-package solarized-theme
    :init
    (setq solarized-distinct-fringe-background t
          solarized-use-variable-pitch nil)
    :custom
    (evil-normal-state-cursor   '("#859900" box))
    (evil-visual-state-cursor   '("#b58900" box))
    (evil-insert-state-cursor   '("#268bd2" bar))
    (evil-replace-state-cursor  '("#dc322f" bar))
    (evil-operator-state-cursor '("#dc322f" hollow))
    (evil-emacs-state-cursor    '("#839496" bar))
    :config
    (load-theme 'solarized-light t))
#+END_SRC

** Frame related
Frame parameters for all frames, regardless of window-system.
#+BEGIN_SRC emacs-lisp
(setq default-frame-alist
      '((tool-bar-lines 0)
        (left-fringe . nil)
        (right-fringe . 0)
        (menu-bar-lines . 0)
        (vertical-scroll-bars . nil)))
#+END_SRC

Per window-system overrides and additions to default-frame-alist.
=window-system-default-frame-alist= uses symbols of type =window-system= and not =system-type=
#+BEGIN_SRC emacs-lisp
  ;; Set frame size pixelwise instead of characterwise
  (setq frame-resize-pixelwise t)

  (setq window-system-default-frame-alist
        '((x . ((top . 0) (left . 0) (width . 319) (height . 74)))
          (w32 . ((fullscreen . maximized)))))
#+END_SRC

Set frame size programatically
#+BEGIN_SRC emacs-lisp
  (bind-keys :map my-s-bindings-map
             ("l" . (lambda () "Set emacs frame size to fit the left desktop monitor"
                      (interactive)
                      (set-frame-position (selected-frame) 0    0)
                      (set-frame-size     (selected-frame) 1910 1150 t)))
             ("r" . (lambda () "Set emacs frame size to fit the right desktop monitor"
                      (interactive)
                      (set-frame-position (selected-frame) 1919 0)
                      (set-frame-size     (selected-frame) 1910 1150 t))))
#+END_SRC

For reasons I don't understand, when I start a server and create a frame it still shows scroll-bars.
So, I have to disable this explicitly
#+BEGIN_SRC emacs-lisp
  (add-to-list 'default-frame-alist
               '(vertical-scroll-bars . nil))
#+END_SRC

* Packages
=(featurep 'FEATURE)= can be used to determine if the package has been loaded or not.
eg. if we do =C-h f ivy-mode=, it says it's defined in /ivy.el/ and at the bottom of the file, we see =(provide 'ivy)=
Thus, ivy is the feature-name.

Other examples:
- /rainbow-mode/ is a mode provided by the file /rainbow-mode.el/ and the feature is also called /rainbow-mode/
- /yas-minor-mode/ is a mode provided by the file /yasnippet.el/ and the feature is called /yasnippet/

** aggressive-indent
#+BEGIN_SRC emacs-lisp
  (use-package aggressive-indent
    :hook (emacs-lisp-mode . aggressive-indent-mode))
#+END_SRC

** avy
I'm using =C-'= instead of creating a binding in =my-goto-map= as that's the default binding used in an ivy-minibuffer
Also, I'm rebinding =M-g M-g= from =goto-line= as using a number with =avy-goto-line= makes it behave like =goto-line= anyway.
Besides, =M-g g= is still bound to =goto-line= by default and, not to mention =<N>G= binding from evil.

#+BEGIN_SRC emacs-lisp
  (use-package avy
    :after evil
    :bind* (("C-'" . avy-goto-char-timer)
            ("M-g M-g" . avy-goto-line))
    :bind (:map my-goto-map ("o" . avy-org-goto-heading-timer)))
#+END_SRC

** beacon
#+BEGIN_SRC emacs-lisp
  (use-package beacon
    :custom
    (beacon-blink-when-window-scrolls nil)
    (beacon-color (face-attribute 'fringe :background))
    :config
    (beacon-mode 1)
    (add-hook 'after-load-theme-hook
              (lambda()
                "Update beacon's background color once a theme is loaded"
                (setq beacon-color (face-attribute 'fringe :background)))))
#+END_SRC

** company
Provides auto-completion.
References:
- [[https://youtu.be/XeWZfruRu6k][Uncle Dave's video]] for an introduction.
- https://www.reddit.com/r/emacs/comments/8z4jcs/tip_how_to_integrate_company_as_completion/

#+BEGIN_SRC emacs-lisp
  (use-package company
    :init (add-hook 'after-init-hook 'global-company-mode)
    :hook (c-mode c++-mode)
    :bind (:map my-auto-completion-map
                ("&" . company-yasnippet))
    :config (setq company-idle-delay 0
                  company-minimum-prefix-length 2
                  company-show-numbers t           ; Show numbers in the drop-down menu to simplify selection
                  company-selection-wrap-around t)
#+END_SRC

*** Keybindings
Replace Meta bindings with Ctrl
#+BEGIN_SRC emacs-lisp
  (unbind-key "M-n" company-active-map)
  (unbind-key "M-p" company-active-map)

  (bind-keys :map company-active-map
             ("C-n" . company-select-next)
             ("C-p" . company-select-previous))
#+END_SRC

*** Enable yasnippet for all backends
(from [[https://emacs.stackexchange.com/a/10520/9690][emacs.stackexchange]])
Keeping this at the end to be run after we've added all backends
#+BEGIN_SRC emacs-lisp
  (defun company-mode/backend-with-yas (backend)
    (if (and (listp backend) (member 'company-yasnippet backend))
        backend
      (append (if (consp backend) backend (list backend))
              '(:with company-yasnippet))))

  (setq company-backends (mapcar #'company-mode/backend-with-yas company-backends))
#+END_SRC

*** /fin/
#+BEGIN_SRC emacs-lisp
)
#+END_SRC

*** company-irony
#+BEGIN_SRC emacs-lisp
  (use-package company-irony
    :after (company irony yasnippet)
    :config
    (add-to-list 'company-backends '(company-irony :with company-yasnippet)))
#+END_SRC

** evil
Getting started guide: https://github.com/noctuid/evil-guide
evil can be toggled using =C-z=
#+BEGIN_SRC emacs-lisp
  (use-package evil
    :init
    (setq evil-want-C-w-in-emacs-state t
          evil-want-Y-yank-to-eol t)
#+END_SRC

*** :config
#+BEGIN_SRC emacs-lisp
  :config
  (evil-mode t)
#+END_SRC

Mode specific states
#+BEGIN_SRC emacs-lisp
  (dolist (mode '(git-rebase-mode org-toc-mode))
    (evil-set-initial-state mode 'emacs))
  (evil-set-initial-state 'term-mode 'insert)
#+END_SRC

=evil-set-initial-state= works only for major modes. Thus for minor modes I have to use an explicit hook. Refer this [[https://github.com/emacs-evil/evil/issues/1115][github issue]] for details
#+BEGIN_SRC emacs-lisp
  (dolist (hook '(org-capture-mode-hook))
    (add-hook hook 'evil-insert-state))

  (dolist (hook '(edebug-mode-hook))
    (add-hook hook 'evil-emacs-state))
#+END_SRC

**** Keybindings
:PROPERTIES:
:ID:       f42c3dc8-c2f6-4f22-9f47-0c578479ef67
:END:
#+BEGIN_SRC emacs-lisp
  (defun my-unimpaired-insert-line-before ()
    "Insert blank line line before the current one"
    (interactive)
    (beginning-of-line)(open-line 1))

  (defun my-unimpaired-insert-line-after ()
    "Insert blank line line after the current one"
    (interactive)
    (end-of-line)(newline))

  (bind-keys :map evil-normal-state-map
             ("] SPC" . my-unimpaired-insert-line-after)
             ("[ SPC" . my-unimpaired-insert-line-before)
             ("] b"   . next-buffer)
             ("[ b"   . previous-buffer)
             ("] q"   . next-error)
             ("[ q"   . previous-error)
             ("[ Q"   . first-error))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook (lambda() (bind-key "z v" 'org-reveal evil-normal-state-map)))
#+END_SRC

<<Make Escape quit everything>>
#+BEGIN_SRC emacs-lisp
  (define-key key-translation-map (kbd "ESC") (kbd "C-g"))
#+END_SRC

***** Follow newly created splits
#+BEGIN_SRC emacs-lisp
  (bind-keys :map evil-window-map
             ("s" . (lambda() (interactive) (evil-window-split)(other-window 1)))
             ("v" . (lambda() (interactive) (evil-window-vsplit)(other-window 1))))
#+END_SRC

***** Move by visual lines
Note this is not a complete solution since it doesn't work when combined with operators (eg. =dj=)
#+BEGIN_SRC emacs-lisp
  (bind-keys :map evil-motion-state-map
             ("j"  . evil-next-visual-line)
             ("gj" . evil-next-line)
             ("k"  . evil-previous-visual-line)
             ("gk" . evil-previous-line)
             ("$"  . evil-end-of-line)
             ("g$" . evil-end-of-visual-line))
#+END_SRC

***** Sensible rebindings
#+BEGIN_SRC emacs-lisp
  (define-key key-translation-map (kbd "C-w C-h") (kbd "C-w h"))
  (define-key key-translation-map (kbd "C-w C-j") (kbd "C-w j"))
  (define-key key-translation-map (kbd "C-w C-k") (kbd "C-w k"))
  (define-key key-translation-map (kbd "C-w C-l") (kbd "C-w l"))
  (define-key key-translation-map (kbd "C-w C-s") (kbd "C-w s"))
  (define-key key-translation-map (kbd "C-w C-v") (kbd "C-w v"))

  (bind-key "U" 'redo evil-normal-state-map)
#+END_SRC

More intuitive keybindings for winner-mode
#+BEGIN_SRC emacs-lisp
  (bind-keys :map evil-window-map
             ("u" . winner-undo)
             ("U" . winner-redo))
#+END_SRC

*** /fin/
#+BEGIN_SRC emacs-lisp
  )
#+END_SRC

*** evil-args
#+BEGIN_SRC emacs-lisp
  (use-package evil-args
    :after evil
    :bind (:map evil-inner-text-objects-map
                ("," . evil-inner-arg)
           :map evil-outer-text-objects-map
                ("," . evil-outer-arg)
           :map evil-normal-state-map
                ("] ," . evil-forward-arg)
                ("[ ," . evil-backward-arg)
           :map evil-motion-state-map
                ("] ," . evil-forward-arg)
                ("[ ," . evil-backward-arg)))
#+END_SRC

*** evil-commentary
#+BEGIN_SRC emacs-lisp
  (use-package evil-commentary
    :after evil
    :bind (:map evil-normal-state-map
                ("g c" . evil-commentary)
           :map evil-visual-state-map
                ("g c" . evil-commentary)))
#+END_SRC

*** evil-exchange
#+BEGIN_SRC emacs-lisp
  (use-package evil-exchange
    :after evil
    :config (evil-exchange-cx-install))
#+END_SRC

*** evil-matchit
#+BEGIN_SRC emacs-lisp
  (use-package evil-matchit
    :after evil
    :config
    (global-evil-matchit-mode 1))
#+END_SRC

*** evil-numbers
#+BEGIN_SRC emacs-lisp
  (use-package evil-numbers
    :after evil
    :bind (:map evil-normal-state-map
               ("C-c +" . evil-numbers/inc-at-pt)
               ("C-c -" . evil-numbers/dec-at-pt)
           :map evil-visual-state-map
               ("C-c +" . evil-numbers/inc-at-pt)
               ("C-c -" . evil-numbers/dec-at-pt)))
#+END_SRC

*** evil-string-inflection
Provides =g~= operator to cycle between snake_case → SCREAMING_SNAKE_CASE → TitleCase → CamelCase → kebab-case
#+BEGIN_SRC emacs-lisp
  (use-package evil-string-inflection
    :after evil
    :bind (:map evil-normal-state-map
                ("g ~" . evil-operator-string-inflection)
           :map evil-visual-state-map
                ("g ~" . evil-operator-string-inflection)))
#+END_SRC

*** evil-surround
#+BEGIN_SRC emacs-lisp
  (use-package evil-surround
    :after evil
    :config (global-evil-surround-mode))
#+END_SRC

*** evil-visualstar
#+BEGIN_SRC emacs-lisp
  (use-package evil-visualstar
    :after evil
    :config (global-evil-visualstar-mode))
#+END_SRC

** flycheck
References:
- https://www.reddit.com/r/emacs/comments/931la6/tip_how_to_adopt_flycheck_as_your_new_best_friend/

#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :hook (prog-mode . flycheck-mode)
    :custom
    (flycheck-gcc-language-standard "c++14")
    (flycheck-clang-language-standard "c++14"))
#+END_SRC

** hideshow
:PROPERTIES:
:CREATED:  [2018-08-03 Fri 14:09]
:END:
Code-folding. From https://github.com/mwfogleman/.emacs.d/blob/master/michael.org#cold-folding and [[https://www.reddit.com/r/emacs/comments/746cd0/which_code_folding_package_do_you_use/dnwi2x1/][reddit]]

#+BEGIN_SRC emacs-lisp
  (use-package hideshow
    :hook ((prog-mode . hs-minor-mode))
    :config
    (defun my-toggle-fold ()
      (interactive)
      (save-excursion
        (end-of-line)
        (hs-toggle-hiding)))
    (bind-key "f" 'my-toggle-fold my-settings-toggle-map))
#+END_SRC

** hydra
#+BEGIN_SRC emacs-lisp
  (use-package hydra)
#+END_SRC

Currently I'm using this only for =ivy-hydra=. More ideas in https::/github.com/kana/vim-submode

** irony
#+BEGIN_SRC emacs-lisp
  (use-package irony
    :hook (c-mode c++-mode)
    :config (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options))
#+END_SRC

** ivy et al.
#+BEGIN_SRC emacs-lisp
  (use-package ivy
    :custom
    (ivy-virtual-abbreviate 'abbreviate "Show abbreviated path in addition to the filename")
    :config
    (ivy-mode 1)
    (setq ivy-count-format "%d/%d "
          ivy-height 12
          ivy-extra-directories nil)
#+END_SRC

Do not add a =^= (beginning of line anchor) while completing. Refer [[https://github.com/abo-abo/swiper/issues/140][this]] and [[https://github.com/abo-abo/swiper/issues/1126][this]].
#+BEGIN_SRC emacs-lisp
  (setq ivy-initial-inputs-alist nil)
#+END_SRC

*** Keybindings
#+BEGIN_SRC emacs-lisp
  (bind-key* "C-c C-r" 'ivy-resume)
#+END_SRC

|---------+------------------------------------------------------------------------------------------------------------------------|
| Binding | Description                                                                                                            |
|---------+------------------------------------------------------------------------------------------------------------------------|
| =M-n=     | [[http://mbork.pl/2018-04-21_counsel-rg_and_symbol_at_point][Insert symbol at point]]. By default /M-p/ and /M-n/ go back and forward in history.                                         |
|         | However, starting with /M-n/ we move the minibuffer history into the future, which can be thought of as a "dwim" choice. |
|---------+------------------------------------------------------------------------------------------------------------------------|
| =M-q=     | [[http://irreal.org/blog/?p=7457][Query replace]]. Start a substitution using the search pattern                                                           |
|---------+------------------------------------------------------------------------------------------------------------------------|
| =C-c C-o= | [[https://oremacs.com/2015/11/04/ivy-occur/][ivy-occur]]. Launch occur using current input                                                                            |
|---------+------------------------------------------------------------------------------------------------------------------------|

**** Show mix of buffers, recent files and bookmarks
There is a variable =ivy-use-virtual-buffers= that does this. However, it is static and when set, dumps everything in =ivy-switch-buffer=.
As a result, by default I have to choose one or the other; I can't have both. This fixes that.
=C-c j j= will show buffers, recent files and bookmarks while =C-c j b= will only show buffers
#+BEGIN_SRC emacs-lisp
  (defun my-ivy-switch-virtual-buffer ()
    "Show recent files and bookmarks in the buffer list"
    (interactive)
    (let* ((ivy-use-virtual-buffers t))
      (ivy-switch-buffer)))

  (defun my-p4-files ()
    "Use fzf with perforce"
    (let (counsel-fzf-cmd "p4 have $STEM/... | fzf -f \"%s\"")
      (counsel-fzf)))

  (defun my-file-finder ()
    "Context based file finding"
    (interactive)
    (cond ((locate-dominating-file default-directory ".git") (counsel-git))
          ((locate-dominating-file default-directory "P4CONFIG") (my-p4-files))
          (t (counsel-fzf))))

  (bind-keys :map my-fuzzy-jumper-command-map
             ("b" . ivy-switch-buffer)
             ("f" . my-file-finder)
             ("j" . my-ivy-switch-virtual-buffer))
#+END_SRC

*** /fin/
#+BEGIN_SRC emacs-lisp
  )
#+END_SRC

*** ivy-hydra
#+BEGIN_SRC emacs-lisp
  (use-package ivy-hydra
    :after (ivy hydra)
    :config
#+END_SRC

**** Customize the default ivy-hydra
Provides some vim-ish movements and calling methods. From [[https://github.com/abo-abo/hydra/wiki/hydra-ivy-replacement][here]]
eg. To kill multiple buffers
- =C-x b= to open the buffer list
- =C-o= to open the hydra menu
- Select the 'kill' action by pressing =o k= or select it by cycling through the actions using =w= and =s=
- Once the 'kill' action has been selected, select the buffer to kill using the movement keys and press =f= to execute the action
- Pressing =f= keeps the hydra menu open to allow selecting other buffers to execute the selected action

#+BEGIN_SRC emacs-lisp
  (bind-key "\C-o"
    (defhydra soo-ivy (:hint nil :color pink)
      "
   Move     ^^^^^^^^^^ | Call        ^^^^ | Cancel^^ | Options^^ | Action _w_/_s_ _o_: %s(ivy-action-name)
  ----------^^^^^^^^^^-+-------------^^^^-+-------^^-+--------^^-+---------------------------------
   _g_ ^ ^ _k_ ^ ^ _u_ | _f_ollow occu_r_ | _i_nsert | _c_alling: %-7s(if ivy-calling \"on\" \"off\") _C_ase-fold: %-10`ivy-case-fold-search
   ^↕^ _h_ ^+^ _l_ ^↕^ | _RET_ done     ^^| _q_uit   | _m_atcher: %-7s(ivy--matcher-desc)^^^^^^^^^^^^ _t_runcate: %-11`truncate-lines
   _G_ ^ ^ _j_ ^ ^ _d_ | _TAB_ alt-done ^^| ^ ^      | _<_/_>_: shrink/grow
  "
      ;; arrows
      ("j" ivy-next-line)
      ("k" ivy-previous-line)
      ("l" ivy-alt-done)
      ("h" ivy-backward-delete-char)
      ("g" ivy-beginning-of-buffer)
      ("G" ivy-end-of-buffer)
      ("d" ivy-scroll-up-command)
      ("u" ivy-scroll-down-command)
      ("e" ivy-scroll-down-command)
      ;; actions
      ("q" keyboard-escape-quit :exit t)
      ("C-g" keyboard-escape-quit :exit t)
      ("<escape>" keyboard-escape-quit :exit t)
      ("C-o" nil)
      ("i" nil)
      ("TAB" ivy-alt-done :exit nil)
      ("C-j" ivy-alt-done :exit nil)
      ;; ("d" ivy-done :exit t)
      ("RET" ivy-done :exit t)
      ("C-m" ivy-done :exit t)
      ("f" ivy-call)
      ("c" ivy-toggle-calling)
      ("m" ivy-toggle-fuzzy)
      (">" ivy-minibuffer-grow)
      ("<" ivy-minibuffer-shrink)
      ("w" ivy-prev-action)
      ("s" ivy-next-action)
      ("o" ivy-read-action)
      ("t" (setq truncate-lines (not truncate-lines)))
      ("C" ivy-toggle-case-fold)
      ("r" ivy-occur :exit t))
    ivy-minibuffer-map)
#+END_SRC

**** /fin/
#+BEGIN_SRC emacs-lisp
  )
#+END_SRC

*** swiper
#+BEGIN_SRC emacs-lisp
  (use-package swiper
    :after ivy
    :bind* ("C-M-s" . swiper-all)
    :init
    (when (or (executable-find "grep") (executable-find "rg"))
      (bind-key* "C-s" 'counsel-grep-or-swiper))
    :config
    (when (executable-find "rg")
      (setq counsel-grep-base-command
            "rg --smart-case --max-columns 240 --no-heading --line-number --color never '%s' %s")))
#+END_SRC

*** counsel
NOTE: I'm deferring loading using =:commands= for those commands for which I cannot use =:bind= here
=counsel-org-tag= binding is defined only after org is loaded so I'm defining it there instead.
=counsel-org-goto= is set conditionally only if we're in org-mode

Also, I'm explicitly binding each command to its counsel variant to get it to work with ivy-rich.
eg. the default flavor of =M-x= will still have all fuzzy searching goodness that ivy brings. However,
using =counsel-M-x= causes ivy-rich to put a docstring in there which it doesn't do with the default flavor of =M-x=

NOTE: I'm deferring loading by using the =commands= keyword for =counsel-org-tag= because the binding for it,
=C-c C-q= is found in =org-mode-map= which hasn't been defined yet.
#+BEGIN_SRC emacs-lisp
  (use-package counsel
    :after ivy
    :commands (counsel-org-tag counsel-org-goto counsel-semantic-or-imenu)
    :bind* ("M-x" . counsel-M-x)
    :bind  (:map help-map
                 ("a" . counsel-apropos)
                 ("f" . counsel-describe-function)
                 ("v" . counsel-describe-variable))
#+END_SRC

Use =C-c f= as prefix for all counsel-related keybindings
#+BEGIN_SRC emacs-lisp
  :bind (:map my-fuzzy-jumper-command-map
              ("/" . counsel-rg)
         :map my-s-bindings-map
              ("v" . counsel-set-variable))

  :config
  (defun my-counsel-imenu ()
    "Use mode-specific commands if available else fallback to counsel-semantic-or-imenu"
    (interactive)
    (if (string= major-mode "org-mode")
        (counsel-org-goto)
      (counsel-semantic-or-imenu)))
  (bind-key "o" 'my-counsel-imenu my-fuzzy-jumper-command-map)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  )
#+END_SRC

*** [[https://github.com/Yevgnen/ivy-rich][ivy-rich]]
:PROPERTIES:
:CREATED:  [2018-07-09 Mon 16:46]
:END:
#+BEGIN_SRC emacs-lisp
  (use-package ivy-rich
    :after ivy
    :custom
    (ivy-rich-path-style 'abbrev)

    ;; Pretty-much the default, just bumping up the widths
    (ivy-rich--display-transformers-list '(
                                           ivy-switch-buffer
                                           (:columns
                                            ((ivy-rich-candidate (:width 40))
                                             (ivy-rich-switch-buffer-size (:width 7))
                                             (ivy-rich-switch-buffer-indicators (:width 4 :face error :align right))
                                             (ivy-rich-switch-buffer-major-mode (:width 12 :face warning))
                                             (ivy-rich-switch-buffer-project (:width 15 :face success))
                                             (ivy-rich-switch-buffer-path (:width
                                                                           (lambda (x)
                                                                             (ivy-rich-switch-buffer-shorten-path x
                                                                                                                  (ivy-rich-minibuffer-width 0.3))))))
                                            :predicate
                                            (lambda (cand) (get-buffer cand)))

                                           counsel-M-x
                                           (:columns
                                            ((counsel-M-x-transformer (:width 50))
                                             (ivy-rich-counsel-function-docstring (:face font-lock-doc-face))))

                                           counsel-describe-function
                                           (:columns
                                            ((counsel-describe-function-transformer (:width 50))
                                             (ivy-rich-counsel-function-docstring (:face font-lock-doc-face))))

                                           counsel-describe-variable
                                           (:columns
                                            ((counsel-describe-variable-transformer (:width 50))
                                             (ivy-rich-counsel-variable-docstring (:face font-lock-doc-face))))

                                           counsel-recentf
                                           (:columns
                                            ((ivy-rich-candidate (:width 0.8))
                                             (ivy-rich-file-last-modified-time (:face font-lock-comment-face))))))

    :config
    (ivy-rich-mode t))
#+END_SRC

** modern-c++-font-lock
#+BEGIN_SRC emacs-lisp
  (use-package modern-cpp-font-lock
    :hook (c++-mode . modern-c++-font-lock-mode))
#+END_SRC

** org
This solution is by [[https://www.reddit.com/r/emacs/comments/5sx7j0/how_do_i_get_usepackage_to_ignore_the_bundled/ddixpr9/][/u/Wolfer1ne on reddit]].
#+BEGIN_SRC emacs-lisp
  (use-package org
    :ensure org-plus-contrib
#+END_SRC

<<ensure_target>>
I specifically grab =org-plus-contrib= from the org repository instead of the bundled version to be able to use org-expiry
Passing an argument to =:ensure= (other than t or nil) allows us to use a different package than the one named in use-package

Resources: [[http://orgmode.org/worg/org-configs/org-customization-guide.html][Customization guide]], [[https://www.reddit.com/r/emacs/comments/8nvnlu/extending_orgmode/dzz1el9][Extensions]]

*** :init
#+BEGIN_SRC emacs-lisp
  :init
  (setq org-directory "~/Notes/")
  (setq org-default-notes-file (expand-file-name "Inbox.org" org-directory))

  (setq org-M-RET-may-split-line '((item) (default . t)))
  ;; (setq org-special-ctrl-a/e t)
  ;; (setq org-return-follows-link nil)
  (setq org-use-speed-commands nil)
  ;; (setq org-speed-commands-user nil)
  (setq org-startup-align-all-tables nil)
  (setq org-use-property-inheritance t)
  (setq org-tags-column -100)
  (setq org-hide-emphasis-markers t)  ; Hide markers for bold/italics etc.
  (setq org-blank-before-new-entry '((heading . t) (plain-list-item . nil)))
  (setq org-link-search-must-match-exact-headline nil)
  (setq org-startup-with-inline-images t)
  (setq org-imenu-depth 10)
#+END_SRC

**** org-babel source blocks
Enable syntax highlighting within the source blocks and keep the editing popup window within the same window.
Also, strip leading and trailing empty lines if any.
/org-src-preserve-indentation/ will not add an extra level of indentation to the source code
#+BEGIN_SRC emacs-lisp
  (setq org-src-fontify-natively                       t
        org-src-window-setup                           'current-window
        org-src-strip-leading-and-trailing-blank-lines t
        ;; org-src-preserve-indentation                t
        org-src-tab-acts-natively                      t)
#+end_src

Languages which can be evaluated in Org-mode buffers.
#+begin_src emacs-lisp
  (org-babel-do-load-languages 'org-babel-load-languages
                               (append org-babel-load-languages
                                       '((python     . t)
                                         (ruby       . t)
                                         (perl       . t)
                                         (dot        . t)
                                         (C          . t))))
#+end_src

Ask for confirmation before evaluating? NO!
#+BEGIN_SRC emacs-lisp :tangle no
  (defun my-org-babel-evaluate-silent (lang body)
    "Do not ask for confirmation to evaluate these languages."
    (not (or (string= lang "emacs-lisp"))))

  (setq org-confirm-babel-evaluate 'my/org-babel-evaluate-silent)
#+END_SRC

On second thought it's better not to do this because of the security implications.
A safer way to go about it is by enabling it on a file-by-file basis using the following modeline
#+BEGIN_EXAMPLE
  -*- org-confirm-babel-evaluate: nil -*-
#+END_EXAMPLE

**** Clean View
#+BEGIN_SRC emacs-lisp
  (setq org-startup-indented t)
  (setq org-hide-leading-stars t)
  (setq org-odd-level-only nil)

  ;; others: ▼, ↴, ⬎, ⤷, …, ⋱
  (setq org-ellipsis " ▼")
#+END_SRC

***** TODO Hide the < and > around targets
From [[http://emacs.stackexchange.com/a/19239/9690][Emacs StackExchange]]
At the moment, it hides not just the angle braces but also the text between them.
#+BEGIN_SRC emacs-lisp :tangle no
  (defcustom org-hidden-links-additional-re "<<[<]?[[:alnum:]]+>>[>]?"
    "Regular expression that matches strings where the invisible-property is set to org-link."
    :type '(choice (const :tag "Off" nil) regexp)
    :group 'org-link)
  (make-variable-buffer-local 'org-hidden-links-additional-re)

  (defun org-activate-hidden-links-additional (limit)
    "Put invisible-property org-link on strings matching `org-hide-links-additional-re'."
    (if org-hidden-links-additional-re
        (re-search-forward org-hidden-links-additional-re limit t)
      (goto-char limit)
      nil))

  (add-hook 'org-font-lock-set-keywords-hook (lambda ()
                                               (add-to-list 'org-font-lock-extra-keywords
                                                            '(org-activate-hidden-links-additional
                                                              (0 '(face org-target invisible org-link))))))
#+END_SRC

***** TODO Show the emphasis and target markers on point
#+BEGIN_SRC emacs-lisp :tangle no
  (defun org-show-emphasis-markers-at-point ()
    (save-match-data
      (if (and (org-in-regexp org-emph-re 2)
               (>= (point) (match-beginning 3))
               (<= (point) (match-end 4))
               (member (match-string 3) (mapcar 'car org-emphasis-alist)))
          (with-silent-modifications
            (remove-text-properties
             (match-beginning 3) (match-beginning 5)
             '(invisible org-link)))
        (apply 'font-lock-flush (list (match-beginning 3) (match-beginning 5))))))

  (add-hook 'post-command-hook 'org-show-emphasis-markers-at-point nil t)
#+END_SRC

**** ToDo States
Custom keywords
#+BEGIN_SRC emacs-lisp
  (setq org-todo-keywords '((sequence "TODO(t!)" "WAITING(w@/!)" "|" "DONE(d@/!)" "DEFER(f@/!)" "CANCEL(c@)")))
  ;; (setq org-todo-keyword-faces
  ;;       (quote (("TODO" :foreground "red" :weight bold)
  ;;               ("WAITING" :foreground "orange" :weight bold)
  ;;               ("DONE" :foreground "forest green" bold)
  ;;               ("CANCEL" :foreground "forest green" bold))))
#+END_SRC
=@=   - Log timestamp and note
=!=   - Log timestamp only
=x/y= - =x= takes affect when entering the state and
      =y= takes affect when exiting if the state being entered doesn't have any logging
Refer [[http://orgmode.org/manual/Tracking-TODO-state-changes.html][Tracking-TODO-state-changes]] for details

Add logging when task state changes
#+BEGIN_SRC emacs-lisp
  (setq org-log-done nil  ; Not required as state changes are logged in the LOGBOOK
        org-log-redeadline 'note
        org-log-into-drawer t  ; Save state changes into LOGBOOK drawer instead of in the body
        org-treat-insert-todo-heading-as-state-change t
        org-enforce-todo-dependencies t)  ; Prevent parent task from being marked complete till all child TODOS are marked as complete
#+END_SRC

Change from any todo state to any other state using =C-c C-t KEY=
#+BEGIN_SRC emacs-lisp
  (setq org-use-fast-todo-selection t)
#+END_SRC

This frees up S-left and S-right which I can then use to cycles through the todo states but skip setting timestamps and entering notes which is very convenient when all I want to do is change the status of an entry without changing its timestamps
#+BEGIN_SRC emacs-lisp
  (setq org-treat-S-cursor-todo-selection-as-state-change nil)
#+END_SRC

*** :config
#+BEGIN_SRC emacs-lisp
  :config
  (setq org-clock-idle-time nil)
  ;; (set-face-attribute 'org-block nil :inherit 'fixed-pitch)
#+END_SRC

**** TODO [[https://orgmode.org/manual/Easy-templates.html][Easy Templates]]
:PROPERTIES:
:ID:       851ad87b-250e-4c1e-83b1-6b4e1fa6b20d
:CREATED:  [2019-01-11 Fri 13:03]
:END:
These get added only if org-version < 9.2
=?= in each string controls where the point will be placed after expansion
#+BEGIN_SRC emacs-lisp :tangle no
  (add-to-list 'org-structure-template-alist
               '("sc" "#+BEGIN_SRC C++\n  #include <iostream>\n\n  using namespace std;\n\n  int main() {\n    ?cout << \"Hello World!\\n\";\n  }\n#+END_SRC"))

  (add-to-list 'org-structure-template-alist
               '("sl" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC\n" "<src lang=\"?\">\n\n</src>"))

  (add-to-list 'org-structure-template-alist
               '("sp" "#+BEGIN_SRC python\n?\n#+END_SRC\n" "<src lang=\"?\">\n\n</src>"))

  ;; (add-to-list 'org-structure-template-alist
  ;;              '("sd" "#+BEGIN_SRC dot :file /tmp/out.png\n?\n#+END_SRC\n" "<src lang=\"?\">\n\n</src>"))

  (add-to-list 'org-structure-template-alist
               '("ss" "#+BEGIN_SRC bash\n?\n#+END_SRC\n" "<src lang=\"?\">\n\n</src>"))
#+END_SRC

For org-version >= 9.2, we have to use this. =C-c C-,= was also added in 9.2 and provides a menu to select an easy-template
#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-structure-template-alist '("sc" . "src C++"))
  (add-to-list 'org-structure-template-alist '("sl" . "src emacs-lisp"))
  (add-to-list 'org-structure-template-alist '("ss" . "src bash"))
#+END_SRC

However, note that since the following start with =s=, it will get clobbered by the default =src= block and not show up in the menu.
Thus to get it to work as before using =<sc=, we have to add =org-tempo= to =org-modules=
#+begin_src emacs-lisp
  (add-to-list 'org-modules 'org-tempo)
#+end_src

**** Flatten links
This is the counterpart to =org-insert-link=. From [[http://emacs.stackexchange.com/a/10714/9690][here]].
#+BEGIN_SRC emacs-lisp
  (defun my-org-flatten-link (&optional replace-with-description)
    "Replace an org link with its description if REPLACE-WITH-DESCRIPTION is true. If not or if description doesn't exist, replace with its url"
    (interactive)
    (if (org-in-regexp org-bracket-link-regexp 1)
        (let ((remove (list (match-beginning 0) (match-end 0)))
              (description (if (match-end 3)
                               (org-match-string-no-properties 3)
                             (org-match-string-no-properties 1))))
          (apply 'delete-region remove)
          (insert description))))
#+END_SRC

**** Use ! to toggle timestamp type
:PROPERTIES:
:ID:       d4634d95-be37-4bdf-987e-22da5778e958
:END:
[[https://orgmode.org/manual/Creating-timestamps.html][By default]], org-mode uses =C-c .= and =C-c != to create active and inactive timestamps respectively.
However, I also have flycheck installed which uses the C-c ! binding.

Thus, this allows me to use =C-c .= to insert a timestamp and when prompted to enter the date+time in the minibuffer,
use =!= to toggle between active and inactive timestamps. Also see [[Custom timestamp keymap]].
From [[http://emacs.stackexchange.com/questions/38062/configure-key-to-toggle-between-active-and-inactive-timestamps#38065][Emacs StackExchange]]

#+BEGIN_SRC emacs-lisp
  (defun org-toggle-time-stamp-activity ()
    "Toggle activity of time stamp or range at point."
    (interactive)
    (let ((pt (point)))
      (when (org-at-timestamp-p t)
        (goto-char (match-beginning 0))
        (when-let ((el (org-element-timestamp-parser))
                   (type (org-element-property :type el))
                   (type-str (symbol-name type))
                   (begin (org-element-property :begin el))
                   (end (org-element-property :end el)))
          (setq type-str
                (if (string-match "inactive" type-str)
                    (replace-regexp-in-string "inactive" "active" type-str)
                  (replace-regexp-in-string "active" "inactive" type-str)))
          (org-element-put-property el :type (intern type-str))
          (goto-char end)
          (skip-syntax-backward "-")
          (delete-region begin (point))
          (insert (org-element-timestamp-interpreter el nil))
          (goto-char pt)))))

  (defvar-local calendar-previous-buffer nil
    "Buffer been active when `calendar' was called.")

  (defun calendar-save-previous-buffer (oldfun &rest args)
    "Save buffer been active at `calendar' in `calendar-previous-buffer'."
    (let ((buf (current-buffer)))
      (apply oldfun args)
      (setq calendar-previous-buffer buf)))

  (advice-add #'calendar :around #'calendar-save-previous-buffer)

  (defvar-local my-org-time-stamp-toggle nil
    "Make time inserted time stamp inactive after inserting with `my-org-time-stamp'.")

  (defun org-time-stamp-toggle ()
    "Make time stamp active at the end of `my-org-time-stamp'."
    (interactive)
    (when-let ((win (minibuffer-selected-window))
               (buf (window-buffer win)))
      (when (buffer-live-p buf)
        (with-current-buffer buf
          (when (buffer-live-p calendar-previous-buffer)
            (set-buffer calendar-previous-buffer))
          (setq my-org-time-stamp-toggle (null my-org-time-stamp-toggle))
          (setq org-read-date-inactive my-org-time-stamp-toggle)))))

  (define-key org-read-date-minibuffer-local-map "!" #'org-time-stamp-toggle)

  (defun my-org-time-stamp (arg)
    "Like `org-time-stamp' with ARG but toggle activity with character ?!."
    (interactive "P")
    (setq my-org-time-stamp-toggle nil)
    (org-time-stamp arg)
    (when my-org-time-stamp-toggle
      (backward-char)
      (org-toggle-time-stamp-activity)
      (forward-char)))

  ;; (org-defkey org-mode-map (kbd "C-c .") #'my-org-time-stamp)
#+END_SRC

**** org-refile
By [[https://www.reddit.com/r/emacs/comments/4366f9/how_do_orgrefiletargets_work/czg008y/][/u/awalker4 on reddit]].
Show upto 3 levels of headings from the current file and two levels of headings from all agenda files
#+BEGIN_SRC emacs-lisp
  (setq org-refile-targets
        '((nil . (:maxlevel . 3))
          (org-agenda-files . (:maxlevel . 2))))
#+END_SRC
Each element of the list generates a set of possible targets.
/nil/ indicates that all the headings in the current buffer will be considered.

Following are from Aaron Bieber's post [[https://blog.aaronbieber.com/2017/03/19/organizing-notes-with-refile.html][Organizing Notes with Refile]]

Creating new parents - To create new heading, add =/HeadingName= to the end when using refile (=C-c C-w=)
#+BEGIN_SRC emacs-lisp
  (setq org-refile-allow-creating-parent-nodes 'confirm)
  (setq org-refile-use-outline-path 'file)
  (setq org-outline-path-complete-in-steps nil)
#+END_SRC

Store the timestamp when an entry is refiled
#+BEGIN_SRC emacs-lisp
  (setq org-log-refile 'time)
#+END_SRC

***** TODO Set org-refile targets based on current file
Why would I want to refile something work-related under Softwares etc.
A way to do it is by writing a function that sets /org-refile-targets/ in a let binding making it local.
eg. implementation by abo-abo: [[https://github.com/abo-abo/worf/blob/master/worf.el][worf-refile-other]]

#+BEGIN_SRC emacs-lisp :tangle no
  (load-library "find-lisp")

  (defun my-org-refile-targets ()
    "Refile the current heading to another heading.
  The other heading can be in the current file or in a file that resides
  anywhere below the directory the current file resides in.

  The intent is to move to a similar file. If I'm in work-related file,
  I almost never have to refile something to a personal file."
    (interactive "p")
    (let* ((org-refile-targets '((nil . (:maxlevel . 9)))))
      (org-refile)))

  (bind-key* "C-c C-w" 'my-org-refile)
  (bind-key "C-c C-w" 'my-org-refile org-mode-map)
#+END_SRC

***** TODO Rice org-refile
eg. https://emacs-china.org/t/topic/3622

**** org-babel
Some org-babel [[https://github.com/dfeich/org-babel-examples][recipes]]

#+BEGIN_SRC emacs-lisp
  (setq org-babel-default-header-args
        '((:results . "verbatim replace")))

  (setq org-babel-C++-compiler "clang++")
  (setq org-babel-default-header-args:C++
        '((:flags . "-std=c++14 -Wall -Wextra -Werror ${BOOST_HOME:+-L ${BOOST_HOME}/lib -I ${BOOST_HOME}/include} -L${HOME}/.local/lib -I${HOME}/.local/include -Wl,${BOOST_HOME:+-rpath ${BOOST_HOME}/lib}")))

  (setq org-babel-default-header-args:perl
        '((:results . "output")))

  (setq org-babel-python-command "python3")
#+END_SRC

***** TODO Display errors and warnings in an org-babel code block
From [[http://emacs.stackexchange.com/questions/2952/display-errors-and-warnings-in-an-org-mode-code-block][Emacs StackExchange]]
#+BEGIN_SRC emacs-lisp :tangle no
  (defvar org-babel-eval-verbose t
    "A non-nil value makes `org-babel-eval' display")

  (defun org-babel-eval (cmd body)
    "Run CMD on BODY.
  If CMD succeeds then return its results, otherwise display
  STDERR with `org-babel-eval-error-notify'."
    (let ((err-buff (get-buffer-create " *Org-Babel Error*")) exit-code)
      (with-current-buffer err-buff (erase-buffer))
      (with-temp-buffer
        (insert body)
        (setq exit-code
              (org-babel--shell-command-on-region
               (point-min) (point-max) cmd err-buff))
        (if (or (not (numberp exit-code)) (> exit-code 0)
                (and org-babel-eval-verbose (> (buffer-size err-buff) 0))) ; new condition
            (progn
              (with-current-buffer err-buff
                (org-babel-eval-error-notify exit-code (buffer-string)))
              nil)
          (buffer-string)))))

  (setq org-babel-eval-verbose t)
#+END_SRC

***** Refresh inline images after evaluating org-babel code
From https://emacs.stackexchange.com/a/9813/9690

#+BEGIN_SRC emacs-lisp
  (defun my-fix-inline-images ()
    (when org-inline-image-overlays
      (org-redisplay-inline-images)))

  (add-hook 'org-babel-after-execute-hook 'my-fix-inline-images)
#+END_SRC

***** Jump to head/tail of any block, not just src blocks
:PROPERTIES:
:ID:       964101eb-3077-411d-b9e5-9011c055c4ff
:CREATED:  [2019-01-14 Mon 21:36]
:END:
=org-babel-goto-src-block-head= jumps to the beginning of a source block. This is super useful! Why restrict it only to source blocks?
#+begin_src emacs-lisp
  (defun my-org-babel-goto-block-corner (p)
    "Go to the beginning of the current block.
    If called with a prefix, go to the end of the block"
    (interactive "P")
    (let* ((element (org-element-at-point)))
      (when (or (eq (org-element-type element) 'example-block)
                (eq (org-element-type element) 'src-block) )
        (let ((begin (org-element-property :begin element))
              (end (org-element-property :end element)))
          ;; Ensure point is not on a blank line after the block.
          (beginning-of-line)
          (skip-chars-forward " \r\t\n" end)
          (when (< (point) end)
            (goto-char (if p end begin))
            (when p
              (skip-chars-backward " \r\t\n")
              (beginning-of-line)))))))
#+end_src

**** org-capture
Show hierarchical headlines when refiling instead of flattening it out
Show all the hierarchical headlines instead of having to step down them

From [[http://cestlaz.github.io/posts/using-emacs-23-capture-1][Using Emacs 23 - Capture 1]] and [[http://cestlaz.github.io/posts/using-emacs-24-capture-2][Using Emacs 24 - Capture 2]]

***** Capture templates
:PROPERTIES:
:CREATED:  [2018-12-28 Fri 23:04]
:END:
#+BEGIN_SRC emacs-lisp
  (setq org-capture-templates
        '(("t" "TODO" entry
           (file+headline org-default-notes-file "Inbox")
           "* TODO %?"
           :jump-to-captured t :empty-lines 1)

          ("c" "Misc" entry
           (file+headline org-default-notes-file "Inbox")
           "* %?"
           :jump-to-captured t :empty-lines 1)

          ("s"  "Code snippets")

          ("se" "Emacs snippets" entry (file "Software/emacs.org")
           "* %?"
           :jump-to-captured t :empty-lines 1)

          ("ss" "Shell snippets" entry (file "Software/shell.org")
           "* %?"
           :jump-to-captured t :empty-lines 1)

          ("sv" "Vim snippets" entry (file "Software/vim.org")
           "* %?"
           :jump-to-captured t :empty-lines 1)))
#+END_SRC

NOTE:
- When using several keys, keys using the same prefix key must be sequential in the list and preceded by a 2-element entry explaining the prefix key.
  [[http://orgmode.org/manual/Template-elements.html#Template-elements][Template elements]], [[http://orgmode.org/manual/Template-elements.html#Template-expansion][Template expansion]]
- Quick notes related to current state can be taken using =C-c C-z= and get added to the =LOGBOOK=

***** Add properties to captured items
:PROPERTIES:
:CREATED:  [2018-12-28 Fri 23:04]
:ID:       f9b19f45-ee3a-4f40-b8af-0e5966e4df35
:END:
This adds the CREATED and ID property to all captures
From https://stackoverflow.com/a/16247032/734153
#+BEGIN_SRC emacs-lisp
  (add-hook 'org-capture-prepare-finalize-hook
            (lambda() (org-expiry-insert-created)(org-id-get-create)))
#+END_SRC

***** COMMENT Capture template for learning Spanish
#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-capture-templates '(("l"  "Spanish")

                                        ("ls" "Item" entry
                                         (file+headline "Personal/Spanish.org" "Misc")
                                         "\n* %?%(setq my-spanish-capture (read-string \"Spanish: \")) :drill:%(org-set-property \"DRILL_CARD_TYPE\" \"hide1_firstmore\")\n\nSpanish: [%(message my-spanish-capture)]\nEnglish: [%^{English}]"
                                         :jump-to-captured t :empty-lines 1)

                                        ("ln" "Noun" entry
                                         (file+headline "Personal/Spanish.org" "Nouns")
                                         "\n* %?[%(setq my-spanish-capture (read-string \"Spanish: \"))] :drill:%(org-set-property \"DRILL_CARD_TYPE\" \"twosided\")\n\nTranslate this noun.\n\n** Spanish\n/%(message my-spanish-capture)/\n\n** English\n%^{English}"
                                         :jump-to-captured t :empty-lines 1)

                                        ("lv" "Verb" entry
                                         (file+headline "Personal/Spanish.org" "Verbs")
                                         "\n* %(setq my-spanish-capture (read-string \"Spanish: \")) :drill:%(org-set-property \"DRILL_CARD_TYPE\" \"hide1cloze\")%(org-set-property \"VERB_INFINITIVE\" (concat \"\\\"\" my-spanish-capture \"\\\"\"))%(org-set-property \"VERB_TRANSLATION\" (concat \"\\\"to \" (setq my-english-capture (read-from-minibuffer \"English: to \")) \"\\\"\"))%(org-set-property \"VERB_INFINITIVE_HINT\" (concat \"\\\"\" (substring my-spanish-capture 0 1) \"...\\\"\"))\n\nSpanish: [%(message my-spanish-capture)]\nEnglish: [to %(message my-english-capture)]\n\n** Notes\n** Examples\n** Simple Present Tense :drill:%(org-set-property \"DRILL_CARD_TYPE\" \"conjugate\")%(org-set-property \"VERB_TENSE\" \"\\\"simple present\\\"\")\n\n| yo               | %?  |\n| tú               |   |\n| él/ella/Ud.      |   |\n| nosotros         |   |\n| vosotros         |   |\n| ellos/ellas/Uds. |   |"
                                         :jump-to-captured t :empty-lines 1))
               t)
#+END_SRC

****** TODO Using %^{prompt} in org-capture template doesn't allow specifying accented characters with =C-x 8=
Hence, I'm using a hacky way of explicitly prompting for input (since I can specify accented characters that way),
saving it to a variable and printing it out later in the capture template.

***** TODO Creating TODOs doesn't log it as a state change
***** Create frames for easy org-capture directly from the OS
(credit: [[http://cestlaz.github.io/posts/using-emacs-24-capture-2/][here]])
#+BEGIN_SRC emacs-lisp
  (use-package noflet
    :config
    (defun my-make-capture-frame ()
      "Create a new frame and run org-capture."
      (interactive)
      (select-frame-by-name "capture")
      (delete-other-windows)
      (noflet ((switch-to-buffer-other-window (buf) (switch-to-buffer buf)))
        (counsel-org-capture))))

  (defadvice org-capture-finalize
      (after delete-capture-frame activate)
    "Advise capture-finalize to close the frame"
    (if (equal "capture" (frame-parameter nil 'name))
        (delete-frame)))

  (defadvice org-capture-destroy
      (after delete-capture-frame activate)
    "Advise capture-destroy to close the frame"
    (if (equal "capture" (frame-parameter nil 'name))
        (delete-frame)))
#+END_SRC

This can then be used to create a capture frame
#+BEGIN_EXAMPLE
  emacsclient --create-frame --no-wait --socket-name=capture --frame-parameters='(quote (name . "capture"))' --eval "(my-make-capture-frame)"
#+END_EXAMPLE

*** Keybindings
:PROPERTIES:
:ID:       ebbf9970-d072-4b59-bcaa-5f4b3d71a7d7
:END:
Custom keymap for org-mode bindings.
#+BEGIN_SRC emacs-lisp
  (bind-keys :prefix-map my-org-bindings-map
             :prefix-docstring "This map is used to group together all org-mode settings"
             :prefix "C-c o"
             ("a" . org-agenda)
             ("c" . counsel-org-capture))
  ;; :bind (("c" . calendar))
#+END_SRC

<<Custom timestamp keymap>>. Also see [[id:d4634d95-be37-4bdf-987e-22da5778e958][Using ! to toggle timestamp type]]

#+BEGIN_SRC emacs-lisp
  (bind-key "C-c C-q" 'counsel-org-tag org-mode-map)
#+END_SRC

Note that org-mode usually has the same command mapped to both =<Prefix> [a-z]= and =<Prefix> C-[a-z]=.
In such cases, I can use =<Prefix> [a-z]= to bind to something else and leave =<Prefix> C-[a-z]= alone.
The mnemonic is that Org leaves =C-c [a-z]= free for the user. Thus, I'm using =[a-z]= in other places too.

Delete the result block using =C-c C-v C-k= where =C-c C-v= is the /org-babel-key-prefix/
#+BEGIN_SRC emacs-lisp
  (define-key key-translation-map (kbd "C-c C-v C-k") (kbd "C-c C-v k"))
#+END_SRC

Repurpose =C-c C-v u= to jump to beginning/end of any block. =C-c C-v C-u= is left untouched to only jump to top of src blocks
#+begin_src emacs-lisp
  (bind-key "u" 'my-org-babel-goto-block-corner org-babel-map)
#+end_src

*** /fin/
#+BEGIN_SRC emacs-lisp
  )
#+END_SRC

*** TODO Archive subtrees hierarchically
Archive subtrees under the same hierarchy as the original in the archive files
https://gist.github.com/Fuco1/e86fb5e0a5bb71ceafccedb5ca22fcfb
https://fuco1.github.io/2017-04-20-Archive-subtrees-under-the-same-hierarchy-as-original-in-the-archive-files.html

*** htmlize
Syntax highlighting when exporting to HTML? Yes, please!
#+BEGIN_SRC emacs-lisp
  (use-package htmlize
    :disabled
    :after org)
#+END_SRC

*** org-agenda
#+BEGIN_SRC emacs-lisp
  (use-package org-agenda
    :after org
    :ensure nil
#+END_SRC

**** :init
Don't add some files to the agenda
#+BEGIN_SRC emacs-lisp
  :init
  (setq org-agenda-files
        (seq-filter (lambda (x)
                      (and 'file-exists-p
                           (not (string= "Spanish.org" x))
                           (not (string-match-p "Orgzly" x))))
                    (mapcar (lambda (x) (expand-file-name x org-directory))
                            '("Inbox.org" "Software/" "Personal/" "Work/"))))
#+END_SRC

**** :config
#+BEGIN_SRC emacs-lisp
  :config
  (setq org-agenda-tags-column -120)          ; Monitors are wide, might as well use it :/
  (setq org-agenda-skip-scheduled-if-done t)  ; Why isn't this default?
  (setq org-agenda-skip-deadline-if-done t)
  (setq org-agenda-window-setup 'only-window)
  (setq org-agenda-restore-windows-after-quit t)
#+END_SRC

Show the previous 7 days as well in the agenda. Also, force agenda to start on a Monday.
Hence, these two combined always show entries starting from the previous Monday.
Source: https://old.reddit.com/r/orgmode/comments/8r70oh/make_orgagenda_show_this_month_and_also_previous/
#+BEGIN_SRC emacs-lisp
  (setq org-agenda-start-day "-7d")
  (setq org-agenda-start-on-weekday 1)
#+END_SRC

**** org-agenda custom commands
Based on https://blog.aaronbieber.com/2016/09/24/an-agenda-for-life-with-org-mode.html
#+BEGIN_SRC emacs-lisp
  (defun my-org-skip-subtree-if-habit ()
    "Skip an agenda entry if it has a STYLE property equal to \"habit\"."
    (let ((subtree-end (save-excursion (org-end-of-subtree t))))
      (if (string= (org-entry-get nil "STYLE") "habit")
          subtree-end
        nil)))

  (defun my-org-skip-subtree-if-priority (priority)
    "Skip an agenda subtree if it has a priority of PRIORITY.

  PRIORITY may be one of the characters ?A, ?B, or ?C."
    (let ((subtree-end (save-excursion (org-end-of-subtree t)))
          (pri-value (* 1000 (- org-lowest-priority priority)))
          (pri-current (org-get-priority (thing-at-point 'line t))))
      (if (= pri-value pri-current)
          subtree-end
        nil)))

  (setq org-agenda-custom-commands
        '(("d" "Daily agenda and all TODOs"
           ((tags "PRIORITY=\"A\""
                  ((org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
                   (org-agenda-overriding-header "High-priority unfinished tasks:")))
            (agenda "" ((org-agenda-span 14)))
            (alltodo ""
                     ((org-agenda-skip-function '(or (my-org-skip-subtree-if-habit)
                                                     (my-org-skip-subtree-if-priority ?A)
                                                     (org-agenda-skip-if nil '(scheduled deadline))))
                      (org-agenda-overriding-header "ALL normal priority tasks:"))))
           ((org-agenda-compact-blocks t)))

          ("w" "Daily agenda and all TODOs for Work"
           ((tags "PRIORITY=\"A\""
                  ((org-agenda-tag-filter-preset '("+Work"))
                   (org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
                   (org-agenda-overriding-header "High-priority unfinished tasks:")))
            (agenda "" ((org-agenda-span 14)))
            (alltodo ""
                     ((org-agenda-tag-filter-preset '("+Work"))
                      (org-agenda-skip-function '(or (my-org-skip-subtree-if-habit)
                                                     (my-org-skip-subtree-if-priority ?A)
                                                     (org-agenda-skip-if nil '(scheduled deadline))))
                      (org-agenda-overriding-header "ALL normal priority tasks:"))))
           ((org-agenda-compact-blocks t)))))
#+END_SRC

**** Keybindings
[[id:ebbf9970-d072-4b59-bcaa-5f4b3d71a7d7][General org keybindings]]
#+BEGIN_SRC emacs-lisp
  :config
#+END_SRC

Open the custom "Daily agenda and all TODOs" directly. Based on [[http://emacs.stackexchange.com/a/868/9690][Emacs StackExchange]].
#+BEGIN_SRC emacs-lisp
  (bind-key* "<f12>" '(lambda (&optional arg) (interactive "P")(org-agenda arg "w")))
#+END_SRC

**** /fin/
#+BEGIN_SRC emacs-lisp
  )
#+END_SRC

*** org-bullets
Other bullets to consider:
Default: "◉ ○ ✸ ✿"
Large: ♥ ● ◇ ✚ ✜ ☯ ◆ ♠ ♣ ♦ ☢ ❀ ◆ ◖ ▶
Small: ► • ★ ▸

#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :after org
    :config
    (add-hook 'org-mode-hook (lambda() (org-bullets-mode 1))))
#+END_SRC

A good way to find more characters is to use =M-x insert-char=

*** org-drill
I grab the /org-plus-contrib/ version of org-id to match org. Also look at [[ensure_target]].
#+BEGIN_SRC emacs-lisp
  (use-package org-drill
    :disabled
    :after org
    :ensure org-plus-contrib
    :init
    (setq org-drill-learn-fraction 0.4)
    :config
    (add-to-list 'org-modules 'org-drill)
    (setq org-drill-add-random-noise-to-intervals-p t)
    (setq org-drill-hide-item-headings-p t)

    (use-package org-drill-table
      :disabled
      :load-path "bundle/org-drill-table"))
#+END_SRC

*** org-expiry
This allows me to add a =CREATED= property everytime I create a new org-heading. From [[https://stackoverflow.com/a/13285957/734153][here]].
#+BEGIN_SRC emacs-lisp
  (use-package org-expiry
    :after org
    :ensure org-plus-contrib
    :init
    (setq org-expiry-inactive-timestamps t) ; Don't have everything in the agenda view
    :config
    (org-expiry-insinuate))
#+END_SRC

*** org-id
I grab the /org-plus-contrib/ version of org-id to match org. Also look at [[ensure_target]].
#+BEGIN_SRC emacs-lisp
  (use-package org-id
    :after org
    :ensure org-plus-contrib
    :init
    (setq org-id-link-to-org-use-id 'create-if-interactive-and-no-custom-id)
    :config
#+END_SRC

To effectively use custom ID, refer [[https://writequit.org/articles/emacs-org-mode-generate-ids.html#update-2016-09-07][this]].
Note that =org-id= has been updated since then and now supports a method =org-id-get-create= which creates an ID if one is not present.
Also, it uses the identifier /ID/ instead of /CUSTOM_ID/

**** Automatically add ID to newly created headings
:PROPERTIES:
:CREATED:  [2018-12-28 Fri 23:59]
:END:
#+BEGIN_SRC emacs-lisp
  (add-hook 'org-insert-heading-hook 'org-id-get-create)
#+END_SRC

**** Completion while inserting link
:PROPERTIES:
:ID:       be086bdd-ffcf-4f4e-beb2-a948191895eb
:END:
To use completion, insert link using =C-c C-l= and select =id:= as type and completion should trigger.
=org-id-get-with-outline-path-completion= returns the ID of the selected heading and creates it if it doesn't have one already.
Details at [[http://emacs.stackexchange.com/a/12434/9690][Emacs StackExchange]]
#+BEGIN_SRC emacs-lisp
  (defun org-id-complete-link (&optional arg)
    "Create an id: link using completion"
    (concat "id:" (org-id-get-with-outline-path-completion org-refile-targets)))

  (eval-after-load 'org '(org-link-set-parameters "id" :complete 'org-id-complete-link))
#+END_SRC

**** TODO Use org-id globally across all files
Example on [[http://stackoverflow.com/a/27158715/734153][Emacs StackExchange]]
#+BEGIN_SRC emacs-lisp
  (setq org-id-track-globally t)
  (setq org-id-extra-files '("~/.emacs.d/config.org"))
#+END_SRC

**** /fin/
#+BEGIN_SRC emacs-lisp
  )
#+END_SRC

** pcre2el
From [[https://www.reddit.com/r/emacs/comments/60nb8b/favorite_builtin_emacs_commands/df8h8hm/][/u/Irkry on reddit]]
#+BEGIN_SRC emacs-lisp
  (use-package pcre2el
    :config (pcre-mode t))
#+END_SRC

** popup-kill-ring
Use =M-y= to show a list of all killed/yanked text to paste at the cursor location
#+BEGIN_SRC emacs-lisp
  (use-package popup-kill-ring
    :bind ("M-y" . popup-kill-ring))
#+END_SRC

** rainbow-delimiters
Use brighter colors
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :bind (:map my-settings-toggle-map ("r" . rainbow-delimiters-mode))
    :config
    (set-face-attribute 'rainbow-delimiters-depth-1-face nil :foreground "dark orange")
    (set-face-attribute 'rainbow-delimiters-depth-2-face nil :foreground "deep pink")
    (set-face-attribute 'rainbow-delimiters-depth-3-face nil :foreground "chartreuse")
    (set-face-attribute 'rainbow-delimiters-depth-4-face nil :foreground "deep sky blue")
    (set-face-attribute 'rainbow-delimiters-depth-5-face nil :foreground "yellow")
    (set-face-attribute 'rainbow-delimiters-depth-6-face nil :foreground "orchid")
    (set-face-attribute 'rainbow-delimiters-depth-7-face nil :foreground "spring green")
    (set-face-attribute 'rainbow-delimiters-depth-8-face nil :foreground "sienna1"))
#+END_SRC

** rainbow-mode
When a color is specified as a hex code or with its name, set the background of the face to the value of the color itself
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-mode
    :defer t)
#+END_SRC

** undo-tree
This lets us visually walk through the changes we've made, undo back to a certain point (or redo), and go down different branches.
Default binding is =C-x u=
#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :bind (:map my-settings-enable-map
                ("U" . undo-tree-visualize)
           :map my-settings-disable-map
                ("U" . undo-tree-visualizer-quit))
    :custom
    (undo-tree-visualizer-timestamps t)
    (undo-tree-visualizer-diff t))
#+END_SRC

** which-key
Shows which keys can be pressed next.
eg. if you press =C-x= and wait a few seconds, a window pops up with all the key bindings following the currently entered incomplete command.
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :config (which-key-mode))
#+END_SRC

** yasnippet
Use =C-d= to clear the field without accepting the default field name

#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :commands (yas-reload-all yas-minor-mode)
    :init
    (add-hook 'c++-mode-hook (lambda() (yas-reload-all)(yas-minor-mode)))
    (setq-default yas-snippet-dirs (list (concat user-emacs-directory "snippets")))
    (setq yas-wrap-around-region t)  ; Automatically insert selected text at $0, if any
    :config
    (bind-keys :map yas-minor-mode-map
               ("C-c & n" . yas-new-snippet)
               ("C-c & s" . yas-insert-snippet)
               ("C-c & v" . yas-visit-snippet-file)
               ("C-c & r" . yas-reload-all)
               ("C-c & &" . yas-describe-tables)))
#+END_SRC

NOTE:
- Normally, I would've used =:hook= to defer loading. However, just running =yas-minor-mode= isn't sufficient and yasnippet
  requires that I run =yas-reload-all= before it. As a result, I've to do it in a round-about manner by adding a hook.
- I can't use =:bind= here to defer loading because I'm adding bindings to a map which doesn't exist till the plugin is loaded.
  I could use =:bind-keymap= here instead but as explained above, I need to do =yas-reload-all= as well and I don't know how to do that with =:bind-keymap=.
  Also, I want to avoid confusion when I read this 3 months later wondering how it works.

** delight
Placing at end to be called after all packages are loaded
#+BEGIN_SRC emacs-lisp
  (use-package delight
    :config
    (delight '((abbrev-mode nil t)
               (aggressive-indent-mode nil aggressive-indent)
               (beacon-mode nil beacon)
               (company-mode nil company)
               (flycheck-mode nil flycheck)
               (irony-mode nil irony)
               (ivy-mode nil ivy)
               (org-indent-mode nil org-indent)
               (pcre-mode nil pcre2el)
               (rainbow-mode)
               (undo-tree-mode nil undo-tree)
               (yas-minor-mode nil yasnippet)
               (which-key-mode nil which-key))))
#+END_SRC

* After
** Private config #+BEGIN_SRC emacs-lisp (when (string-match-p "atlibex" (system-name)) (load (expand-file-name "private_work.el" user-emacs-directory) t)) #+END_SRC
** File-local variables
Use =add-file-local-variable= or =add-file-local-variable-prop-line= instead of adding these manually

# Local Variables:
# org-refile-targets: ((nil :maxlevel . 9))
# End:

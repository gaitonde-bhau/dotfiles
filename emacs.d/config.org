#+TITLE: Emacs Configuration
#+PROPERTY: header-args :results value silent

* Init
:PROPERTIES:
:header-args: :tangle yes
:END:
** Archives
/package-archives/ uses HTTP access to GNU by default. Replacing it with the https version instead
#+BEGIN_SRC emacs-lisp
  (setq package-archives '(("repo-gnu"   . "https://elpa.gnu.org/packages/")
                           ("repo-melpa" . "https://melpa.milkbox.net/packages/")
                           ("repo-org"   . "http://orgmode.org/elpa/")))

  (when (>= emacs-major-version 24)
    (when (>= emacs-minor-version 4)
      (setq load-prefer-newer t))
    (require 'package))

  (package-initialize)
#+END_SRC

** use-package
[[https://www.youtube.com/watch?v%3D2TSKxxYEbII][use-package video tutorial]]

Install and load use-package
#+BEGIN_SRC emacs-lisp
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  (eval-and-compile
    (defvar use-package-verbose t)
    (require 'use-package)
    (require 'bind-key)
    (require 'diminish)
    (setq use-package-always-ensure t)
    (if (daemonp)
        (setq use-package-always-demand t)))

  (bind-key* "C-h B" 'describe-personal-keybindings)
#+END_SRC

** TODO Check if there's a way to keep all the config in this file itself with init.el being empty
Sacha Chua seems to have something like that. Her init.el is simply a link.
Maybe some information in this [[https://www.reddit.com/r/emacs/comments/4uo9r0/shaving_time_on_emacs_startup_from_org_literate/][reddit thread]].

* Visual
:PROPERTIES:
:header-args: :tangle yes
:END:
#+BEGIN_SRC emacs-lisp
  ;; Disable anoying beep
  (setq ring-bell-function 'ignore)

  ;; Improve rendering performance
  (setq redisplay-dont-pause t)

  ;; Display a special glyph in the fringe of each empty line at the end of the buffer
  (setq indicate-empty-lines t)
#+END_SRC

** Frame related
Set size of default frame
#+BEGIN_SRC emacs-lisp
  (setq default-frame-alist
        '((top    . 0)
          (left   . 0)
          (width  . 237)
          (height . 66)))
#+END_SRC

Start maximized
#+BEGIN_SRC emacs-lisp
  ;; Open in fullscreen
  (defun my/switch-fullscreen nil
    "Switch to fullscreen. Works in OSX."
    (interactive)
    (let* ((modes '(nil fullboth fullwidth fullheight))
           (cm (cdr (assoc 'fullscreen (frame-parameters))))
           (next (cadr (member cm modes))))
      (modify-frame-parameters
       (selected-frame)
       (list (cons 'fullscreen next)))))
  ;; (my/switch-fullscreen)

  ;; Start maximized
  ;; (custom-set-variables '(initial-frame-alist (quote ((fullscreen . maximized)))))
#+END_SRC

Transparency
#+BEGIN_SRC emacs-lisp
  ;; (set-frame-parameter (selected-frame) 'alpha '(85 85))
  ;; (add-to-list 'default-frame-alist '(alpha 85 85))
#+END_SRC

Avoid Emacs hanging for a while after changing default font:
#+BEGIN_SRC emacs-lisp
  ;; (modify-frame-parameters nil '((wait-for-wm . nil)))
#+END_SRC

*** TODO Set frame size based on home/work

** Clean-up
#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-message t)
  (setq initial-scratch-message "")

  (menu-bar-mode -1)
  ;; (tooltip-mode -1)
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
#+END_SRC

We can also put something like this into =~/.Xresources= to enable/disable certain things as soon as Emacs starts
#+BEGIN_EXAMPLE
Emacs.verticalScrollBars: off
Emacs.toolBar: off
#+END_EXAMPLE

** Mode line
#+BEGIN_SRC emacs-lisp
  ;; Show column number in bottom bar
  (setq column-number-mode t)
#+END_SRC

* General
:PROPERTIES:
:header-args: :tangle yes
:END:
** Keybinds
By default =C-x == is bound to /what-cursor-position/ but evil maps both =ga= and =g8= to that as well so might as well use it to show something useful.
#+BEGIN_SRC emacs-lisp
  (bind-key* "C-x =" 'describe-char)
#+end_src

#+begin_src emacs-lisp
  (defun my/revert-buffer-no-confirm ()
    "Revert buffer without confirmation."
    (interactive)
    (revert-buffer :ignore-auto :noconfirm))

  (bind-key* "<f5>" 'my/revert-buffer-no-confirm)
#+END_SRC

*** Enable/Disable/Toggle ala vim-unimpaired
I think the following would be handy
  =[= - Enable setting
  =~= - Toggle setting
  =]= - Disable setting

#+BEGIN_SRC emacs-lisp
  (bind-keys* :prefix-map emacs-unimpaired-enable-map
              :prefix-docstring "This map is used to enable settings ala vim-unimpaired"
              :prefix "C-c [")
  (bind-keys* :prefix-map emacs-unimpaired-disable-map
              :prefix-docstring "This map is used to disable settings ala vim-unimpaired"
              :prefix "C-c ]")
  (bind-keys* :prefix-map emacs-unimpaired-toggle-map
              :prefix-docstring "This map is used to toggle settings ala vim-unimpaired"
              :prefix "C-c ~")
#+END_SRC
Note the use of /bind-keys*/. This is because /bind-keys*/ will override any maps that are defined by any modes.
Since =C-c [=, =C-c ~= and  =C-c ]= are all defined by org-mode, I want to override those definitions and hence put mine in the /override-global-mode/
Note that since /bind-keys*/ puts everything in the /override-global-mode/ map, it essentially ignores any =:map= that is passed to it.
Thus, once the prefixes and maps are defined, we have to use /bind-keys/ only to create new keybinds inside them.

*** Substitution map
#+BEGIN_SRC emacs-lisp
  (bind-keys :prefix-map my-s-bindings-map
             :prefix-docstring "This map is used to group together all substitution related bindings"
             :prefix "C-c s")
#+END_SRC

** Custom file
#+BEGIN_SRC emacs-lisp
  (setq custom-file (concat user-emacs-directory "custom.el"))
  (load custom-file)
#+END_SRC

** Backup
#+BEGIN_SRC emacs-lisp
  (defvar backup-directory (concat user-emacs-directory "/tmp/backups"))
  (if (not (file-exists-p backup-directory)) (make-directory backup-directory t))
  (setq backup-directory-alist `(("." . ,backup-directory)))
  (setq make-backup-files         t)  ; backup of a file the first time it is saved.
  (setq backup-by-copying         t)  ; don't clobber symlinks
  (setq version-control           t)  ; version numbers for backup files
  (setq delete-old-versions       t)  ; delete excess backup files silently
  (setq delete-by-moving-to-trash t)
  (setq kept-old-versions         6)  ; oldest versions to keep when a new numbered backup is made (default: 2)
  (setq kept-new-versions         9)  ; newest versions to keep when a new numbered backup is made (default: 2)
#+END_SRC

** Autosave
#+BEGIN_SRC emacs-lisp
  (defvar autosave-directory (concat user-emacs-directory "/tmp/autosaves"))
  (if (not (file-exists-p autosave-directory)) (make-directory autosave-directory t))
  (setq auto-save-file-name-transforms `(("." ,autosave-directory t)))
  (setq auto-save-default t)  ; auto-save every buffer that visits a file
#+END_SRC

** History
Delete identical history entries
#+BEGIN_SRC emacs-lisp
(setq history-delete-duplicates t)
#+END_SRC

Save mini-buffer history
#+BEGIN_SRC emacs-lisp
  (use-package savehist
    :init
    (setq savehist-file (concat user-emacs-directory "tmp/history.el")
          history-length 100)
    :config
    (savehist-mode t))
#+END_SRC

** UTF-8 Please
#+BEGIN_SRC emacs-lisp
  (setq locale-coding-system   'utf-8)
  (set-terminal-coding-system  'utf-8)
  (set-keyboard-coding-system  'utf-8)
  (set-selection-coding-system 'utf-8)
  (set-language-environment    "UTF-8")
  (prefer-coding-system        'utf-8)
#+END_SRC

** TODO Fonts
:PROPERTIES:
:ID:       bd542328-7d1d-4806-936d-a50673beada6
:END:
The reason for adding the hook is that if I try to create a daemon, it errors out with
    /error: Window system is not in use or not initialized/
This is because we try to set a face-attribute before a frame is created which is a no-no for some reason.

However, the downside to this is that if I have multiple such 'when' sections (like in private.el) we can't dictate the order in which they're applied.
#+BEGIN_SRC emacs-lisp
  (defun my/set-font-exists (font size)
    " Check if font exists and set if it does"
    (let ((font (concat font "-" (if (numberp size)
                                     (number-to-string size)
                                   size))))
      (when (x-list-fonts font)
        (setq my-variable-pitch-font font
              my-fixed-pitch-font    font))))

  (add-hook 'after-make-frame-functions
            (lambda (frame)
              (select-frame frame)
              (when (eq system-type 'gnu/linux)
                (my/set-font-exists "DejaVu Sans Mono" "11"))
              (when (eq system-type 'windows-nt)
                (my/set-font-exists "Consolas" "10"))
              (my/set-font-exists "Hack" "10")
              (set-face-attribute 'default        nil :font my-variable-pitch-font)
              (set-face-attribute 'fixed-pitch    nil :font my-fixed-pitch-font)
              (set-face-attribute 'variable-pitch nil :font my-variable-pitch-font)))

  ;; (my/set-font-exists "Hack" "10")
  ;; (set-face-attribute 'default        nil :font my-variable-pitch-font)
  ;; (set-face-attribute 'fixed-pitch    nil :font my-fixed-pitch-font)
  ;; (set-face-attribute 'variable-pitch nil :font my-variable-pitch-font))
#+END_SRC

Fall back to DejaVu Sans when the font lacks support for some glyphs. Taken from [[https://github.com/joodie/emacs-literal-config/blob/c66e30ce961b140dd3e84116f4d45cbc19d0d944/emacs.org#font][github:joodie]]
How does this work? What is it supposed to do?
#+BEGIN_SRC emacs-lisp :tangle no
  (when (functionp 'set-fontset-font)
    (set-fontset-font "fontset-default" 'unicode
                      (font-spec :family "DejaVu Sans Mono"
                                 :width 'normal
                                 :size 11
                                 :weight 'normal)))
#+END_SRC

Scale font size using =C-x C-+= and =C-x C--=. =C-x C-0= resets it.
=text-scale-mode-step= controls the scaling factor. For obvious reasons, don't set it to 1 else it won't change at all
#+BEGIN_SRC emacs-lisp
  (setq text-scale-mode-step 1.1)
  (setq line-spacing 2)
#+END_SRC

** Tabs, Indentation and Spacing
Use only spaces and no tabs
#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
  (setq-default tab-width 2)
  (setq-default show-trailing-whitespace t)

  ;; (bind-key "RET" 'newline-and-indent)
#+end_src
Since these are buffer-local variables, I have to use =setq-default=

*** Enable/Disable/Toggle Trailing whitespace
#+BEGIN_SRC emacs-lisp
  (defun my/toggle-trailing-whitespace ()
    "Toggle trailing whitespace"
    (interactive)  ; Allows to be called as a command via M-x
    (setq-default show-trailing-whitespace (not show-trailing-whitespace)))

  (bind-keys :map emacs-unimpaired-enable-map
             ("SPC" . (lambda () (interactive)(setq-default show-trailing-whitespace t)))
             :map emacs-unimpaired-disable-map
             ("SPC" . (lambda () (interactive)(setq-default show-trailing-whitespace nil)))
             :map emacs-unimpaired-toggle-map
             ("SPC" . my/toggle-trailing-whitespace))
#+END_SRC

*** Delete trailing whitespace
From [[https://www.emacswiki.org/emacs/DeletingWhitespace#toc3][emacswiki:]]
#+BEGIN_SRC emacs-lisp
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC

Use =C-c s SPC= to delete trailing whitespace manually
#+BEGIN_SRC emacs-lisp
  (bind-keys :map my-s-bindings-map
             ("SPC" . delete-trailing-whitespace))
#+END_SRC

*** Toggle wrap
#+BEGIN_SRC emacs-lisp
  (bind-key "w" 'toggle-truncate-lines emacs-unimpaired-toggle-map)
#+END_SRC

** Highlight current line
#+BEGIN_SRC emacs-lisp
  ;; (global-hl-line-mode 1)
  (bind-key "c" 'global-hl-line-mode emacs-unimpaired-toggle-map)
#+END_SRC

*** TODO FIXME
#+BEGIN_SRC emacs-lisp
  (bind-key "c" (global-hl-line-mode 1)  emacs-unimpaired-enable-map)
  (bind-key "c" (global-hl-line-mode -1) emacs-unimpaired-disable-map)
#+END_SRC

** Simpler y/n answers
#+BEGIN_SRC emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Matching Parens
#+BEGIN_SRC emacs-lisp
  (show-paren-mode 1)
  (setq show-paren-delay 0)
  ;; (setq show-paren-style 'expression)
#+END_SRC

** Misc
#+BEGIN_SRC emacs-lisp
  ;; Count 1 space after a period as the end of a sentence, instead of 2
  (setq sentence-end-double-space nil)

  ;; Enable editing by visual lines
  (global-visual-line-mode t)
  (diminish 'visual-line-mode)

  ;; Let emacs react faster to keystrokes
  (setq echo-keystrokes 0.1)
  (setq idle-update-delay 0.35)

  ;; Jump to the help window when it's opened.
  ;; Press q to close it and restore the view to the previous buffer
  (setq help-window-select t)

  ;; Confirm before quitting - sometimes I fat-finger and press both C-x C-c instead of just C-c
  (setq confirm-kill-emacs 'y-or-n-p)
#+END_SRC

** Winner mode
Undo and Redo changes in window configuration. Use =C-c right= and =C-c left= to switch between different layouts.
This is useful when I close a window by mistake to undo it and restore the window layout.
#+BEGIN_SRC emacs-lisp
  (winner-mode 1)
#+END_SRC

** Theme Directories
#+BEGIN_SRC emacs-lisp
  (add-to-list 'custom-theme-load-path (concat user-emacs-directory "/themes"))
  (add-to-list 'load-path (concat user-emacs-directory "/themes"))
#+END_SRC

** Emacs server
- Always start the emacs-server, except when run in daemon mode
- Already Disable prompt asking you if you want to kill a buffer with a live process attached to it.
  http://stackoverflow.com/questions/268088/how-to-remove-the-prompt-for-killing-emacsclient-buffers

#+BEGIN_SRC emacs-lisp
  (use-package server
    :disabled
    :config
    (unless (or (daemonp) (server-running-p))
      (server-mode 1))
    (add-hook 'server-switch-hook 'raise-frame))
#+END_SRC

Alias for emacsclient:
This will launch emacsclient if a server is already running and launch emacs if not
#+BEGIN_EXAMPLE
  alias e='emacsclient --alternate-editor="emacs" --create-frame --quiet'
#+END_EXAMPLE

** Mouse
Mouse-wheel acts on the hovered window rather than the one where the typing focus is
#+BEGIN_SRC emacs-lisp
  (setq mouse-wheel-follow-mouse t)
#+END_SRC

** TODO Scratch
Mode-specific scratch buffers?

* Packages
:PROPERTIES:
:header-args: :tangle yes
:END:
** ace-window
When more than 2 windows are open, show a home-row character to in each window to jump directly to.
Similar to Tmux's =<prefix> C-g=
#+BEGIN_SRC emacs-lisp
  (use-package ace-window
    :init
    (setq aw-background t)
    (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j? ?k? ?l))
    :config
    (set-face-attribute 'aw-leading-char-face nil :foreground "red" :height 2.5)
    :bind ("C-x o" . ace-window))
#+END_SRC

Note that we're rebinding =C-x o=

** aggressive-indent
#+BEGIN_SRC emacs-lisp
  (use-package aggressive-indent
    :config
    (global-aggressive-indent-mode t))
#+END_SRC

** auto-complete
Completion doesn't work if evil is installed

#+BEGIN_SRC emacs-lisp
  (use-package auto-complete
    :init
    (progn (ac-config-default)
           (global-auto-complete-mode t)))
#+END_SRC

** evil
evil can be toggled using =C-z=

#+BEGIN_SRC emacs-lisp
  (use-package evil
    ;; :disabled
    :init
    ;; (setq evil-want-C-u-scroll t)
    (setq evil-want-C-w-in-emacs-state t)
    (setq evil-want-Y-yank-to-eol t)

    (evil-mode t)
#+END_SRC

*** :config
#+BEGIN_SRC emacs-lisp
  :config
#+END_SRC

**** evil-commentary
#+BEGIN_SRC emacs-lisp
  (use-package evil-commentary
    :diminish evil-commentary-mode
    :config (evil-commentary-mode))
#+END_SRC

**** evil-surround
#+BEGIN_SRC emacs-lisp
  (use-package evil-surround
    :config (global-evil-surround-mode))
#+END_SRC

**** evil-visualstar
#+BEGIN_SRC emacs-lisp
  (use-package evil-visualstar
    :config (global-evil-visualstar-mode))
#+END_SRC

**** evil-exchange
#+BEGIN_SRC emacs-lisp
  (use-package evil-exchange
    :config (evil-exchange-cx-install))
#+END_SRC

**** evil-matchit
#+BEGIN_SRC emacs-lisp
  (use-package evil-matchit)
#+END_SRC

**** Keybinds
Make /Escape/ quit everything
#+BEGIN_SRC emacs-lisp
  (defun my/minibuffer-keyboard-quit ()
    "Abort recursive edit.
          In Delete Selection mode, if the mark is active, just deactivate it;
          then it takes a second ESC to abort the minibuffer."
    (interactive)
    (if (and delete-selection-mode transient-mark-mode mark-active)
        (setq deactivate-mark  t)
      (when (get-buffer "*Completions*") (delete-windows-on "*Completions*"))
      (abort-recursive-edit)))

  (bind-key [escape] 'keyboard-quit            evil-normal-state-map          )
  (bind-key [escape] 'keyboard-quit            evil-visual-state-map          )
  (bind-key [escape] 'minibuffer-keyboard-quit minibuffer-local-map           )
  (bind-key [escape] 'minibuffer-keyboard-quit minibuffer-local-ns-map        )
  (bind-key [escape] 'minibuffer-keyboard-quit minibuffer-local-completion-map)
  (bind-key [escape] 'minibuffer-keyboard-quit minibuffer-local-must-match-map)
  (bind-key [escape] 'minibuffer-keyboard-quit minibuffer-local-isearch-map   )
#+END_SRC

#+BEGIN_SRC emacs-lisp
  ;; (bind-key "g a" 'describe-char evil-normal-state-map)
  (bind-key "U" 'redo evil-normal-state-map)
  (bind-key "] SPC" '(lambda () (interactive)(end-of-line)(newline))           evil-normal-state-map)
  (bind-key "[ SPC" '(lambda () (interactive)(beginning-of-line)(open-line 1)) evil-normal-state-map)
#+END_SRC

*** END
#+BEGIN_SRC emacs-lisp
)
#+END_SRC

** avy
Similar to vim's easy-motion plugin
#+BEGIN_SRC emacs-lisp
  (use-package avy
    :bind (:map evil-normal-state-map
                ("g s" . avy-goto-char)))
#+END_SRC

** flycheck
#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :disabled
    :diminish flycheck-mode
    :init (global-flycheck-mode t)
    :config
    (use-package flycheck-sml
      :ensure nil
      :load-path "bundle/flycheck-sml/"))
#+END_SRC

** helm
[[http://tuhdo.github.io/helm-intro.html][Introduction to Helm by reddit:/u/tuhdo]]

#+BEGIN_SRC emacs-lisp
  (use-package helm
    ;; :disabled
    :diminish helm-mode
#+END_SRC

*** :init
#+BEGIN_SRC emacs-lisp
  :init
  (require 'helm-config)

  (setq helm-quick-update                     t   )
  (setq helm-idle-delay                       0.0 )
  (setq helm-input-idle-delay                 0.01)
  (setq helm-split-window-in-side-p           t   )  ; open helm buffer inside current window, not occupy whole other window
  (setq helm-move-to-line-cycle-in-source     t   )  ; move to end or beginning of source when reaching top or bottom of source
  (setq helm-display-header-line              nil )  ; Disable the header

  (setq helm-M-x-fuzzy-match                  t   )
  (setq helm-apropos-fuzzy-match              t   )
  (setq helm-buffers-fuzzy-matching           t   )
  (setq helm-completion-in-region-fuzzy-match t   )
  (setq helm-imenu-fuzzy-match                t   )
  (setq helm-lisp-fuzzy-completion            t   )
  (setq helm-locate-fuzzy-match               t   )
  (setq helm-mode-fuzzy-match                 t   )
  (setq helm-recentf-fuzzy-match              t   )
  (setq helm-semantic-fuzzy-match             t   )

  (helm-mode t)
  (helm-autoresize-mode t)
  (semantic-mode t)
#+END_SRC

*** :config
#+BEGIN_SRC emacs-lisp
  :config
#+END_SRC

**** Remove sub-headers line if only a single source; keep them for multiple sources
#+BEGIN_SRC emacs-lisp
  (defvar helm-source-header-default-background (face-attribute 'helm-source-header :background))
  (defvar helm-source-header-default-foreground (face-attribute 'helm-source-header :foreground))
  (defvar helm-source-header-default-box        (face-attribute 'helm-source-header :box))

  (defun helm-toggle-header-line ()
    (if (> (length helm-sources) 1)
        (set-face-attribute 'helm-source-header nil
                            :foreground helm-source-header-default-foreground
                            :background helm-source-header-default-background
                            :box helm-source-header-default-box
                            :height 1.0)
      (set-face-attribute 'helm-source-header nil
                          :foreground (face-attribute 'helm-selection :background)
                          :background (face-attribute 'helm-selection :background)
                          :box nil
                          :height 0.1)))
  (add-hook 'helm-before-initialize-hook 'helm-toggle-header-line)
#+END_SRC

**** helm-descbinds
#+BEGIN_SRC emacs-lisp
  (use-package helm-descbinds
    :init (helm-descbinds-mode t))
#+END_SRC

Note that helm-descbinds will replace the default /describe-bindings/.
Thus =C-h b= can be used for it; no need to create a new binding.

**** helm-projectile
#+BEGIN_SRC emacs-lisp
  (use-package helm-projectile
    :config
    (helm-projectile-on))
#+END_SRC

*** Keybinds
Remove the default prefix =C-x c=. Note this is still a part of :config
#+BEGIN_SRC emacs-lisp
  (unbind-key "C-x c")
#+END_SRC

This allows us to create new custom bindings within helm's default map thereby allowing us to use the default keybindings as well
We redefine /helm-command-prefix/ here
#+BEGIN_SRC emacs-lisp
  :bind* (("M-x"   . helm-M-x)
          ("C-h a" . helm-apropos))

  :bind (("C-c j" . helm-command-prefix)
         :map       helm-command-map
         ("b"     . helm-buffers-list)
         ("f"     . helm-find-files)    ; Find files in the current directory
         ("m"     . helm-mini)          ; m - mixed
         ("p"     . helm-projectile)
         ("/"     . helm-occur))        ; search in all open buffers
#+END_SRC

=C-x C-s= can be used after =helm-occur= to save the results to a buffer.

Other useful default keybinds:
|--------------+-----------------------------+-----------------------------------------------------------|
| <prefix> a   | helm-apropos                | Combination of describe-function, variable, commands etc. |
| <prefix> i   | helm-semantic-or-imenu      | Similar to outline mode (in vim)                          |
| <prefix> o   | helm-org-in-buffer-headings | Jump to org section heading                               |
| <prefix> r   | helm-regexp                 | Construct a regexp                                        |
| <prefix> C-, | helm-calcul-expression      | Interface to calc command                                 |
| C-x r b      | helm-filtered-bookmarks     |                                                           |
|--------------+-----------------------------+-----------------------------------------------------------|

*** use-package END
#+BEGIN_SRC emacs-lisp
)
#+END_SRC

** org
This solution is by [[https://www.reddit.com/r/emacs/comments/5sx7j0/how_do_i_get_usepackage_to_ignore_the_bundled/ddixpr9/][/u/Wolfer1ne on reddit]].
#+BEGIN_SRC emacs-lisp
  (use-package org
    :ensure org-plus-contrib
    :pin repo-org
#+END_SRC

Passing an argument to =:ensure= (other than t or nil) allows us to use a different package than the one named in use-package
Also, using =:pin= allows us to prefer which package-archive we'd like to use to download the package from.
I don't remember why we need to specifically grab =org-plus-contrib= from the org repository instead of from one of the other ones.

*** :init
#+BEGIN_SRC emacs-lisp
  :init
  (setq org-indent-mode t)

  (setq org-directory "~/Notes/")
  (setq org-default-notes-file (concat org-directory "organizer.org"))

  (setq org-M-RET-may-split-line '((item) (default . t)))
  (setq org-log-done 'time) ; 'time/'note
  ;; (setq org-special-ctrl-a/e t)
  ;; (setq org-return-follows-link nil)
  (setq org-use-speed-commands nil)
  ;; (setq org-speed-commands-user nil)
  (setq org-startup-align-all-tables nil)
  ;; (setq org-log-into-drawer nil)
  (setq org-use-property-inheritance t)
  (setq org-tags-column -80)
  (setq org-hide-emphasis-markers t)  ; Hide markers for bold/italics etc.
  (setq org-blank-before-new-entry '((heading . t) (plain-list-item . nil)))
  (setq org-link-search-must-match-exact-headline nil)
  (setq org-startup-with-inline-images t)
  (setq org-imenu-depth 10)
#+END_SRC

**** org-babel source blocks
Enable syntax highlighting within the source blocks and keep the editing popup window within the same window.
Also, strip leading and trailing empty lines if any.
/org-src-preserve-indentation/ will not add an extra level of indentation to the source code
#+BEGIN_SRC emacs-lisp
  (setq org-src-fontify-natively                       t
        org-src-window-setup                           'current-window
        org-src-strip-leading-and-trailing-blank-lines t
        ;; org-src-preserve-indentation                t
        org-src-tab-acts-natively                      t)
#+end_src

Languages which can be evaluated in Org-mode buffers.
#+begin_src emacs-lisp
  (org-babel-do-load-languages 'org-babel-load-languages
                               (append org-babel-load-languages
                                       '((python     . t)
                                         (ruby       . t)
                                         (perl       . t)
                                         (sh         . t)
                                         (C          . t))))
#+end_src

Ask for confirmation before evaluating? NO!
On second thought it's better not to do this because of the security implications.
A safer way to go about it is by enabling it on a file-by-file basis using the following modeline
#+BEGIN_EXAMPLE
  -*- org-confirm-babel-evaluate: nil -*-
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp :tangle no
  (defun my/org-babel-evaluate-silent (lang body)
    "Do not ask for confirmation to evaluate these languages."
    (not (or (string= lang "emacs-lisp"))))

  (setq org-confirm-babel-evaluate 'my/org-babel-evaluate-silent)
  ;; (setq org-confirm-babel-evaluate nil)
#+END_SRC

**** Clean View
#+BEGIN_SRC emacs-lisp
  (setq org-startup-indented t)
  (setq org-hide-leading-stars t)
  (setq org-odd-level-only nil)

  ;; …▼•
  ;; (setq org-ellipsis "▼") ; Use a fancy arrow to indicate a fold instead of '...'
#+END_SRC

***** TODO Hide the < and > around targets
:LOGBOOK:
- State "TODO"       from              [2017-03-19 Sun 15:00]
:END:
From [[http://emacs.stackexchange.com/a/19239/9690][Emacs StackExchange]]
At the moment, it hides not just the angle braces but also the text between them.
#+BEGIN_SRC emacs-lisp :tangle no
  (defcustom org-hidden-links-additional-re "<<[<]?[[:alnum:]]+>>[>]?"
    "Regular expression that matches strings where the invisible-property is set to org-link."
    :type '(choice (const :tag "Off" nil) regexp)
    :group 'org-link)
  (make-variable-buffer-local 'org-hidden-links-additional-re)

  (defun org-activate-hidden-links-additional (limit)
    "Put invisible-property org-link on strings matching `org-hide-links-additional-re'."
    (if org-hidden-links-additional-re
        (re-search-forward org-hidden-links-additional-re limit t)
      (goto-char limit)
      nil))

  (add-hook 'org-font-lock-set-keywords-hook (lambda ()
                           (add-to-list 'org-font-lock-extra-keywords
                                '(org-activate-hidden-links-additional
                                  (0 '(face org-target invisible org-link))))))
#+END_SRC

***** TODO Show the emphasis and target markers on point
#+BEGIN_SRC emacs-lisp :tangle no
  (defun org-show-emphasis-markers-at-point ()
    (save-match-data
      (if (and (org-in-regexp org-emph-re 2)
           (>= (point) (match-beginning 3))
           (<= (point) (match-end 4))
           (member (match-string 3) (mapcar 'car org-emphasis-alist)))
      (with-silent-modifications
        (remove-text-properties
         (match-beginning 3) (match-beginning 5)
         '(invisible org-link)))
        (apply 'font-lock-flush (list (match-beginning 3) (match-beginning 5))))))

  (add-hook 'post-command-hook 'org-show-emphasis-markers-at-point nil t)
#+END_SRC

**** ToDo States
Add logging when task state changes
#+BEGIN_SRC emacs-lisp
  (setq org-log-done nil)
  (setq org-log-into-drawer t)  ; Save state changes into LOGBOOK drawer instead of in the body
  (setq org-treat-insert-todo-heading-as-state-change t)
#+END_SRC

Custom keywords
#+BEGIN_SRC emacs-lisp
  (setq org-todo-keywords '((sequence "TODO(t!)" "WAITING(w@/!)" "|" "DONE(d!)" "CANCEL(c@)")))
  ;; (setq org-todo-keyword-faces
  ;;       (quote (("TODO" :foreground "red" :weight bold)
  ;;               ("WAITING" :foreground "orange" :weight bold)
  ;;               ("DONE" :foreground "forest green" bold)
  ;;               ("CANCEL" :foreground "forest green" bold))))
#+END_SRC
=!= - Log timestamp
=@= - Log timestamp and note
Refer [[http://orgmode.org/manual/Tracking-TODO-state-changes.html][Tracking-TODO-state-changes]] for details

Change from any todo state to any other state using =C-c C-t KEY=
#+BEGIN_SRC emacs-lisp
  (setq org-use-fast-todo-selection t)
#+END_SRC

This frees up S-left and S-right which I can then use to cycles through the todo states but skip setting timestamps and entering notes which is very convenient when all I want to do is fix up the status of an entry.
#+BEGIN_SRC emacs-lisp
  (setq org-treat-S-cursor-todo-selection-as-state-change nil)
#+END_SRC

*** :config
#+BEGIN_SRC emacs-lisp
  :config
  (eval-after-load 'org-indent '(diminish org-indent-mode))
#+END_SRC

**** Make org-mode play nicely with Google Chrome
From [[http://stackoverflow.com/a/6309985/734153][StackOverflow]]
#+BEGIN_SRC emacs-lisp
  (setq browse-url-browser-function 'browse-url-generic
        browse-url-generic-program  "google-chrome")
#+END_SRC

**** Templates
#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-structure-template-alist
               '("sl" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC\n" "<src lang=\"?\">\n\n</src>"))
#+END_SRC

**** Fonts
Variable pitch for non-code text taken from [[http://www.xiangji.me/2015/07/13/a-few-of-my-org-mode-customizations][here]].
#+BEGIN_SRC emacs-lisp
  (defun my/set-buffer-variable-pitch ()
    (interactive)
    (variable-pitch-mode t)
    (setq line-spacing 3)
    (set-face-attribute 'org-table nil :inherit 'fixed-pitch)
    (set-face-attribute 'org-code  nil :inherit 'fixed-pitch)
    (set-face-attribute 'org-block nil :inherit 'fixed-pitch))

  ;; (add-hook 'org-mode-hook      'my/set-buffer-variable-pitch)
  ;; (add-hook 'eww-mode-hook      'my/set-buffer-variable-pitch)
  ;; (add-hook 'markdown-mode-hook 'my/set-buffer-variable-pitch)
  ;; (add-hook 'Info-mode-hook     'my/set-buffer-variable-pitch)
#+END_SRC

NOTE: =org-block-background= has been removed in Org 8.3.1 and from 9.0.0,
has been completely deprecated and it inherits from =org-block=

General configuration [[id:bd542328-7d1d-4806-936d-a50673beada6][here]]

**** Delete links
This is the counterpart to =org-insert-link=. From [[http://emacs.stackexchange.com/a/10714/9690][here]].
#+BEGIN_SRC emacs-lisp
  (defun my/org-replace-link-with-description ()
    "Replace an org link with its description. If a description doesn't exist, replace with its address"
    (interactive)
    (if (org-in-regexp org-bracket-link-regexp 1)
        (let ((remove (list (match-beginning 0) (match-end 0)))
              (description (if (match-end 3)
                               (org-match-string-no-properties 3)
                             (org-match-string-no-properties 1))))
          (apply 'delete-region remove)
          (insert description))))
#+END_SRC

**** Complete multiple org tags
From [[https://blog.aaronbieber.com/2016/03/05/playing-tag-in-org-mode.html][Aaron Bieber's blog]]

Once the first tag is set (using helm), we don't get completion support after that.
This is because, the entire tag string is treated as a single value and Helm tries to complete based only on the full value.
#+BEGIN_SRC emacs-lisp
  (defun my/org-swap-tags (tags)
    "Replace any tags on the current headline with TAGS.

  The assumption is that TAGS will be a string conforming to Org Mode's
  tag format specifications, or nil to remove all tags."
    (let ((old-tags (org-get-tags-string))
          (tags (if tags
                    (concat " " tags)
                  "")))
      (save-excursion
        (beginning-of-line)
        (re-search-forward
         (concat "[ \t]*" (regexp-quote old-tags) "[ \t]*$")
         (line-end-position) t)
        (replace-match tags)
        (org-set-tags t))))

  (defun my/org-set-tags (tag)
    "Add TAG if it is not in the list of tags, remove it otherwise.

  TAG is chosen interactively from the global tags completion table."
    (interactive
     (list (let ((org-last-tags-completion-table
                  (if (derived-mode-p 'org-mode)
                      (org-uniquify
                       (delq nil (append (org-get-buffer-tags)
                                         (org-global-tags-completion-table))))
                    (org-global-tags-completion-table))))
             (org-icompleting-read
              "Tag: " 'org-tags-completion-function nil nil nil
              'org-tags-history))))
    (let* ((cur-list (org-get-tags))
           (new-tags (mapconcat 'identity
                                (if (member tag cur-list)
                                    (delete tag cur-list)
                                  (append cur-list (list tag)))
                                ":"))
           (new (if (> (length new-tags) 1) (concat " :" new-tags ":")
                  nil)))
      (my/org-swap-tags new)))

  (bind-key* "C-c C-q" 'my/org-set-tags)
#+END_SRC

**** Add to org-modules
#+BEGIN_SRC emacs-lisp
  ;; (add-to-list 'org-modules 'org-id)
  ;; (eval-after-load 'org
  ;;   '(org-load-modules-maybe t))
#+END_SRC

**** org-bullets
#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    ;; :disable
    :init
    ;; (setq org-bullets-bullet-list '("●"))
    ;; (setq org-bullets-bullet-list '("○"))
    :config
    (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
#+END_SRC

A good way to find more characters is to use =M-x insert-char=

**** org-agenda
#+BEGIN_SRC emacs-lisp
  (use-package org-agenda
    :ensure nil
    :init
    (setq org-agenda-files
          (seq-filter 'file-exists-p
                      (mapcar (lambda (x) (concat org-directory x))
                              '("organizer.org" "Software/" "Personal/"))))

    (setq org-agenda-tags-column            -120) ; Monitors are wide, might as well use it :/
    (setq org-agenda-skip-scheduled-if-done t)    ; Why isn't this default?
    (setq org-agenda-skip-deadline-if-done  t)
#+END_SRC

Keybinds for org [[id:ebbf9970-d072-4b59-bcaa-5f4b3d71a7d7][located here]]

***** TODO Fix setting org-agenda-files
The lambda will insert a nil if the file/directory doesn't exist.
This will cause whatever reads =org-agenda-files= to blow up because it expects

***** org-agenda custom commands
Based on https://blog.aaronbieber.com/2016/09/24/an-agenda-for-life-with-org-mode.html
#+BEGIN_SRC emacs-lisp
  (defun my/org-skip-subtree-if-habit ()
    "Skip an agenda entry if it has a STYLE property equal to \"habit\"."
    (let ((subtree-end (save-excursion (org-end-of-subtree t))))
      (if (string= (org-entry-get nil "STYLE") "habit")
          subtree-end
        nil)))

  (defun my/org-skip-subtree-if-priority (priority)
    "Skip an agenda subtree if it has a priority of PRIORITY.

  PRIORITY may be one of the characters ?A, ?B, or ?C."
    (let ((subtree-end (save-excursion (org-end-of-subtree t)))
          (pri-value (* 1000 (- org-lowest-priority priority)))
          (pri-current (org-get-priority (thing-at-point 'line t))))
      (if (= pri-value pri-current)
          subtree-end
        nil)))

  (setq org-agenda-custom-commands
        '(("d" "Daily agenda and all TODOs"
           ((tags "PRIORITY=\"A\""
                  ((org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
                   (org-agenda-overriding-header "High-priority unfinished tasks:")))
            (agenda "" ((org-agenda-span 3)))
            (alltodo ""
                     ((org-agenda-skip-function '(or (my/org-skip-subtree-if-habit)
                                                     (my/org-skip-subtree-if-priority ?A)
                                                     (org-agenda-skip-if nil '(scheduled deadline))))
                      (org-agenda-overriding-header "ALL normal priority tasks:"))))
           ((org-agenda-compact-blocks t)))))

  ;; (org-add-agenda-custom-command
  ;;  '("w" "Work agenda"
  ;;    ((tags "PRIORITY=\"A\""
  ;;           ((org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
  ;;            (org-agenda-overriding-header "High-priority unfinished tasks:")))
  ;;     (agenda "" ((org-agenda-span 3)))
  ;;     (alltodo ""
  ;;              ((org-agenda-skip-function '(or (my/org-skip-subtree-if-habit)
  ;;                                              (my/org-skip-subtree-if-priority ?A)
  ;;                                              (org-agenda-skip-if nil '(scheduled deadline))))
  ;;               (org-agenda-overriding-header "ALL normal priority tasks:"))))
  ;;    ((org-agenda-compact-blocks t))))
#+END_SRC

***** org-agenda END
#+BEGIN_SRC emacs-lisp
  )
#+END_SRC

**** org-refile
By [[https://www.reddit.com/r/emacs/comments/4366f9/how_do_orgrefiletargets_work/czg008y/][/u/awalker4 on reddit]].
Show upto 9 levels of headings from the current file and two levels of headings from all agenda files
#+BEGIN_SRC emacs-lisp
  (setq org-refile-targets
        '((nil . (:maxlevel . 5))
          (org-agenda-files . (:maxlevel . 2))))
#+END_SRC

Each element of the list generates a set of possible targets.
/nil/ indicates that all the headings in the current buffer will be considered.

***** TODO Set org-refile targets based on current file
Why would I want to refile something work-related under Softwares etc.
A way to do it is by writing a function that sets /org-refile-targets/ in a let binding making it local.
eg. implementation by abo-abo: [[https://github.com/abo-abo/worf/blob/master/worf.el][worf-refile-other]]

#+BEGIN_SRC emacs-lisp :tangle no
  (load-library "find-lisp")

  (defun my/org-refile-targets ()
  "Refile the current heading to another heading.
  The other heading can be in the current file or in a file that resides
  anywhere below the directory the current file resides in.

  The intent is to move to a similar file. If I'm in work-related file,
  I almost never have to refile something to a personal file."
  (interactive "p")
  (let* (org-refile-targets
         (seq-filter (lambda (x) (string-match-p
                                  (directory-file-name (buffer-file-name)) x))
                     (find-lisp-find-files org-directory org-agenda-file-regexp))))

  (org-refile))

  (bind-key* "C-c C-w" 'my/org-refile-targets)
#+END_SRC

**** org-wunderlist
#+BEGIN_SRC emacs-lisp
  (use-package org-wunderlist
    :disabled
    :init (setq org-wunderlist-file (concat org-directory "Personal/Wunderlist.org")
                org-wunderlist-dir  (concat user-emacs-directory "tmp/org-wunderlist/")))
#+END_SRC

Client-ID and Token stored in private.el

**** org-ac
Autocomplete sources for org mode

#+BEGIN_SRC emacs-lisp
  (use-package org-ac
    :init
    (require 'org-ac)
    (org-ac/config-default))
#+END_SRC

**** org-capture

Show hierarchical headlines when refiling instead of flattening it out
Show all the hierarchical headlines instead of having to step down them
#+BEGIN_SRC emacs-lisp
  (setq org-refile-use-outline-path t)
  (setq org-outline-path-complete-in-steps nil)
#+END_SRC

From [[http://cestlaz.github.io/posts/using-emacs-23-capture-1][Using Emacs 23 - Capture 1]] and [[http://cestlaz.github.io/posts/using-emacs-24-capture-2][Using Emacs 24 - Capture 2]]
#+BEGIN_SRC emacs-lisp
  (setq org-capture-templates
        '(("T" "TODO" entry
           (file+headline org-default-notes-file "Inbox")
           "* TODO %^{Task}%(org-set-property \"CAPTURED\" \"%U\")\n\n%?"
           :jump-to-captured t)

          ("s"  "Snippets of code")

          ("se" "Emacs" entry
           (file (concat org-directory "Software/emacs.org"))
           :jump-to-captured t)

          ("ss" "Shell" entry
           (file (concat org-directory "Software/shell.org"))
           :jump-to-captured t)

          ("sv" "Vim" entry
           (file (concat org-directory "Software/vim.org"))
           :jump-to-captured t)))
#+END_SRC

NOTE: When using several keys, keys using the same prefix key must be sequential in the list and preceded by a 2-element entry explaining the prefix key.
[[http://orgmode.org/manual/Template-elements.html#Template-elements][Template elements]], [[http://orgmode.org/manual/Template-elements.html#Template-expansion][Template expansion]]

We use this to create frames for org-capture directly from the OS as shown [[http://cestlaz.github.io/posts/using-emacs-24-capture-2/][here]].
#+BEGIN_SRC emacs-lisp
  (use-package noflet)

  (defun my/make-capture-frame ()
    "Create a new frame and run org-capture."
    (interactive)
    (make-frame '((name . "capture")))
    (select-frame-by-name "capture")
    (delete-other-windows)
    (noflet ((switch-to-buffer-other-window (buf) (switch-to-buffer buf)))
            (org-capture)))

  (defadvice org-capture-finalize
      (after delete-capture-frame activate)
    "Advise capture-finalize to close the frame"
    (if (equal "capture" (frame-parameter nil 'name))
      (delete-frame)))

  (defadvice org-capture-destroy
      (after delete-capture-frame activate)
    "Advise capture-destroy to close the frame"
    (if (equal "capture" (frame-parameter nil 'name))
      (delete-frame)))
#+END_SRC

***** TODO Split org-capture-templates and move work related stuff to a separate file
**** org-id
I grab the /org-plus-contrib/ version of org-id to match org
#+BEGIN_SRC emacs-lisp
  (use-package org-id
    :ensure org-plus-contrib
    :init
    (setq org-id-link-to-org-use-id 'create-if-interactive-and-no-custom-id)

    :config
#+END_SRC

***** TODO Use org-id globally across all files
:LOGBOOK:
- State "TODO"       from              [2017-03-18 Sat 19:50]
:END:
Example on [[http://stackoverflow.com/a/27158715/734153][Emacs StackExchange]]
#+BEGIN_SRC emacs-lisp
  (setq org-id-track-globally t)
  (setq org-id-extra-files '("~/.emacs.d/config.org"))
#+END_SRC

***** Completion while inserting link
:PROPERTIES:
:ID:       be086bdd-ffcf-4f4e-beb2-a948191895eb
:END:
To use completion, insert link using =C-c C-l= and select =id:= as type and completion should trigger
More details at [[http://emacs.stackexchange.com/a/12434/9690][Emacs StackExchange]]
#+BEGIN_SRC emacs-lisp
  (defun org-id-complete-link (&optional arg)
    "Create an id: link using completion"
    (concat "id:"
            (org-id-get-with-outline-path-completion)))

  (org-link-set-parameters "id"
                           :complete 'org-id-complete-link)
#+END_SRC

***** END
#+BEGIN_SRC emacs-lisp
  )
#+END_SRC

**** htmlize
Syntax highlighting when exporting to HTML? Yes, please!
#+BEGIN_SRC emacs-lisp
  (use-package htmlize
    :disabled)
#+END_SRC

*** Keybinds
:PROPERTIES:
:ID:       ebbf9970-d072-4b59-bcaa-5f4b3d71a7d7
:END:

Custom keymap for org-mode bindings
#+BEGIN_SRC emacs-lisp
  (bind-keys :prefix-map my-org-bindings-map
             :prefix-docstring "This map is used to group together all org-mode settings"
             :prefix "C-c o"
             ("a" . org-agenda)
             ("c" . org-capture))
  ;; :bind (("c" . calendar))
#+END_SRC

Note that these are still part of the /:config/ block
#+BEGIN_SRC emacs-lisp
  ;; (bind-keys :map helm-command-map
  ;;            ("o" . helm-org-in-buffer-headings)
  ;;            ("h" . helm-info-org))
#+end_src

Delete the result block using =C-c C-v k= where =C-c C-v= is the /org-babel-key-prefix/
#+begin_src emacs-lisp
  :bind (:map org-babel-map
              ("k"   . org-babel-remove-result)
              ("C-k" . org-babel-remove-result))
#+end_src

*** use-package END
#+BEGIN_SRC emacs-lisp
)
#+END_SRC

*** TODO Diminish org-indent-mode

** projectile
#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :diminish projectile-mode
    :init
    (setq projectile-enable-caching t)
    (setq projectile-completion-system 'helm)
    :config
    (add-to-list 'projectile-other-file-alist '("cc" "h")) ; .cc -> .h
    (add-to-list 'projectile-other-file-alist '("h" "cc")) ; .h -> .cc
    (projectile-global-mode)
#+END_SRC

*** Keybinds
:PROPERTIES:
:header-args: :tangle no
:END:

Unbind the default prefix. Explained [[https://github.com/bbatsov/projectile/issues/991#issuecomment-248026667][here.]]
#+BEGIN_SRC emacs-lisp
  (define-key projectile-mode-map projectile-keymap-prefix nil)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  :bind (("C-x p" . projectile-keymap-prefix)
         :map       projectile-command-map)
#+END_SRC

*** use-package END
#+BEGIN_SRC emacs-lisp
  )
#+END_SRC

*** TODO Set .x.v as other file for .x
This requires including $STEM/build/lv/ch/rtl in .projectile and ignoring .x
Might need to re-index every time a model is built?

** rainbow-delimiters
Use brighter colors
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :config
    (progn
      (set-face-attribute 'rainbow-delimiters-depth-1-face nil :foreground "dark orange")
      (set-face-attribute 'rainbow-delimiters-depth-2-face nil :foreground "deep pink")
      (set-face-attribute 'rainbow-delimiters-depth-3-face nil :foreground "chartreuse")
      (set-face-attribute 'rainbow-delimiters-depth-4-face nil :foreground "deep sky blue")
      (set-face-attribute 'rainbow-delimiters-depth-5-face nil :foreground "yellow")
      (set-face-attribute 'rainbow-delimiters-depth-6-face nil :foreground "orchid")
      (set-face-attribute 'rainbow-delimiters-depth-7-face nil :foreground "spring green")
      (set-face-attribute 'rainbow-delimiters-depth-8-face nil :foreground "sienna1"))

    :bind (:map emacs-unimpaired-toggle-map ("r" . rainbow-delimiters-mode)))
#+END_SRC

*** TODO Find Better colors for leuven theme

** rainbow-mode
When a color is specified as a hex code or with its name, set the background of the face to the value of the color itself
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-mode
    :defer t)
#+END_SRC

Provides command =rainbow-mode= to toggle this

** undo-tree
This lets us visually walk through the changes we've made, undo back to a certain point (or redo), and go down different branches.
Default binding is =C-x u=
#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :diminish undo-tree-mode
    :commands (undo-tree-visualize)
    :config
      (global-undo-tree-mode)
      (setq undo-tree-visualizer-timestamps t)
      (setq undo-tree-visualizer-diff t))
#+END_SRC

** verilog-mode
#+BEGIN_SRC emacs-lisp
  (use-package verilog-mode
    :load-path "bundle/verilog-mode"
    :mode (("\\.v\\'"    . verilog-mode)
           ("\\.svh?\\'" . verilog-mode)
           ("\\.x\\'"    . verilog-mode))
    :config
    (font-lock-mode 1))
#+END_SRC

** yasnippet
#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :diminish yas-minor-mode

    :init
    ;; (setq-default yas-snippet-dirs (list (concat user-emacs-directory "snippets")))
    (setq yas-wrap-around-region t)  ; Automatically insert selected text at $0, if any
    (yas-global-mode t)

    :config
    (bind-keys :map yas-minor-mode-map
               ("C-c & n"   . yas-new-snippet)
               ("C-c & s"   . yas-insert-snippet)
               ("C-c & v"   . yas-visit-snippet-file)
               ("C-c & r"   . yas-reload-all)
               ("C-c & C-r" . yas-reload-all)))
#+END_SRC

** which-key
Shows which keys can be pressed next. Eg. if you press =C-x= and wait a few seconds, a window pops up with all the key bindings following the currently entered incomplete command.
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :diminish which-key-mode
    :config  (which-key-mode))
#+END_SRC

** leuven-theme
[[https://github.com/fniessen/emacs-leuven-theme][Github Link]]
#+BEGIN_SRC emacs-lisp
  (use-package leuven-theme
    ;; :disabled
    :config
    (load-theme 'leuven t)

    (setq evil-normal-state-cursor   '("#008000" box)
          evil-visual-state-cursor   '("#006FE0" box)
          evil-insert-state-cursor   '("#0000FF" bar)
          evil-replace-state-cursor  '("#D0372D" bar)
          evil-operator-state-cursor '("#D0372D" hollow)
          evil-emacs-state-cursor    '("white"   box))

    (set-face-attribute 'org-agenda-date         nil :height 1.4)
    (set-face-attribute 'org-agenda-date-today   nil :height 1.4)
    (set-face-attribute 'org-agenda-date-weekend nil :height 1.4)
    (set-face-attribute 'trailing-whitespace     nil :background "#DDDDFF"))
#+END_SRC

Load theme first and then override the colors

** TODO hydra
Ideas in https::/github.com/kana/vim-submode

** TODO linum-relative
Relative line-numbers ala vim
#+BEGIN_SRC emacs-lisp
  (use-package linum-relative
    :disabled
    :diminish linum-relative-mode
    :init
    (setq linum-relative-current-symbol "")
    (linum-relative-global-mode t))
#+END_SRC

*** TODO Figure out why it's necessary to explicitly specify :background for 'linum-relative-current-face
Shouldn't it inherit from 'linum?

*** TODO Fix ugly gaps in linum-face when lines wrap. [[http://emacs.stackexchange.com/a/897/9690][StackExchange Discussion]]
#+BEGIN_SRC emacs-lisp
  (defvar my-linum-gapless-margin-display
    `((margin left-margin) ,(propertize "     " 'face 'linum))
    "String used on the margin.")

  (defvar-local my-linum-gapless-margin-overlays nil
    "List of overlays in current buffer.")

  (defun my-linum-gapless-make-overlay-at (p)
    "Create a margin overlay at position P."
    (push (make-overlay p (1+ p)) my-linum-gapless-margin-overlays)
    (overlay-put
     (car my-linum-gapless-margin-overlays) 'before-string
     (propertize " "  'display my-linum-gapless-margin-display)))

  (defun my-linum-gapless-setup-margin-overlays ()
    "Put overlays on each line which is visually wrapped."
    (interactive)
    (let ((ww (- (window-width)
                 (if (= 0 (or (cdr fringe-mode) 1)) 1 0)))
          ov)
      (mapc #'delete-overlay my-linum-gapless-margin-overlays)
      (save-excursion
        (goto-char (point-min))
        (while (null (eobp))
          ;; On each logical line
          (forward-line 1)
          (save-excursion
            (forward-char -1)
            ;; Check if it has multiple visual lines.
            (while (>= (current-column) ww)
              (my-linum-gapless-make-overlay-at (point))
              (forward-char (- ww))))))))

  ;; (add-hook 'linum-before-numbering-hook #'my-linum-gapless-setup-margin-overlays)
#+END_SRC

** TODO macrostep
Expand a macro and enter macrostep-mode by pressing /C-c m e/.
Once in macrostep-mode, press /e/ to expand, /c/ to collapse and /q/ to quit

#+BEGIN_SRC emacs-lisp
  (use-package macrostep
    :disabled
    :bind ("C-c m e" . macrostep-expand))
#+END_SRC

** TODO SLIME
** TODO evil-snipe
Replaces avy

** TODO company-mode
Autocompletion
Reduce delay and ensure that the popup shows up only if the last command has been an editing command.
#+BEGIN_SRC emacs-lisp
  (use-package company
    :disabled
    :diminish company-mode
    :init (setq company-idle-delay 0.25
                company-begin-commands '(self-insert-command))
#+end_src

*** :config
#+BEGIN_SRC emacs-lisp
  :config (add-hook 'after-init-hook 'global-company-mode)
#+END_SRC

Enter by default triggers the completion. This is not what I want. Sometimes I just mean Enter.
This will complete the selection only if I have explicitly interacted with Company. Taken from [[http://emacs.stackexchange.com/a/24800/9690][here]].
#+BEGIN_SRC emacs-lisp
  (defun my/company-active-return ()
    "Complete the current selection, but only if the user has interacted explicitly with Company."
    (interactive)
    (if (company-explicit-action-p)
        (company-complete)
      (call-interactively
       (or (key-binding (this-command-keys))
           (key-binding (kbd "RET"))))))

  (bind-key "<return>" #'my/company-active-return company-active-map)
  (bind-key "RET"      #'my/company-active-return company-active-map)
#+END_SRC

**** TODO Completion for Org
http://orgmode.org/manual/Completion.html
http://emacs.stackexchange.com/a/21173/9690

*** END
#+BEGIN_SRC emacs-lisp
)
#+END_SRC

** TODO vimish-fold
#+BEGIN_SRC emacs-lisp
  (use-package vimish-fold
    :disabled
#+END_SRC

*** :config
#+BEGIN_SRC emacs-lisp
  :config
  (vimish-fold-global-mode 1)
#+END_SRC

**** evil-vimish-mode
#+BEGIN_SRC emacs-lisp
  (use-package evil-vimish-fold
    :config
    (evil-vimish-fold-mode 1))
#+END_SRC

*** END
#+BEGIN_SRC emacs-lisp
  )
#+END_SRC

** TODO monokai-theme
#+BEGIN_SRC emacs-lisp
  (use-package monokai-theme
    :disabled
    :config
    ;; (setq monokai-use-variable-pitch nil
    ;;       monokai-height-minus-1     1.0
    ;;       monokai-height-plus-1      1.0
    ;;       monokai-height-plus-2      1.0
    ;;       monokai-height-plus-3      1.0
    ;;       monokai-height-plus-4      1.0)
    (load-theme 'monokai t))
#+END_SRC

** TODO solarized-theme
#+BEGIN_SRC emacs-lisp
  (use-package solarized-theme
    :disabled
    :config
    ;; (setq solarized-use-variable-pitch nil
    ;;       solarized-height-minus-1     1.0
    ;;       solarized-height-plus-1      1.0
    ;;       solarized-height-plus-2      1.0
    ;;       solarized-height-plus-3      1.0
    ;;       solarized-height-plus-4      1.0)
    (setq solarized-use-less-bold t)
    ;; (set-face-attribute 'linum-relative-current-face nil :foreground "#D33682")

    (setq evil-normal-state-cursor   '("#719e07" box)
          evil-visual-state-cursor   '("#b58900" box)
          evil-insert-state-cursor   '("#268bd2" bar)
          evil-replace-state-cursor  '("#dc322f" bar)
          evil-operator-state-cursor '("#dc322f" hollow)
          evil-emacs-state-cursor    '("white"   box))

    (load-theme 'solarized-light t))
#+END_SRC

* ProgLangEmacs
:PROPERTIES:
:header-args: :tangle yes
:END:
** sml-mode
#+BEGIN_SRC emacs-lisp
  (use-package sml-mode
    :if (eq system-type 'gnu/linux)
    :config
    (add-to-list 'org-structure-template-alist
                 '("sml" "#+BEGIN_SRC sml\n?\n#+END_SRC\n" "<src lang=\"?\">\n\n</src>"))
#+END_SRC

*** TODO Restart the SML REPL
:LOGBOOK:
- State "TODO"       from "TODO"       [2017-03-19 Sun 11:23]
:END:
#+BEGIN_SRC emacs-lisp :tangle no
  (defun my/restart-sml-repl ()
    "Restarts the SML REPL"
    (interactive)
    (progn
      (when (get-buffer-process (current-buffer))
        (goto-char (point-max)) ; First go to the end of the buffer
        (comint-delchar-or-maybe-eof 1); Then kill the REPL (C-d)
        (sleep-for 0.1)) ; This is needed for some reason
      (sml-run "sml" nil)))

  (bind-key* "C-c C-s" 'my/restart-sml-repl)
#+END_SRC

*** Restart SML REPL and load the correct file
#+BEGIN_SRC emacs-lisp
  (defun my/restart-sml-and-run ()
    "Restarts the SML REPL and tries to load the correct .sml file.

  The sml file loaded is the one at the top of the list returned by
  `buffer-list'.

  If this command is executed while in an sml buffer, the point is returned back
  to that buffer after restarting the REPL and loading that file."
    (interactive)
    (let* ((in-sml-buf (derived-mode-p 'sml-mode))
           (repl-buf (get-buffer "*sml*"))
           (sml-file (if in-sml-buf
                         (buffer-file-name)
                       (catch 'break
                         (dolist (buf (buffer-list))
                           (let ((file (buffer-file-name buf)))
                             (when (and (stringp file)
                                        (string-match-p ".*\\.sml\\'" file))
                               ;; Return the first .sml file name from the list
                               ;; and end the loop.
                               (throw 'break file)))))))
           (msg "Restarted SML"))
      (when repl-buf
        (when in-sml-buf
          ;; If the REPL buffer already exists and you are not in it, switch
          ;; to it.
          (switch-to-buffer-other-window repl-buf))
        ;; If the REPL has a live process, kill it
        (when (get-buffer-process (current-buffer))
          (goto-char (point-max)) ; First go to the EOB
          (comint-delchar-or-maybe-eof 1) ; Then kill the REPL (C-d)
          (sleep-for 0.1))) ; Somehow this is needed between kill and respawn
      (if sml-file
          (setq msg (concat msg (format " and now loading `%s'"
                                        (file-name-nondirectory sml-file))))
        ;; If no sml file was found in the buffer list
        (setq sml-file ""))
      (setq msg (concat msg "."))
      (message msg)
      ;; Then start a new process
      (sml-run "sml" sml-file) ; C-c C-s + typing "use foo.sml" in REPL
      ;; Switch back to the sml buffer if you executed this command from there
      (when in-sml-buf
        (switch-to-buffer-other-window (get-file-buffer sml-file)))))

  (bind-key "C-c <C-return>" #'my/restart-sml-and-run inferior-sml-mode-map)
  (bind-key "C-c <C-return>" #'my/restart-sml-and-run sml-mode-map)
#+END_SRC

*** ob-sml
#+BEGIN_SRC emacs-lisp
  (use-package ob-sml
    :config
    (add-to-list 'org-babel-load-languages '(sml . t))
    (org-babel-do-load-languages 'org-babel-load-languages org-babel-load-languages)
#+END_SRC

**** TODO Launch sml-repl if not running when evaluating a code-block
:LOGBOOK:
- State "TODO"       from "TODO"       [2017-03-19 Sun 11:23]
:END:

**** END
#+BEGIN_SRC emacs-lisp
  )
#+END_SRC

*** END
#+BEGIN_SRC emacs-lisp
  )
#+END_SRC

* After
:PROPERTIES:
:header-args: :tangle yes
:END:
** Private config
#+BEGIN_SRC emacs-lisp
  (load (concat user-emacs-directory "private.el") t)
#+END_SRC

** TODO After theme
Set the background of the line number column to match that of the modeline
#+BEGIN_SRC emacs-lisp
  ;; (set-face-attribute 'linum nil :font my-monospaced-font :background (face-attribute 'mode-line :background nil t) :inverse-video nil :box nil :strike-through nil :overline nil :underline nil :slant 'normal :weight 'normal)
  ;; (set-face-attribute 'linum-relative-current-face nil :inherit 'linum :weight 'bold :background (face-attribute 'linum :background nil t))
#+END_SRC

* ToDo Items
** DONE Add CUSTOM_ID property to all headings
:LOGBOOK:
- State "DONE"       from "TODO"       [2017-01-05 Thu 19:21]
:END:
CUSTOM_ID value is the full hierarchical path to the section heading eg. =org*org-capture=
[[https://writequit.org/articles/emacs-org-mode-generate-ids.html][Autogenerating CUSTOM_IDs]]
